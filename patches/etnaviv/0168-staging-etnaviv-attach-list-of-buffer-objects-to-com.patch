From fe2bc1e323732885a458617d59d1aff500dd2a36 Mon Sep 17 00:00:00 2001
From: Russell King <rmk+kernel@arm.linux.org.uk>
Date: Sun, 22 Nov 2015 23:01:45 +0000
Subject: [PATCH 168/195] staging: etnaviv: attach list of buffer objects to
 command buffer

The existing method of tracking the active buffer objects does not work
when we permit buffer objects to be accessed by multiple GPUs.

Resolve this by referencing the buffer objects which the command buffer
will be operating on to the command buffer itself.

Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
---
 drivers/staging/etnaviv/etnaviv_drv.h        | 12 ++++++
 drivers/staging/etnaviv/etnaviv_gem_submit.c | 15 +------
 drivers/staging/etnaviv/etnaviv_gpu.c        | 60 ++++++++++++----------------
 drivers/staging/etnaviv/etnaviv_gpu.h        |  5 ++-
 4 files changed, 43 insertions(+), 49 deletions(-)

diff --git a/drivers/staging/etnaviv/etnaviv_drv.h b/drivers/staging/etnaviv/etnaviv_drv.h
index 7101de4..a5cee7d 100644
--- a/drivers/staging/etnaviv/etnaviv_drv.h
+++ b/drivers/staging/etnaviv/etnaviv_drv.h
@@ -123,6 +123,18 @@ u32 etnaviv_readl(const void __iomem *addr);
 #define DBG(fmt, ...) DRM_DEBUG(fmt"\n", ##__VA_ARGS__)
 #define VERB(fmt, ...) if (0) DRM_DEBUG(fmt"\n", ##__VA_ARGS__)
 
+/*
+ * Return the storage size of a structure with a variable length array.
+ * The array is nelem elements of elem_size, where the base structure
+ * is defined by base.  If the size overflows size_t, return zero.
+ */
+static inline size_t size_vstruct(size_t nelem, size_t elem_size, size_t base)
+{
+	if (elem_size && nelem > (SIZE_MAX - base) / elem_size)
+		return 0;
+	return base + nelem * elem_size;
+}
+
 /* returns true if fence a comes after fence b */
 static inline bool fence_after(u32 a, u32 b)
 {
diff --git a/drivers/staging/etnaviv/etnaviv_gem_submit.c b/drivers/staging/etnaviv/etnaviv_gem_submit.c
index f056388..3ee3686 100644
--- a/drivers/staging/etnaviv/etnaviv_gem_submit.c
+++ b/drivers/staging/etnaviv/etnaviv_gem_submit.c
@@ -32,18 +32,6 @@ static inline void __user *to_user_ptr(u64 address)
 	return (void __user *)(uintptr_t)address;
 }
 
-/*
- * Return the storage size of a structure with a variable length array.
- * The array is nelem elements of elem_size, where the base structure
- * is defined by base.  If the size overflows size_t, return zero.
- */
-static size_t size_vstruct(size_t nelem, size_t elem_size, size_t base)
-{
-	if (elem_size && nelem > (SIZE_MAX - base) / elem_size)
-		return 0;
-	return base + nelem * elem_size;
-}
-
 static struct etnaviv_gem_submit *submit_create(struct drm_device *dev,
 		struct etnaviv_gpu *gpu, size_t nr)
 {
@@ -330,7 +318,8 @@ int etnaviv_ioctl_gem_submit(struct drm_device *dev, void *data,
 	bos = drm_malloc_ab(args->nr_bos, sizeof(*bos));
 	relocs = drm_malloc_ab(args->nr_relocs, sizeof(*relocs));
 	stream = drm_malloc_ab(1, args->stream_size);
-	cmdbuf = etnaviv_gpu_cmdbuf_new(gpu, ALIGN(args->stream_size, 8) + 8);
+	cmdbuf = etnaviv_gpu_cmdbuf_new(gpu, ALIGN(args->stream_size, 8) + 8,
+					args->nr_bos);
 	if (!bos || !relocs || !stream || !cmdbuf) {
 		ret = -ENOMEM;
 		goto err_submit_cmds;
diff --git a/drivers/staging/etnaviv/etnaviv_gpu.c b/drivers/staging/etnaviv/etnaviv_gpu.c
index 57a8d97..23d6aaa 100644
--- a/drivers/staging/etnaviv/etnaviv_gpu.c
+++ b/drivers/staging/etnaviv/etnaviv_gpu.c
@@ -544,7 +544,7 @@ int etnaviv_gpu_init(struct etnaviv_gpu *gpu)
 	}
 
 	/* Create buffer: */
-	gpu->buffer = etnaviv_gpu_cmdbuf_new(gpu, PAGE_SIZE);
+	gpu->buffer = etnaviv_gpu_cmdbuf_new(gpu, PAGE_SIZE, 0);
 	if (!gpu->buffer) {
 		ret = -ENOMEM;
 		dev_err(gpu->dev, "could not create command buffer\n");
@@ -924,11 +924,14 @@ static void event_free(struct etnaviv_gpu *gpu, unsigned int event)
  * Cmdstream submission/retirement:
  */
 
-struct etnaviv_cmdbuf *etnaviv_gpu_cmdbuf_new(struct etnaviv_gpu *gpu, u32 size)
+struct etnaviv_cmdbuf *etnaviv_gpu_cmdbuf_new(struct etnaviv_gpu *gpu, u32 size,
+	size_t nr_bos)
 {
 	struct etnaviv_cmdbuf *cmdbuf;
+	size_t sz = size_vstruct(nr_bos, sizeof(cmdbuf->bo[0]),
+				 sizeof(*cmdbuf));
 
-	cmdbuf = kzalloc(sizeof(*cmdbuf), GFP_KERNEL);
+	cmdbuf = kzalloc(sz, GFP_KERNEL);
 	if (!cmdbuf)
 		return NULL;
 
@@ -959,34 +962,23 @@ static void retire_worker(struct work_struct *work)
 	struct drm_device *dev = gpu->drm;
 	u32 fence = gpu->completed_fence;
 	struct etnaviv_cmdbuf *cmdbuf, *tmp;
+	unsigned int i;
 
 	mutex_lock(&dev->struct_mutex);
-
-	while (!list_empty(&gpu->active_list)) {
-		struct etnaviv_gem_object *obj;
-
-		obj = list_first_entry(&gpu->active_list,
-				struct etnaviv_gem_object, mm_list);
-
-		if ((!(obj->access & ETNA_SUBMIT_BO_READ) ||
-		     fence_after_eq(fence, obj->read_fence)) &&
-		    (!(obj->access & ETNA_SUBMIT_BO_WRITE) ||
-		     fence_after_eq(fence, obj->write_fence))) {
-			/* move to inactive: */
-			etnaviv_gem_move_to_inactive(&obj->base);
-			etnaviv_gem_put_iova(gpu, &obj->base);
-			drm_gem_object_unreference(&obj->base);
-		} else {
-			break;
-		}
-	}
-
 	list_for_each_entry_safe(cmdbuf, tmp, &gpu->active_cmd_list,
 				 gpu_active_list) {
-		if (fence_after_eq(fence, cmdbuf->fence)) {
-			list_del(&cmdbuf->gpu_active_list);
-			etnaviv_gpu_cmdbuf_free(cmdbuf);
+		if (!fence_after_eq(fence, cmdbuf->fence))
+			break;
+
+		list_del(&cmdbuf->gpu_active_list);
+
+		for (i = 0; i < cmdbuf->nr_bos; i++) {
+			etnaviv_gem_move_to_inactive(&cmdbuf->bo[i]->base);
+			etnaviv_gem_put_iova(gpu, &cmdbuf->bo[i]->base);
+			drm_gem_object_unreference(&cmdbuf->bo[i]->base);
 		}
+
+		etnaviv_gpu_cmdbuf_free(cmdbuf);
 	}
 
 	gpu->retired_fence = fence;
@@ -1132,27 +1124,25 @@ int etnaviv_gpu_submit(struct etnaviv_gpu *gpu,
 
 	for (i = 0; i < submit->nr_bos; i++) {
 		struct etnaviv_gem_object *etnaviv_obj = submit->bos[i].obj;
+		u32 iova;
+
+		/* Each cmdbuf takes a reference on the bo and iova */
+		drm_gem_object_reference(&etnaviv_obj->base);
+		etnaviv_gem_get_iova_locked(gpu, &etnaviv_obj->base, &iova);
+		cmdbuf->bo[i] = etnaviv_obj;
 
 		/* can't happen yet.. but when we add 2d support we'll have
 		 * to deal w/ cross-ring synchronization:
 		 */
 		WARN_ON(is_active(etnaviv_obj) && (etnaviv_obj->gpu != gpu));
 
-		if (!is_active(etnaviv_obj)) {
-			u32 iova;
-
-			/* ring takes a reference to the bo and iova: */
-			drm_gem_object_reference(&etnaviv_obj->base);
-			etnaviv_gem_get_iova_locked(gpu, &etnaviv_obj->base,
-						    &iova);
-		}
-
 		if (submit->bos[i].flags & (ETNA_SUBMIT_BO_READ |
 					    ETNA_SUBMIT_BO_WRITE))
 			etnaviv_gem_move_to_active(&etnaviv_obj->base, gpu,
 						   submit->bos[i].flags,
 						   submit->fence);
 	}
+	cmdbuf->nr_bos = submit->nr_bos;
 	hangcheck_timer_reset(gpu);
 
 	return 0;
diff --git a/drivers/staging/etnaviv/etnaviv_gpu.h b/drivers/staging/etnaviv/etnaviv_gpu.h
index 000cd97..c1c849f 100644
--- a/drivers/staging/etnaviv/etnaviv_gpu.h
+++ b/drivers/staging/etnaviv/etnaviv_gpu.h
@@ -155,6 +155,9 @@ struct etnaviv_cmdbuf {
 	u32 exec_state;
 	/* per GPU in-flight list */
 	struct list_head gpu_active_list;
+	/* BOs attached to this command buffer */
+	unsigned int nr_bos;
+	struct etnaviv_gem_object *bo[0];
 };
 
 static inline void gpu_write(struct etnaviv_gpu *gpu, u32 reg, u32 data)
@@ -193,7 +196,7 @@ int etnaviv_gpu_wait_obj_inactive(struct etnaviv_gpu *gpu,
 int etnaviv_gpu_submit(struct etnaviv_gpu *gpu,
 	struct etnaviv_gem_submit *submit, struct etnaviv_cmdbuf *cmdbuf);
 struct etnaviv_cmdbuf *etnaviv_gpu_cmdbuf_new(struct etnaviv_gpu *gpu,
-					      u32 size);
+					      u32 size, size_t nr_bos);
 void etnaviv_gpu_cmdbuf_free(struct etnaviv_cmdbuf *cmdbuf);
 int etnaviv_gpu_pm_get_sync(struct etnaviv_gpu *gpu);
 void etnaviv_gpu_pm_put(struct etnaviv_gpu *gpu);
-- 
2.6.2

