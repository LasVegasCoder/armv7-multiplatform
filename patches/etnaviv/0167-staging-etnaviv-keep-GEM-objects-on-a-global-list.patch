From bf2640426ff762ede8151f149d21a4ce52b2eacc Mon Sep 17 00:00:00 2001
From: Russell King <rmk+kernel@arm.linux.org.uk>
Date: Sun, 22 Nov 2015 23:01:45 +0000
Subject: [PATCH 167/194] staging: etnaviv: keep GEM objects on a global list

Always keep all GEM objects on a global list, rather than moving them
between an inactive and GPU list.

Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
---
 drivers/staging/etnaviv/etnaviv_drv.c | 16 ++--------------
 drivers/staging/etnaviv/etnaviv_drv.h |  5 +++--
 drivers/staging/etnaviv/etnaviv_gem.c | 11 +++++------
 drivers/staging/etnaviv/etnaviv_gem.h |  9 +--------
 4 files changed, 11 insertions(+), 30 deletions(-)

diff --git a/drivers/staging/etnaviv/etnaviv_drv.c b/drivers/staging/etnaviv/etnaviv_drv.c
index 540cd6b..6b6e5c1 100644
--- a/drivers/staging/etnaviv/etnaviv_drv.c
+++ b/drivers/staging/etnaviv/etnaviv_drv.c
@@ -138,20 +138,8 @@ static void etnaviv_preclose(struct drm_device *dev, struct drm_file *file)
 static int etnaviv_gem_show(struct drm_device *dev, struct seq_file *m)
 {
 	struct etnaviv_drm_private *priv = dev->dev_private;
-	struct etnaviv_gpu *gpu;
-	unsigned int i;
-
-	for (i = 0; i < ETNA_MAX_PIPES; i++) {
-		gpu = priv->gpu[i];
-		if (gpu) {
-			seq_printf(m, "Active Objects (%s):\n",
-				   dev_name(gpu->dev));
-			etnaviv_gem_describe_objects(&gpu->active_list, m);
-		}
-	}
 
-	seq_puts(m, "Inactive Objects:\n");
-	etnaviv_gem_describe_objects(&priv->inactive_list, m);
+	etnaviv_gem_describe_objects(priv, m);
 
 	return 0;
 }
@@ -566,7 +554,7 @@ static int etnaviv_bind(struct device *dev)
 		goto out_wq;
 	}
 
-	INIT_LIST_HEAD(&priv->inactive_list);
+	INIT_LIST_HEAD(&priv->gem_list);
 	priv->num_gpus = 0;
 
 	dev_set_drvdata(dev, drm);
diff --git a/drivers/staging/etnaviv/etnaviv_drv.h b/drivers/staging/etnaviv/etnaviv_drv.h
index 21888f2..7101de4 100644
--- a/drivers/staging/etnaviv/etnaviv_drv.h
+++ b/drivers/staging/etnaviv/etnaviv_drv.h
@@ -55,7 +55,7 @@ struct etnaviv_drm_private {
 	struct etnaviv_gpu *gpu[ETNA_MAX_PIPES];
 
 	/* list of GEM objects: */
-	struct list_head inactive_list;
+	struct list_head gem_list;
 
 	struct workqueue_struct *wq;
 };
@@ -111,7 +111,8 @@ bool etnaviv_cmd_validate_one(struct etnaviv_gpu *gpu,
 	struct drm_etnaviv_gem_submit_reloc *relocs, unsigned int reloc_size);
 
 #ifdef CONFIG_DEBUG_FS
-void etnaviv_gem_describe_objects(struct list_head *list, struct seq_file *m);
+void etnaviv_gem_describe_objects(struct etnaviv_drm_private *priv,
+	struct seq_file *m);
 #endif
 
 void __iomem *etnaviv_ioremap(struct platform_device *pdev, const char *name,
diff --git a/drivers/staging/etnaviv/etnaviv_gem.c b/drivers/staging/etnaviv/etnaviv_gem.c
index 0fe910d..392b12e 100644
--- a/drivers/staging/etnaviv/etnaviv_gem.c
+++ b/drivers/staging/etnaviv/etnaviv_gem.c
@@ -343,7 +343,6 @@ void etnaviv_gem_move_to_active(struct drm_gem_object *obj,
 void etnaviv_gem_move_to_inactive(struct drm_gem_object *obj)
 {
 	struct drm_device *dev = obj->dev;
-	struct etnaviv_drm_private *priv = dev->dev_private;
 	struct etnaviv_gem_object *etnaviv_obj = to_etnaviv_bo(obj);
 
 	WARN_ON(!mutex_is_locked(&dev->struct_mutex));
@@ -353,7 +352,6 @@ void etnaviv_gem_move_to_inactive(struct drm_gem_object *obj)
 	etnaviv_obj->write_fence = 0;
 	etnaviv_obj->access = 0;
 	list_del_init(&etnaviv_obj->mm_list);
-	list_add_tail(&etnaviv_obj->mm_list, &priv->inactive_list);
 }
 
 static inline enum dma_data_direction etnaviv_op_to_dma_dir(u32 op)
@@ -450,13 +448,14 @@ static void etnaviv_gem_describe(struct drm_gem_object *obj, struct seq_file *m)
 			off, etnaviv_obj->vaddr, obj->size);
 }
 
-void etnaviv_gem_describe_objects(struct list_head *list, struct seq_file *m)
+void etnaviv_gem_describe_objects(struct etnaviv_drm_private *priv,
+	struct seq_file *m)
 {
 	struct etnaviv_gem_object *etnaviv_obj;
 	int count = 0;
 	size_t size = 0;
 
-	list_for_each_entry(etnaviv_obj, list, mm_list) {
+	list_for_each_entry(etnaviv_obj, &priv->gem_list, gem_node) {
 		struct drm_gem_object *obj = &etnaviv_obj->base;
 
 		seq_puts(m, "   ");
@@ -492,7 +491,7 @@ void etnaviv_gem_free_object(struct drm_gem_object *obj)
 	/* object should not be on active list: */
 	WARN_ON(is_active(etnaviv_obj));
 
-	list_del(&etnaviv_obj->mm_list);
+	list_del(&etnaviv_obj->gem_node);
 
 	list_for_each_entry_safe(mapping, tmp, &etnaviv_obj->vram_list,
 				 obj_node) {
@@ -519,7 +518,7 @@ int etnaviv_gem_obj_add(struct drm_device *dev, struct drm_gem_object *obj)
 	if (ret)
 		return ret;
 
-	list_add_tail(&etnaviv_obj->mm_list, &priv->inactive_list);
+	list_add_tail(&etnaviv_obj->gem_node, &priv->gem_list);
 	mutex_unlock(&dev->struct_mutex);
 
 	return 0;
diff --git a/drivers/staging/etnaviv/etnaviv_gem.h b/drivers/staging/etnaviv/etnaviv_gem.h
index 3fcfa62..45136d1 100644
--- a/drivers/staging/etnaviv/etnaviv_gem.h
+++ b/drivers/staging/etnaviv/etnaviv_gem.h
@@ -47,14 +47,7 @@ struct etnaviv_gem_object {
 
 	u32 flags;
 
-	/* And object is either:
-	 *  inactive - on priv->inactive_list
-	 *  active   - on one one of the gpu's active_list..  well, at
-	 *     least for now we don't have (I don't think) hw sync between
-	 *     2d and 3d one devices which have both, meaning we need to
-	 *     block on submit if a bo is already on other ring
-	 *
-	 */
+	struct list_head gem_node;
 	struct list_head mm_list;
 	struct etnaviv_gpu *gpu;     /* non-null if active */
 	u32 access;
-- 
2.6.2

