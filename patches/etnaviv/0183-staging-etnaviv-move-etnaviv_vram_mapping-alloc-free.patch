From e8219d032ca7e373e8823affff42e390f37ba60b Mon Sep 17 00:00:00 2001
From: Russell King <rmk+kernel@arm.linux.org.uk>
Date: Mon, 30 Nov 2015 11:39:13 +0000
Subject: [PATCH 183/195] staging: etnaviv: move etnaviv_vram_mapping
 alloc/free

Move the main responsibility for allocating and freeing the
etnaviv_vram_mapping structure out of the MMU code and into the GEM
code.

Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
---
 drivers/staging/etnaviv/etnaviv_gem.c | 18 ++++++++++++++++--
 drivers/staging/etnaviv/etnaviv_mmu.c | 34 +++++++---------------------------
 drivers/staging/etnaviv/etnaviv_mmu.h |  2 +-
 3 files changed, 24 insertions(+), 30 deletions(-)

diff --git a/drivers/staging/etnaviv/etnaviv_gem.c b/drivers/staging/etnaviv/etnaviv_gem.c
index 449298b..15b092e 100644
--- a/drivers/staging/etnaviv/etnaviv_gem.c
+++ b/drivers/staging/etnaviv/etnaviv_gem.c
@@ -268,9 +268,21 @@ int etnaviv_gem_get_iova_locked(struct etnaviv_gpu *gpu,
 	if (IS_ERR(pages))
 		return PTR_ERR(pages);
 
-	/* etnaviv_iommu_map_gem initialises use-count */
+	mapping = kzalloc(sizeof(*mapping), GFP_KERNEL);
+	if (!mapping)
+		return -ENOMEM;
+
+	INIT_LIST_HEAD(&mapping->scan_node);
+	mapping->object = etnaviv_obj;
+	mapping->mmu = mmu;
+	mapping->use = 1;
+
 	ret = etnaviv_iommu_map_gem(gpu->mmu, etnaviv_obj, gpu->memory_base,
-				    &mapping);
+				    mapping);
+	if (ret < 0)
+		kfree(mapping);
+	else
+		list_add_tail(&mapping->obj_node, &etnaviv_obj->vram_list);
 
 out:
 	if (!ret) {
@@ -497,6 +509,8 @@ void etnaviv_gem_free_object(struct drm_gem_object *obj)
 				 obj_node) {
 		WARN_ON(mapping->use);
 		etnaviv_iommu_unmap_gem(mapping->mmu, mapping);
+		list_del(&mapping->obj_node);
+		kfree(mapping);
 	}
 
 	drm_gem_free_mmap_offset(obj);
diff --git a/drivers/staging/etnaviv/etnaviv_mmu.c b/drivers/staging/etnaviv/etnaviv_mmu.c
index 0d46a26..2f6a5f1 100644
--- a/drivers/staging/etnaviv/etnaviv_mmu.c
+++ b/drivers/staging/etnaviv/etnaviv_mmu.c
@@ -93,22 +93,13 @@ int etnaviv_iommu_unmap(struct etnaviv_iommu *iommu, u32 iova,
 
 int etnaviv_iommu_map_gem(struct etnaviv_iommu *mmu,
 	struct etnaviv_gem_object *etnaviv_obj, u32 memory_base,
-	struct etnaviv_vram_mapping **out_mapping)
+	struct etnaviv_vram_mapping *mapping)
 {
-	struct etnaviv_vram_mapping *mapping, *free = NULL;
+	struct etnaviv_vram_mapping *free = NULL;
 	struct sg_table *sgt = etnaviv_obj->sgt;
 	struct drm_mm_node *node;
 	int ret;
 
-	mapping = kzalloc(sizeof(*mapping), GFP_KERNEL);
-	if (!mapping)
-		return -ENOMEM;
-
-	INIT_LIST_HEAD(&mapping->scan_node);
-	mapping->object = etnaviv_obj;
-	mapping->mmu = mmu;
-	mapping->use = 1;
-
 	/* v1 MMU can optimize single entry (contiguous) scatterlists */
 	if (sgt->nents == 1 && !(etnaviv_obj->flags & ETNA_BO_FORCE_MMU)) {
 		u32 iova;
@@ -116,12 +107,7 @@ int etnaviv_iommu_map_gem(struct etnaviv_iommu *mmu,
 		iova = sg_dma_address(sgt->sgl) - memory_base;
 		if (iova < 0x80000000 - sg_dma_len(sgt->sgl)) {
 			mapping->iova = iova;
-			list_add_tail(&mapping->obj_node,
-				      &etnaviv_obj->vram_list);
-			list_add_tail(&mapping->mmu_node,
-				      &mmu->mappings);
-			if (out_mapping)
-				*out_mapping = mapping;
+			list_add_tail(&mapping->mmu_node, &mmu->mappings);
 			return 0;
 		}
 	}
@@ -191,8 +177,10 @@ int etnaviv_iommu_map_gem(struct etnaviv_iommu *mmu,
 				list_del_init(&m->scan_node);
 
 		list_for_each_entry_safe(m, n, &list, scan_node) {
-			list_del_init(&m->scan_node);
 			etnaviv_iommu_unmap_gem(mmu, m);
+			list_del(&m->scan_node);
+			list_del(&m->obj_node);
+			kfree(m);
 		}
 
 		/*
@@ -203,10 +191,8 @@ int etnaviv_iommu_map_gem(struct etnaviv_iommu *mmu,
 		mmu->need_flush = true;
 	}
 
-	if (ret < 0) {
-		kfree(mapping);
+	if (ret < 0)
 		return ret;
-	}
 
 	mmu->last_iova = node->start + etnaviv_obj->base.size;
 	mapping->iova = node->start;
@@ -215,14 +201,10 @@ int etnaviv_iommu_map_gem(struct etnaviv_iommu *mmu,
 
 	if (ret < 0) {
 		drm_mm_remove_node(node);
-		kfree(mapping);
 		return ret;
 	}
 
-	list_add_tail(&mapping->obj_node, &etnaviv_obj->vram_list);
 	list_add_tail(&mapping->mmu_node, &mmu->mappings);
-	if (out_mapping)
-		*out_mapping = mapping;
 
 	return ret;
 }
@@ -243,8 +225,6 @@ void etnaviv_iommu_unmap_gem(struct etnaviv_iommu *mmu,
 	}
 
 	list_del(&mapping->mmu_node);
-	list_del(&mapping->obj_node);
-	kfree(mapping);
 }
 
 void etnaviv_iommu_destroy(struct etnaviv_iommu *mmu)
diff --git a/drivers/staging/etnaviv/etnaviv_mmu.h b/drivers/staging/etnaviv/etnaviv_mmu.h
index 367c29e..d612adb 100644
--- a/drivers/staging/etnaviv/etnaviv_mmu.h
+++ b/drivers/staging/etnaviv/etnaviv_mmu.h
@@ -56,7 +56,7 @@ int etnaviv_iommu_unmap(struct etnaviv_iommu *iommu, u32 iova,
 	struct sg_table *sgt, unsigned len);
 int etnaviv_iommu_map_gem(struct etnaviv_iommu *mmu,
 	struct etnaviv_gem_object *etnaviv_obj, u32 memory_base,
-	struct etnaviv_vram_mapping **mapping);
+	struct etnaviv_vram_mapping *mapping);
 void etnaviv_iommu_unmap_gem(struct etnaviv_iommu *mmu,
 	struct etnaviv_vram_mapping *mapping);
 void etnaviv_iommu_destroy(struct etnaviv_iommu *iommu);
-- 
2.6.2

