From 786f4d9e19df6b31cc0971938e6caaa0e0f57c3d Mon Sep 17 00:00:00 2001
From: Russell King <rmk+kernel@arm.linux.org.uk>
Date: Thu, 19 Nov 2015 23:07:38 +0000
Subject: [PATCH 160/195] staging: etnaviv: split pin/unpin from locking
 operations

Split the object iova pinning/unpinning from the object locking
operations.  This will allow us to move more of the submission out
from under the DRM struct mutex.

Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
---
 drivers/staging/etnaviv/etnaviv_gem_submit.c | 88 +++++++++++++++++-----------
 1 file changed, 53 insertions(+), 35 deletions(-)

diff --git a/drivers/staging/etnaviv/etnaviv_gem_submit.c b/drivers/staging/etnaviv/etnaviv_gem_submit.c
index f195314..7bf26ac 100644
--- a/drivers/staging/etnaviv/etnaviv_gem_submit.c
+++ b/drivers/staging/etnaviv/etnaviv_gem_submit.c
@@ -108,29 +108,23 @@ out_unlock:
 	return ret;
 }
 
-static void submit_unlock_unpin_bo(struct etnaviv_gem_submit *submit, int i)
+static void submit_unlock_object(struct etnaviv_gem_submit *submit, int i)
 {
-	struct etnaviv_gem_object *etnaviv_obj = submit->bos[i].obj;
-
-	if (submit->bos[i].flags & BO_PINNED)
-		etnaviv_gem_put_iova(submit->gpu, &etnaviv_obj->base);
+	if (submit->bos[i].flags & BO_LOCKED) {
+		struct etnaviv_gem_object *etnaviv_obj = submit->bos[i].obj;
 
-	if (submit->bos[i].flags & BO_LOCKED)
 		ww_mutex_unlock(&etnaviv_obj->resv->lock);
-
-	submit->bos[i].iova = 0;
-	submit->bos[i].flags &= ~(BO_LOCKED | BO_PINNED);
+		submit->bos[i].flags &= ~BO_LOCKED;
+	}
 }
 
-/* This is where we make sure all the bo's are reserved and pin'd: */
-static int submit_validate_objects(struct etnaviv_gem_submit *submit)
+static int submit_lock_objects(struct etnaviv_gem_submit *submit)
 {
 	int contended, slow_locked = -1, i, ret = 0;
 
 retry:
 	for (i = 0; i < submit->nr_bos; i++) {
 		struct etnaviv_gem_object *etnaviv_obj = submit->bos[i].obj;
-		u32 iova;
 
 		if (slow_locked == i)
 			slow_locked = -1;
@@ -147,23 +141,6 @@ retry:
 				goto fail;
 			submit->bos[i].flags |= BO_LOCKED;
 		}
-
-
-		/* if locking succeeded, pin bo: */
-		ret = etnaviv_gem_get_iova_locked(submit->gpu,
-						  &etnaviv_obj->base, &iova);
-
-		/* this would break the logic in the fail path.. there is no
-		 * reason for this to happen, but just to be on the safe side
-		 * let's notice if this starts happening in the future:
-		 */
-		WARN_ON(ret == -EDEADLK);
-
-		if (ret)
-			goto fail;
-
-		submit->bos[i].flags |= BO_PINNED;
-		submit->bos[i].iova = iova;
 	}
 
 	ww_acquire_done(&submit->ticket);
@@ -172,10 +149,10 @@ retry:
 
 fail:
 	for (; i >= 0; i--)
-		submit_unlock_unpin_bo(submit, i);
+		submit_unlock_object(submit, i);
 
 	if (slow_locked > 0)
-		submit_unlock_unpin_bo(submit, slow_locked);
+		submit_unlock_object(submit, slow_locked);
 
 	if (ret == -EDEADLK) {
 		struct etnaviv_gem_object *etnaviv_obj;
@@ -195,6 +172,41 @@ fail:
 	return ret;
 }
 
+static void submit_unpin_objects(struct etnaviv_gem_submit *submit)
+{
+	int i;
+
+	for (i = 0; i < submit->nr_bos; i++) {
+		struct etnaviv_gem_object *etnaviv_obj = submit->bos[i].obj;
+
+		if (submit->bos[i].flags & BO_PINNED)
+			etnaviv_gem_put_iova(submit->gpu, &etnaviv_obj->base);
+
+		submit->bos[i].iova = 0;
+		submit->bos[i].flags &= ~BO_PINNED;
+	}
+}
+
+static int submit_pin_objects(struct etnaviv_gem_submit *submit)
+{
+	int i, ret = 0;
+
+	for (i = 0; i < submit->nr_bos; i++) {
+		struct etnaviv_gem_object *etnaviv_obj = submit->bos[i].obj;
+		u32 iova;
+
+		ret = etnaviv_gem_get_iova_locked(submit->gpu,
+						  &etnaviv_obj->base, &iova);
+		if (ret)
+			break;
+
+		submit->bos[i].flags |= BO_PINNED;
+		submit->bos[i].iova = iova;
+	}
+
+	return ret;
+}
+
 static int submit_bo(struct etnaviv_gem_submit *submit, u32 idx,
 		struct etnaviv_gem_object **obj, u32 *iova)
 {
@@ -259,14 +271,14 @@ static int submit_reloc(struct etnaviv_gem_submit *submit, void *stream,
 	return 0;
 }
 
-static void submit_cleanup(struct etnaviv_gem_submit *submit, bool fail)
+static void submit_cleanup(struct etnaviv_gem_submit *submit)
 {
 	unsigned i;
 
 	for (i = 0; i < submit->nr_bos; i++) {
 		struct etnaviv_gem_object *etnaviv_obj = submit->bos[i].obj;
 
-		submit_unlock_unpin_bo(submit, i);
+		submit_unlock_object(submit, i);
 		drm_gem_object_unreference(&etnaviv_obj->base);
 	}
 
@@ -377,7 +389,11 @@ int etnaviv_ioctl_gem_submit(struct drm_device *dev, void *data,
 	if (ret)
 		goto out;
 
-	ret = submit_validate_objects(submit);
+	ret = submit_lock_objects(submit);
+	if (ret)
+		goto out;
+
+	ret = submit_pin_objects(submit);
 	if (ret)
 		goto out;
 
@@ -402,8 +418,10 @@ int etnaviv_ioctl_gem_submit(struct drm_device *dev, void *data,
 	args->fence = submit->fence;
 
 out:
-	if (submit)
+	if (submit) {
+		submit_unpin_objects(submit);
 		submit_cleanup(submit, !!ret);
+	}
 	mutex_unlock(&dev->struct_mutex);
 
 	etnaviv_gpu_pm_put(gpu);
-- 
2.6.2

