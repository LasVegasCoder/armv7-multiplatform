From 0b5b1fb74462319169fb48cbf132085f5743a8c8 Mon Sep 17 00:00:00 2001
From: Russell King <rmk+kernel@arm.linux.org.uk>
Date: Mon, 30 Nov 2015 11:39:13 +0000
Subject: [PATCH 179/194] staging: etnaviv: arrange for IOVAs to take an object
 refcount

An IOVA reference is also a reference to the object.  To ensure
proper behaviour, arrange for an IOVA refcount to also take an
object refcount.

Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
---
 drivers/staging/etnaviv/etnaviv_gem.c | 12 +++++++++---
 drivers/staging/etnaviv/etnaviv_gpu.c | 11 ++++++-----
 2 files changed, 15 insertions(+), 8 deletions(-)

diff --git a/drivers/staging/etnaviv/etnaviv_gem.c b/drivers/staging/etnaviv/etnaviv_gem.c
index c2a3948..46403b6 100644
--- a/drivers/staging/etnaviv/etnaviv_gem.c
+++ b/drivers/staging/etnaviv/etnaviv_gem.c
@@ -262,8 +262,7 @@ int etnaviv_gem_get_iova_locked(struct etnaviv_gpu *gpu,
 	mapping = etnaviv_gem_get_vram_mapping(etnaviv_obj, gpu->mmu);
 	if (mapping) {
 		mapping->use += 1;
-		*iova = mapping->iova;
-		return 0;
+		goto out;
 	}
 
 	pages = etnaviv_gem_get_pages(etnaviv_obj);
@@ -273,8 +272,13 @@ int etnaviv_gem_get_iova_locked(struct etnaviv_gpu *gpu,
 	/* etnaviv_iommu_map_gem initialises use-count */
 	ret = etnaviv_iommu_map_gem(gpu->mmu, etnaviv_obj, gpu->memory_base,
 				    &mapping);
-	if (!ret)
+
+out:
+	if (!ret) {
+		/* Take a reference on the object */
+		drm_gem_object_reference(obj);
 		*iova = mapping->iova;
+	}
 
 	return ret;
 }
@@ -290,6 +294,8 @@ void etnaviv_gem_put_iova(struct etnaviv_gpu *gpu, struct drm_gem_object *obj)
 
 	WARN_ON(mapping->use == 0);
 	mapping->use -= 1;
+
+	drm_gem_object_unreference(obj);
 }
 
 void *etnaviv_gem_vaddr_locked(struct drm_gem_object *obj)
diff --git a/drivers/staging/etnaviv/etnaviv_gpu.c b/drivers/staging/etnaviv/etnaviv_gpu.c
index ef1903b..d751a29 100644
--- a/drivers/staging/etnaviv/etnaviv_gpu.c
+++ b/drivers/staging/etnaviv/etnaviv_gpu.c
@@ -1088,9 +1088,11 @@ static void retire_worker(struct work_struct *work)
 		fence_put(cmdbuf->fence);
 
 		for (i = 0; i < cmdbuf->nr_bos; i++) {
-			etnaviv_gem_put_iova(gpu, &cmdbuf->bo[i]->base);
-			atomic_dec(&cmdbuf->bo[i]->gpu_active);
-			drm_gem_object_unreference(&cmdbuf->bo[i]->base);
+			struct etnaviv_gem_object *etnaviv_obj = cmdbuf->bo[i];
+
+			atomic_dec(&etnaviv_obj->gpu_active);
+			/* drop the refcount taken in etnaviv_gpu_submit */
+			etnaviv_gem_put_iova(gpu, &etnaviv_obj->base);
 		}
 
 		etnaviv_gpu_cmdbuf_free(cmdbuf);
@@ -1234,8 +1236,7 @@ int etnaviv_gpu_submit(struct etnaviv_gpu *gpu,
 		struct etnaviv_gem_object *etnaviv_obj = submit->bos[i].obj;
 		u32 iova;
 
-		/* Each cmdbuf takes a reference on the bo and iova */
-		drm_gem_object_reference(&etnaviv_obj->base);
+		/* Each cmdbuf takes a refcount on the iova */
 		etnaviv_gem_get_iova_locked(gpu, &etnaviv_obj->base, &iova);
 		cmdbuf->bo[i] = etnaviv_obj;
 		atomic_inc(&etnaviv_obj->gpu_active);
-- 
2.6.2

