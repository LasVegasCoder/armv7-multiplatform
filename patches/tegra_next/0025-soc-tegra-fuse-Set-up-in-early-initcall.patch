From 367d20da332c754b5f244784c4e999014c2166e7 Mon Sep 17 00:00:00 2001
From: Thierry Reding <treding@nvidia.com>
Date: Fri, 11 Jul 2014 11:13:30 +0200
Subject: [PATCH 25/45] soc/tegra: fuse: Set up in early initcall

Rather than rely on explicit initialization order called from SoC setup
code, use a plain initcall and rely on initcall ordering to take care of
dependencies.

This driver exposes some functionality (querying the chip ID) needed at
very early stages of the boot process. An early initcall is good enough
provided that some of the dependencies are deferred to later stages. To
make sure any abuses are easily caught, output a warning message if the
chip ID is queried while it can't be read yet.

Signed-off-by: Thierry Reding <treding@nvidia.com>
---
 arch/arm/mach-tegra/tegra.c            |  1 -
 drivers/soc/tegra/fuse/fuse-tegra.c    | 11 +++++++++--
 drivers/soc/tegra/fuse/tegra-apbmisc.c |  7 +++++--
 include/soc/tegra/fuse.h               |  1 -
 4 files changed, 14 insertions(+), 6 deletions(-)

diff --git a/arch/arm/mach-tegra/tegra.c b/arch/arm/mach-tegra/tegra.c
index e5733fa..c9176db 100644
--- a/arch/arm/mach-tegra/tegra.c
+++ b/arch/arm/mach-tegra/tegra.c
@@ -73,7 +73,6 @@ u32 tegra_uart_config[3] = {
 static void __init tegra_init_early(void)
 {
 	of_register_trusted_foundations();
-	tegra_init_fuse();
 	tegra_cpu_reset_handler_init();
 	tegra_powergate_init();
 }
diff --git a/drivers/soc/tegra/fuse/fuse-tegra.c b/drivers/soc/tegra/fuse/fuse-tegra.c
index 03742ed..11a5043 100644
--- a/drivers/soc/tegra/fuse/fuse-tegra.c
+++ b/drivers/soc/tegra/fuse/fuse-tegra.c
@@ -23,6 +23,7 @@
 #include <linux/of_address.h>
 #include <linux/io.h>
 
+#include <soc/tegra/common.h>
 #include <soc/tegra/fuse.h>
 
 #include "fuse.h"
@@ -125,11 +126,14 @@ int tegra_fuse_create_sysfs(struct device *dev, int size,
 	return device_create_bin_file(dev, &fuse_bin_attr);
 }
 
-void __init tegra_init_fuse(void)
+static int __init tegra_init_fuse(void)
 {
 	struct device_node *np;
 	void __iomem *car_base;
 
+	if (!soc_is_tegra())
+		return 0;
+
 	tegra_init_apbmisc();
 
 	np = of_find_matching_node(NULL, car_match);
@@ -139,7 +143,7 @@ void __init tegra_init_fuse(void)
 		iounmap(car_base);
 	} else {
 		pr_err("Could not enable fuse clk. ioremap tegra car failed.\n");
-		return;
+		return -ENXIO;
 	}
 
 	if (tegra_get_chip_id() == TEGRA20)
@@ -153,4 +157,7 @@ void __init tegra_init_fuse(void)
 		tegra_sku_info.core_process_id);
 	pr_debug("Tegra CPU Speedo ID %d, Soc Speedo ID %d\n",
 		tegra_sku_info.cpu_speedo_id, tegra_sku_info.soc_speedo_id);
+
+	return 0;
 }
+early_initcall(tegra_init_fuse);
diff --git a/drivers/soc/tegra/fuse/tegra-apbmisc.c b/drivers/soc/tegra/fuse/tegra-apbmisc.c
index bfc1d54..3bf5aba 100644
--- a/drivers/soc/tegra/fuse/tegra-apbmisc.c
+++ b/drivers/soc/tegra/fuse/tegra-apbmisc.c
@@ -38,9 +38,12 @@ u32 tegra_read_chipid(void)
 
 u8 tegra_get_chip_id(void)
 {
-	u32 id = tegra_read_chipid();
+	if (!apbmisc_base) {
+		WARN(1, "Tegra Chip ID not yet available\n");
+		return 0;
+	}
 
-	return (id >> 8) & 0xff;
+	return (tegra_read_chipid() >> 8) & 0xff;
 }
 
 u32 tegra_read_straps(void)
diff --git a/include/soc/tegra/fuse.h b/include/soc/tegra/fuse.h
index 738712d..8e12494 100644
--- a/include/soc/tegra/fuse.h
+++ b/include/soc/tegra/fuse.h
@@ -56,7 +56,6 @@ struct tegra_sku_info {
 
 u32 tegra_read_straps(void);
 u32 tegra_read_chipid(void);
-void tegra_init_fuse(void);
 int tegra_fuse_readl(unsigned long offset, u32 *value);
 
 extern struct tegra_sku_info tegra_sku_info;
-- 
2.0.1

