From a6b72c714425be196e49d2bb41f9ad405c55f1bb Mon Sep 17 00:00:00 2001
From: Alexander Shiyan <shc_work@mail.ru>
Date: Tue, 27 May 2014 13:04:46 +0400
Subject: [PATCH 027/125] ARM: i.MX: Use of_clk_get_by_name() for timer clocks
 for DT case.

Use of_clk_get_by_name() for timer clocks for DT case.
This patch eliminates a lot of unneeded clk_register_clkdev()
calls for GPT.

Signed-off-by: Alexander Shiyan <shc_work@mail.ru>
Signed-off-by: Shawn Guo <shawn.guo@freescale.com>
---
 arch/arm/mach-imx/clk-imx1.c        |  5 ++---
 arch/arm/mach-imx/clk-imx25.c       |  5 ++---
 arch/arm/mach-imx/clk-imx51-imx53.c |  2 --
 arch/arm/mach-imx/clk-imx6q.c       |  2 --
 arch/arm/mach-imx/clk-imx6sl.c      |  3 ---
 arch/arm/mach-imx/clk-imx6sx.c      |  3 ---
 arch/arm/mach-imx/time.c            | 33 +++++++++++++++++++++------------
 7 files changed, 25 insertions(+), 28 deletions(-)

diff --git a/arch/arm/mach-imx/clk-imx1.c b/arch/arm/mach-imx/clk-imx1.c
index e9c391b..96b1eb6 100644
--- a/arch/arm/mach-imx/clk-imx1.c
+++ b/arch/arm/mach-imx/clk-imx1.c
@@ -76,9 +76,6 @@ static void __init _mx1_clocks_init(unsigned long fref)
 		if (IS_ERR(clk[i]))
 			pr_err("imx1 clk %d: register failed with %ld\n",
 				i, PTR_ERR(clk[i]));
-
-	clk_register_clkdev(clk[IMX1_CLK_PER1], "per", "imx-gpt.0");
-	clk_register_clkdev(clk[IMX1_CLK_HCLK], "ipg", "imx-gpt.0");
 }
 
 int __init mx1_clocks_init(unsigned long fref)
@@ -87,6 +84,8 @@ int __init mx1_clocks_init(unsigned long fref)
 
 	_mx1_clocks_init(fref);
 
+	clk_register_clkdev(clk[IMX1_CLK_PER1], "per", "imx-gpt.0");
+	clk_register_clkdev(clk[IMX1_CLK_HCLK], "ipg", "imx-gpt.0");
 	clk_register_clkdev(clk[IMX1_CLK_DMA_GATE], "ahb", "imx1-dma");
 	clk_register_clkdev(clk[IMX1_CLK_HCLK], "ipg", "imx1-dma");
 	clk_register_clkdev(clk[IMX1_CLK_PER1], "per", "imx1-uart.0");
diff --git a/arch/arm/mach-imx/clk-imx25.c b/arch/arm/mach-imx/clk-imx25.c
index ae578c0..2423c09 100644
--- a/arch/arm/mach-imx/clk-imx25.c
+++ b/arch/arm/mach-imx/clk-imx25.c
@@ -234,9 +234,6 @@ static int __init __mx25_clocks_init(unsigned long osc_rate)
 	/* Clock source for gpt must be derived from AHB */
 	clk_set_parent(clk[per5_sel], clk[ahb]);
 
-	clk_register_clkdev(clk[ipg], "ipg", "imx-gpt.0");
-	clk_register_clkdev(clk[gpt_ipg_per], "per", "imx-gpt.0");
-
 	/*
 	 * Let's initially set up CLKO parent as ipg, since this configuration
 	 * is used on some imx25 board designs to clock the audio codec.
@@ -250,6 +247,8 @@ int __init mx25_clocks_init(void)
 {
 	__mx25_clocks_init(24000000);
 
+	clk_register_clkdev(clk[ipg], "ipg", "imx-gpt.0");
+	clk_register_clkdev(clk[gpt_ipg_per], "per", "imx-gpt.0");
 	/* i.mx25 has the i.mx21 type uart */
 	clk_register_clkdev(clk[uart1_ipg], "ipg", "imx21-uart.0");
 	clk_register_clkdev(clk[uart_ipg_per], "per", "imx21-uart.0");
diff --git a/arch/arm/mach-imx/clk-imx51-imx53.c b/arch/arm/mach-imx/clk-imx51-imx53.c
index 4e95865..e293f6a 100644
--- a/arch/arm/mach-imx/clk-imx51-imx53.c
+++ b/arch/arm/mach-imx/clk-imx51-imx53.c
@@ -292,8 +292,6 @@ static void __init mx5_clocks_common_init(void __iomem *ccm_base)
 			pr_err("i.MX5 clk %d: register failed with %ld\n",
 				i, PTR_ERR(clk[i]));
 
-	clk_register_clkdev(clk[IMX5_CLK_GPT_HF_GATE], "per", "imx-gpt.0");
-	clk_register_clkdev(clk[IMX5_CLK_GPT_IPG_GATE], "ipg", "imx-gpt.0");
 	clk_register_clkdev(clk[IMX5_CLK_UART1_PER_GATE], "per", "imx21-uart.0");
 	clk_register_clkdev(clk[IMX5_CLK_UART1_IPG_GATE], "ipg", "imx21-uart.0");
 	clk_register_clkdev(clk[IMX5_CLK_UART2_PER_GATE], "per", "imx21-uart.1");
diff --git a/arch/arm/mach-imx/clk-imx6q.c b/arch/arm/mach-imx/clk-imx6q.c
index 8556c78..540f257 100644
--- a/arch/arm/mach-imx/clk-imx6q.c
+++ b/arch/arm/mach-imx/clk-imx6q.c
@@ -442,8 +442,6 @@ static void __init imx6q_clocks_init(struct device_node *ccm_node)
 	clk_data.clk_num = ARRAY_SIZE(clk);
 	of_clk_add_provider(np, of_clk_src_onecell_get, &clk_data);
 
-	clk_register_clkdev(clk[gpt_ipg], "ipg", "imx-gpt.0");
-	clk_register_clkdev(clk[gpt_ipg_per], "per", "imx-gpt.0");
 	clk_register_clkdev(clk[enet_ref], "enet_ref", NULL);
 
 	if ((imx_get_soc_revision() != IMX_CHIP_REVISION_1_0) ||
diff --git a/arch/arm/mach-imx/clk-imx6sl.c b/arch/arm/mach-imx/clk-imx6sl.c
index 5408ca7..7431bfa 100644
--- a/arch/arm/mach-imx/clk-imx6sl.c
+++ b/arch/arm/mach-imx/clk-imx6sl.c
@@ -357,9 +357,6 @@ static void __init imx6sl_clocks_init(struct device_node *ccm_node)
 	clk_data.clk_num = ARRAY_SIZE(clks);
 	of_clk_add_provider(np, of_clk_src_onecell_get, &clk_data);
 
-	clk_register_clkdev(clks[IMX6SL_CLK_GPT], "ipg", "imx-gpt.0");
-	clk_register_clkdev(clks[IMX6SL_CLK_GPT_SERIAL], "per", "imx-gpt.0");
-
 	/* Ensure the AHB clk is at 132MHz. */
 	ret = clk_set_rate(clks[IMX6SL_CLK_AHB], 132000000);
 	if (ret)
diff --git a/arch/arm/mach-imx/clk-imx6sx.c b/arch/arm/mach-imx/clk-imx6sx.c
index 72f8902..5211cf6 100644
--- a/arch/arm/mach-imx/clk-imx6sx.c
+++ b/arch/arm/mach-imx/clk-imx6sx.c
@@ -451,9 +451,6 @@ static void __init imx6sx_clocks_init(struct device_node *ccm_node)
 	clk_data.clk_num = ARRAY_SIZE(clks);
 	of_clk_add_provider(np, of_clk_src_onecell_get, &clk_data);
 
-	clk_register_clkdev(clks[IMX6SX_CLK_GPT_BUS], "ipg", "imx-gpt.0");
-	clk_register_clkdev(clks[IMX6SX_CLK_GPT_SERIAL], "per", "imx-gpt.0");
-
 	for (i = 0; i < ARRAY_SIZE(clks_init_on); i++)
 		clk_prepare_enable(clks[clks_init_on[i]]);
 
diff --git a/arch/arm/mach-imx/time.c b/arch/arm/mach-imx/time.c
index bed081e..2d96051 100644
--- a/arch/arm/mach-imx/time.c
+++ b/arch/arm/mach-imx/time.c
@@ -290,23 +290,20 @@ static int __init mxc_clockevent_init(struct clk *timer_clk)
 	return 0;
 }
 
-void __init mxc_timer_init(void __iomem *base, int irq)
+static void __init _mxc_timer_init(void __iomem *base, int irq,
+				   struct clk *clk_per, struct clk *clk_ipg)
 {
 	uint32_t tctl_val;
-	struct clk *timer_clk;
-	struct clk *timer_ipg_clk;
 
-	timer_clk = clk_get_sys("imx-gpt.0", "per");
-	if (IS_ERR(timer_clk)) {
+	if (IS_ERR(clk_per)) {
 		pr_err("i.MX timer: unable to get clk\n");
 		return;
 	}
 
-	timer_ipg_clk = clk_get_sys("imx-gpt.0", "ipg");
-	if (!IS_ERR(timer_ipg_clk))
-		clk_prepare_enable(timer_ipg_clk);
+	if (!IS_ERR(clk_ipg))
+		clk_prepare_enable(clk_ipg);
 
-	clk_prepare_enable(timer_clk);
+	clk_prepare_enable(clk_per);
 
 	timer_base = base;
 
@@ -325,15 +322,24 @@ void __init mxc_timer_init(void __iomem *base, int irq)
 	__raw_writel(tctl_val, timer_base + MXC_TCTL);
 
 	/* init and register the timer to the framework */
-	mxc_clocksource_init(timer_clk);
-	mxc_clockevent_init(timer_clk);
+	mxc_clocksource_init(clk_per);
+	mxc_clockevent_init(clk_per);
 
 	/* Make irqs happen */
 	setup_irq(irq, &mxc_timer_irq);
 }
 
+void __init mxc_timer_init(void __iomem *base, int irq)
+{
+	struct clk *clk_per = clk_get_sys("imx-gpt.0", "per");
+	struct clk *clk_ipg = clk_get_sys("imx-gpt.0", "ipg");
+
+	_mxc_timer_init(base, irq, clk_per, clk_ipg);
+}
+
 void __init mxc_timer_init_dt(struct device_node *np)
 {
+	struct clk *clk_per, *clk_ipg;
 	void __iomem *base;
 	int irq;
 
@@ -341,5 +347,8 @@ void __init mxc_timer_init_dt(struct device_node *np)
 	WARN_ON(!base);
 	irq = irq_of_parse_and_map(np, 0);
 
-	mxc_timer_init(base, irq);
+	clk_per = of_clk_get_by_name(np, "per");
+	clk_ipg = of_clk_get_by_name(np, "ipg");
+
+	_mxc_timer_init(base, irq, clk_per, clk_ipg);
 }
-- 
2.0.1

