From 234d4bd0e926f451ca9dd0bc0d20d0607995006e Mon Sep 17 00:00:00 2001
From: Shawn Guo <shawn.guo@freescale.com>
Date: Tue, 20 May 2014 14:55:15 +0800
Subject: [PATCH 021/125] ARM: imx5: use dynamic mapping for Cortex and GPC
 block

The imx5 pm code uses static mapping to access Cortex and GPC registers.
The patch create struct imx5_pm_data to encode physical address of
Cortex and GPC block, and create dynamic mapping for them at run-time.

Signed-off-by: Shawn Guo <shawn.guo@freescale.com>
---
 arch/arm/mach-imx/common.h  |  6 ++--
 arch/arm/mach-imx/mm-imx5.c |  4 +--
 arch/arm/mach-imx/pm-imx5.c | 84 +++++++++++++++++++++++++++++----------------
 3 files changed, 60 insertions(+), 34 deletions(-)

diff --git a/arch/arm/mach-imx/common.h b/arch/arm/mach-imx/common.h
index 8aa198c..1156bf6 100644
--- a/arch/arm/mach-imx/common.h
+++ b/arch/arm/mach-imx/common.h
@@ -142,10 +142,12 @@ void imx6sl_pm_init(void);
 void imx6q_pm_set_ccm_base(void __iomem *base);
 
 #ifdef CONFIG_PM
-void imx5_pm_init(void);
+void imx51_pm_init(void);
+void imx53_pm_init(void);
 void imx5_pm_set_ccm_base(void __iomem *base);
 #else
-static inline void imx5_pm_init(void) {}
+static inline void imx51_pm_init(void) {}
+static inline void imx53_pm_init(void) {}
 static inline void imx5_pm_set_ccm_base(void __iomem *base) {}
 #endif
 
diff --git a/arch/arm/mach-imx/mm-imx5.c b/arch/arm/mach-imx/mm-imx5.c
index 771ab36..9e43e87 100644
--- a/arch/arm/mach-imx/mm-imx5.c
+++ b/arch/arm/mach-imx/mm-imx5.c
@@ -96,10 +96,10 @@ void __init imx53_init_early(void)
 void __init imx51_init_late(void)
 {
 	mx51_neon_fixup();
-	imx5_pm_init();
+	imx51_pm_init();
 }
 
 void __init imx53_init_late(void)
 {
-	imx5_pm_init();
+	imx53_pm_init();
 }
diff --git a/arch/arm/mach-imx/pm-imx5.c b/arch/arm/mach-imx/pm-imx5.c
index 3544c25..f1f80ab 100644
--- a/arch/arm/mach-imx/pm-imx5.c
+++ b/arch/arm/mach-imx/pm-imx5.c
@@ -28,21 +28,14 @@
 #define MXC_CCM_CLPCR_VSTBY		(0x1 << 8)
 #define MXC_CCM_CLPCR_SBYOS		(0x1 << 6)
 
-#define MX51_CORTEXA8_BASE		MX51_IO_ADDRESS(MX51_ARM_BASE_ADDR)
-#define MXC_CORTEXA8_PLAT_LPC		(MX51_CORTEXA8_BASE + 0xc)
+#define MXC_CORTEXA8_PLAT_LPC		0xc
 #define MXC_CORTEXA8_PLAT_LPC_DSM	(1 << 0)
 #define MXC_CORTEXA8_PLAT_LPC_DBG_DSM	(1 << 1)
 
-#define MX51_GPC_BASE			MX51_IO_ADDRESS(MX51_GPC_BASE_ADDR)
-#define MXC_SRPG_NEON_BASE		(MX51_GPC_BASE + 0x280)
-#define MXC_SRPG_ARM_BASE		(MX51_GPC_BASE + 0x2a0)
-#define MXC_SRPG_EMPGC0_BASE		(MX51_GPC_BASE + 0x2c0)
-#define MXC_SRPG_EMPGC1_BASE		(MX51_GPC_BASE + 0x2d0)
-
-#define MXC_SRPG_NEON_SRPGCR		(MXC_SRPG_NEON_BASE + 0x0)
-#define MXC_SRPG_ARM_SRPGCR		(MXC_SRPG_ARM_BASE + 0x0)
-#define MXC_SRPG_EMPGC0_SRPGCR		(MXC_SRPG_EMPGC0_BASE + 0x0)
-#define MXC_SRPG_EMPGC1_SRPGCR		(MXC_SRPG_EMPGC1_BASE + 0x0)
+#define MXC_SRPG_NEON_SRPGCR		0x280
+#define MXC_SRPG_ARM_SRPGCR		0x2a0
+#define MXC_SRPG_EMPGC0_SRPGCR		0x2c0
+#define MXC_SRPG_EMPGC1_SRPGCR		0x2d0
 
 #define MXC_SRPGCR_PCR			1
 
@@ -56,7 +49,24 @@
  */
 #define IMX5_DEFAULT_CPU_IDLE_STATE WAIT_UNCLOCKED_POWER_OFF
 
+struct imx5_pm_data {
+	phys_addr_t cortex_addr;
+	phys_addr_t gpc_addr;
+};
+
+static const struct imx5_pm_data imx51_pm_data __initconst = {
+	.cortex_addr = 0x83fa0000,
+	.gpc_addr = 0x73fd8000,
+};
+
+static const struct imx5_pm_data imx53_pm_data __initconst = {
+	.cortex_addr = 0x63fa0000,
+	.gpc_addr = 0x53fd8000,
+};
+
 static void __iomem *ccm_base;
+static void __iomem *cortex_base;
+static void __iomem *gpc_base;
 
 void __init imx5_pm_set_ccm_base(void __iomem *base)
 {
@@ -74,13 +84,16 @@ static void mx5_cpu_lp_set(enum mxc_cpu_pwr_mode mode)
 	int stop_mode = 0;
 
 	/* always allow platform to issue a deep sleep mode request */
-	plat_lpc = __raw_readl(MXC_CORTEXA8_PLAT_LPC) &
+	plat_lpc = __raw_readl(cortex_base + MXC_CORTEXA8_PLAT_LPC) &
 	    ~(MXC_CORTEXA8_PLAT_LPC_DSM);
 	ccm_clpcr = __raw_readl(ccm_base + MXC_CCM_CLPCR) &
 		    ~(MXC_CCM_CLPCR_LPM_MASK);
-	arm_srpgcr = __raw_readl(MXC_SRPG_ARM_SRPGCR) & ~(MXC_SRPGCR_PCR);
-	empgc0 = __raw_readl(MXC_SRPG_EMPGC0_SRPGCR) & ~(MXC_SRPGCR_PCR);
-	empgc1 = __raw_readl(MXC_SRPG_EMPGC1_SRPGCR) & ~(MXC_SRPGCR_PCR);
+	arm_srpgcr = __raw_readl(gpc_base + MXC_SRPG_ARM_SRPGCR) &
+		     ~(MXC_SRPGCR_PCR);
+	empgc0 = __raw_readl(gpc_base + MXC_SRPG_EMPGC0_SRPGCR) &
+		 ~(MXC_SRPGCR_PCR);
+	empgc1 = __raw_readl(gpc_base + MXC_SRPG_EMPGC1_SRPGCR) &
+		 ~(MXC_SRPGCR_PCR);
 
 	switch (mode) {
 	case WAIT_CLOCKED:
@@ -114,17 +127,17 @@ static void mx5_cpu_lp_set(enum mxc_cpu_pwr_mode mode)
 		return;
 	}
 
-	__raw_writel(plat_lpc, MXC_CORTEXA8_PLAT_LPC);
+	__raw_writel(plat_lpc, cortex_base + MXC_CORTEXA8_PLAT_LPC);
 	__raw_writel(ccm_clpcr, ccm_base + MXC_CCM_CLPCR);
-	__raw_writel(arm_srpgcr, MXC_SRPG_ARM_SRPGCR);
-	__raw_writel(arm_srpgcr, MXC_SRPG_NEON_SRPGCR);
+	__raw_writel(arm_srpgcr, gpc_base + MXC_SRPG_ARM_SRPGCR);
+	__raw_writel(arm_srpgcr, gpc_base + MXC_SRPG_NEON_SRPGCR);
 
 	if (stop_mode) {
 		empgc0 |= MXC_SRPGCR_PCR;
 		empgc1 |= MXC_SRPGCR_PCR;
 
-		__raw_writel(empgc0, MXC_SRPG_EMPGC0_SRPGCR);
-		__raw_writel(empgc1, MXC_SRPG_EMPGC1_SRPGCR);
+		__raw_writel(empgc0, gpc_base + MXC_SRPG_EMPGC0_SRPGCR);
+		__raw_writel(empgc1, gpc_base + MXC_SRPG_EMPGC1_SRPGCR);
 	}
 }
 
@@ -146,8 +159,8 @@ static int mx5_suspend_enter(suspend_state_t state)
 		flush_cache_all();
 
 		/*clear the EMPGC0/1 bits */
-		__raw_writel(0, MXC_SRPG_EMPGC0_SRPGCR);
-		__raw_writel(0, MXC_SRPG_EMPGC1_SRPGCR);
+		__raw_writel(0, gpc_base + MXC_SRPG_EMPGC0_SRPGCR);
+		__raw_writel(0, gpc_base + MXC_SRPG_EMPGC1_SRPGCR);
 	}
 	cpu_do_idle();
 
@@ -181,7 +194,7 @@ static void imx5_pm_idle(void)
 	imx5_cpu_do_idle();
 }
 
-static int __init imx5_pm_common_init(void)
+static int __init imx5_pm_common_init(const struct imx5_pm_data *data)
 {
 	int ret;
 	struct clk *gpc_dvfs_clk = clk_get(NULL, "gpc_dvfs");
@@ -195,17 +208,28 @@ static int __init imx5_pm_common_init(void)
 
 	arm_pm_idle = imx5_pm_idle;
 
-	WARN_ON(!ccm_base);
+	cortex_base = ioremap(data->cortex_addr, SZ_16K);
+	gpc_base = ioremap(data->gpc_addr, SZ_16K);
+	WARN_ON(!ccm_base || !cortex_base || !gpc_base);
 
 	/* Set the registers to the default cpu idle state. */
 	mx5_cpu_lp_set(IMX5_DEFAULT_CPU_IDLE_STATE);
 
-	return imx5_cpuidle_init();
+	ret = imx5_cpuidle_init();
+	if (ret)
+		pr_warn("%s: cpuidle init failed %d\n", __func__, ret);
+
+	suspend_set_ops(&mx5_suspend_ops);
+
+	return 0;
+}
+
+void __init imx51_pm_init(void)
+{
+	imx5_pm_common_init(&imx51_pm_data);
 }
 
-void __init imx5_pm_init(void)
+void __init imx53_pm_init(void)
 {
-	int ret = imx5_pm_common_init();
-	if (!ret)
-		suspend_set_ops(&mx5_suspend_ops);
+	imx5_pm_common_init(&imx53_pm_data);
 }
-- 
2.0.1

