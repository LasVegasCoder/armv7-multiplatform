From 3d0d57309a4ca9cbb0c02487f9d6b50c6ef1cf2e Mon Sep 17 00:00:00 2001
From: Robert Nelson <robertcnelson@gmail.com>
Date: Sun, 8 Jan 2017 17:30:59 -0600
Subject: [PATCH] merge: tinydrm

Signed-off-by: Robert Nelson <robertcnelson@gmail.com>
---
 drivers/gpu/drm/Kconfig                        |    1 +
 drivers/gpu/drm/Makefile                       |    1 +
 drivers/gpu/drm/tinydrm/Kconfig                |   30 +
 drivers/gpu/drm/tinydrm/Makefile               |   10 +
 drivers/gpu/drm/tinydrm/adafruit-tft.c         |  394 +++++++++
 drivers/gpu/drm/tinydrm/core/Makefile          |    6 +
 drivers/gpu/drm/tinydrm/core/tinydrm-core.c    |  388 +++++++++
 drivers/gpu/drm/tinydrm/core/tinydrm-fb.c      |  141 +++
 drivers/gpu/drm/tinydrm/core/tinydrm-helpers.c |  289 +++++++
 drivers/gpu/drm/tinydrm/core/tinydrm-pipe.c    |  248 ++++++
 drivers/gpu/drm/tinydrm/core/tinydrm-regmap.c  |  262 ++++++
 drivers/gpu/drm/tinydrm/mi0283qt.c             |  307 +++++++
 drivers/gpu/drm/tinydrm/mipi-dbi.c             | 1090 ++++++++++++++++++++++++
 include/drm/tinydrm/hx8340.h                   |   46 +
 include/drm/tinydrm/ili9341.h                  |   54 ++
 include/drm/tinydrm/mipi-dbi.h                 |   90 ++
 include/drm/tinydrm/st7735r.h                  |   44 +
 include/drm/tinydrm/tinydrm-helpers.h          |   56 ++
 include/drm/tinydrm/tinydrm-regmap.h           |   98 +++
 include/drm/tinydrm/tinydrm.h                  |  145 ++++
 20 files changed, 3700 insertions(+)
 create mode 100644 drivers/gpu/drm/tinydrm/Kconfig
 create mode 100644 drivers/gpu/drm/tinydrm/Makefile
 create mode 100644 drivers/gpu/drm/tinydrm/adafruit-tft.c
 create mode 100644 drivers/gpu/drm/tinydrm/core/Makefile
 create mode 100644 drivers/gpu/drm/tinydrm/core/tinydrm-core.c
 create mode 100644 drivers/gpu/drm/tinydrm/core/tinydrm-fb.c
 create mode 100644 drivers/gpu/drm/tinydrm/core/tinydrm-helpers.c
 create mode 100644 drivers/gpu/drm/tinydrm/core/tinydrm-pipe.c
 create mode 100644 drivers/gpu/drm/tinydrm/core/tinydrm-regmap.c
 create mode 100644 drivers/gpu/drm/tinydrm/mi0283qt.c
 create mode 100644 drivers/gpu/drm/tinydrm/mipi-dbi.c
 create mode 100644 include/drm/tinydrm/hx8340.h
 create mode 100644 include/drm/tinydrm/ili9341.h
 create mode 100644 include/drm/tinydrm/mipi-dbi.h
 create mode 100644 include/drm/tinydrm/st7735r.h
 create mode 100644 include/drm/tinydrm/tinydrm-helpers.h
 create mode 100644 include/drm/tinydrm/tinydrm-regmap.h
 create mode 100644 include/drm/tinydrm/tinydrm.h

diff --git a/drivers/gpu/drm/Kconfig b/drivers/gpu/drm/Kconfig
index ebfe8404c25f..0b1d65570f45 100644
--- a/drivers/gpu/drm/Kconfig
+++ b/drivers/gpu/drm/Kconfig
@@ -321,3 +321,4 @@ config DRM_SAVAGE
 	  chipset. If M is selected the module will be called savage.
 
 endif # DRM_LEGACY
+source "drivers/gpu/drm/tinydrm/Kconfig"
diff --git a/drivers/gpu/drm/Makefile b/drivers/gpu/drm/Makefile
index b9ae4280de9d..da26c9613fa4 100644
--- a/drivers/gpu/drm/Makefile
+++ b/drivers/gpu/drm/Makefile
@@ -91,3 +91,4 @@ obj-$(CONFIG_DRM_ARCPGU)+= arc/
 obj-y			+= hisilicon/
 obj-$(CONFIG_DRM_ZTE)	+= zte/
 obj-$(CONFIG_DRM_MXSFB)	+= mxsfb/
+obj-$(CONFIG_DRM_TINYDRM)+= tinydrm/
diff --git a/drivers/gpu/drm/tinydrm/Kconfig b/drivers/gpu/drm/tinydrm/Kconfig
new file mode 100644
index 000000000000..efa0633839f7
--- /dev/null
+++ b/drivers/gpu/drm/tinydrm/Kconfig
@@ -0,0 +1,30 @@
+menuconfig DRM_TINYDRM
+	tristate "Support for small TFT LCD display modules"
+	depends on DRM
+	select DRM_KMS_HELPER
+	select DRM_KMS_CMA_HELPER
+	select VIDEOMODE_HELPERS
+	help
+	  Choose this option if you have a tinydrm supported display.
+	  If M is selected the module will be called tinydrm.
+
+config TINYDRM_MIPI_DBI
+	tristate
+	select REGMAP
+
+config TINYDRM_MI0283QT
+	tristate "DRM support for MI0283QT"
+	depends on DRM_TINYDRM && SPI
+	select TINYDRM_MIPI_DBI
+	help
+	  DRM driver for the following Multi-Inno MI0283QT display panels:
+	    MI0283QT-8, MI0283QT-9, MI0283QT-9A, MI0283QT-11, MI0283QT-13
+
+config TINYDRM_ADAFRUIT_TFT
+	tristate "DRM driver for Adafruit SPI TFT displays"
+	depends on DRM_TINYDRM && SPI
+	select TINYDRM_MIPI_DBI
+	help
+	  DRM driver for the following Adafruit displays:
+	    2.2" Color TFT LCD display - HX8340BN, 9-bit mode (#797)
+	    1.8" Color TFT LCD display - ST7735R (#358)
diff --git a/drivers/gpu/drm/tinydrm/Makefile b/drivers/gpu/drm/tinydrm/Makefile
new file mode 100644
index 000000000000..6f02b79110fb
--- /dev/null
+++ b/drivers/gpu/drm/tinydrm/Makefile
@@ -0,0 +1,10 @@
+ccflags-y += -I$(src)/include
+
+obj-$(CONFIG_DRM_TINYDRM)		+= core/
+
+# Controllers
+obj-$(CONFIG_TINYDRM_MIPI_DBI)		+= mipi-dbi.o
+
+# Displays
+obj-$(CONFIG_TINYDRM_MI0283QT)		+= mi0283qt.o
+obj-$(CONFIG_TINYDRM_ADAFRUIT_TFT)	+= adafruit-tft.o
diff --git a/drivers/gpu/drm/tinydrm/adafruit-tft.c b/drivers/gpu/drm/tinydrm/adafruit-tft.c
new file mode 100644
index 000000000000..ef89c1b6b0e6
--- /dev/null
+++ b/drivers/gpu/drm/tinydrm/adafruit-tft.c
@@ -0,0 +1,394 @@
+#define DEBUG
+
+/*
+ * DRM driver for Adafruit MIPI compatible SPI TFT displays
+ *
+ * Copyright 2016 Noralf Tr√∏nnes
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <drm/tinydrm/hx8340.h>
+#include <drm/tinydrm/mipi-dbi.h>
+#include <drm/tinydrm/st7735r.h>
+#include <drm/tinydrm/tinydrm.h>
+#include <drm/tinydrm/tinydrm-helpers.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/property.h>
+#include <linux/regulator/consumer.h>
+#include <linux/spi/spi.h>
+#include <video/mipi_display.h>
+
+struct adafruit_tft_display {
+	const struct drm_display_mode mode;
+	const struct drm_simple_display_pipe_funcs funcs;
+	bool write_only;
+	bool dc;
+};
+
+enum adafruit_tft_display_ids {
+	ADAFRUIT_797,
+	ADAFRUIT_358,
+};
+
+/*
+ * 2.2" Color TFT LCD display - HX8340BN, 9-bit mode (#797)
+ * Product: http://www.adafruit.com/products/797
+ * Schematics: https://github.com/adafruit/Adafruit-2.2-SPI-TFT
+ *
+ * It's hard to tell if it should be possible to read from the controller.
+ * The datasheet says that SDI is used for input and output, but
+ * the schematics indicate that MISO is connected.
+ * One user reports a failed attempt to read from it. So err on the safe
+ * side and mark it is as write-only in case it tries to drive MOSI.
+ *
+ * Init sequence taken from the BTL221722-276L datasheet
+ */
+static void adafruit_tft_797_enable(struct drm_simple_display_pipe *pipe,
+				    struct drm_crtc_state *crtc_state)
+{
+	struct tinydrm_device *tdev = pipe_to_tinydrm(pipe);
+	struct mipi_dbi *mipi = mipi_dbi_from_tinydrm(tdev);
+	struct device *dev = tdev->drm.dev;
+	struct regmap *reg = mipi->reg;
+	u8 addr_mode;
+	int ret;
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	mutex_lock(&tdev->dev_lock);
+
+	if (tdev->prepared)
+		goto out_unlock;
+
+	if (mipi->regulator) {
+		ret = regulator_enable(mipi->regulator);
+		if (ret) {
+			dev_err(dev, "Failed to enable regulator %d\n", ret);
+			goto out_unlock;
+		}
+	}
+
+	mipi_dbi_hw_reset(mipi);
+	ret = mipi_dbi_write(reg, HX8340_SETEXTCMD, 0xFF, 0x83, 0x40);
+	if (ret) {
+		dev_err(dev, "Error writing command %d\n", ret);
+		goto out_unlock;
+	}
+
+	mipi_dbi_write(reg, MIPI_DCS_EXIT_SLEEP_MODE);
+	msleep(150);
+
+	/* Undocumented register */
+	mipi_dbi_write(reg, 0xCA, 0x70, 0x00, 0xD9);
+
+	mipi_dbi_write(reg, HX8340_SETOSC, 0x01, 0x11);
+
+	/* Driving ability Setting */
+	mipi_dbi_write(reg, 0xC9,
+		       0x90, 0x49, 0x10, 0x28, 0x28, 0x10, 0x00, 0x06);
+	msleep(20);
+
+	/* Gamma 2.2 Setting */
+	mipi_dbi_write(reg, HX8340_SETGAMMAP,
+		       0x60, 0x71, 0x01, 0x0E, 0x05, 0x02, 0x09, 0x31, 0x0A);
+	mipi_dbi_write(reg, HX8340_SETGAMMAN,
+		       0x67, 0x30, 0x61, 0x17, 0x48, 0x07, 0x05, 0x33);
+	msleep(10);
+
+	mipi_dbi_write(reg, HX8340_SETPWCTR5, 0x35, 0x20, 0x45);
+	mipi_dbi_write(reg, HX8340_SETPWCTR4, 0x33, 0x25, 0x4C);
+	msleep(10);
+
+	mipi_dbi_write(reg, MIPI_DCS_SET_PIXEL_FORMAT, 0x05);
+
+	switch (mipi->rotation) {
+	default:
+		addr_mode = 0;
+		break;
+	case 90:
+		addr_mode = HX8340_MADCTL_MV | HX8340_MADCTL_MY;
+		break;
+	case 180:
+		addr_mode = HX8340_MADCTL_MY;
+		break;
+	case 270:
+		addr_mode = HX8340_MADCTL_MX | HX8340_MADCTL_MV;
+		break;
+	}
+	addr_mode |= HX8340_MADCTL_BGR;
+	mipi_dbi_write(reg, MIPI_DCS_SET_ADDRESS_MODE, addr_mode);
+
+	mipi_dbi_write(reg, MIPI_DCS_SET_DISPLAY_ON);
+	msleep(50);
+
+	tdev->prepared = true;
+	if (pipe->plane.state->fb)
+		schedule_work(&tdev->dirty_work);
+
+out_unlock:
+	mutex_unlock(&tdev->dev_lock);
+}
+
+/*
+ * 1.8" Color TFT LCD display - ST7735R (#358)
+ * Product: https://www.adafruit.com/products/358
+ *
+ * Init sequence taken from the Adafruit-ST7735-Library (Black Tab)
+ */
+static void adafruit_tft_358_enable(struct drm_simple_display_pipe *pipe,
+				    struct drm_crtc_state *crtc_state)
+{
+	struct tinydrm_device *tdev = pipe_to_tinydrm(pipe);
+	struct mipi_dbi *mipi = mipi_dbi_from_tinydrm(tdev);
+	struct device *dev = tdev->drm.dev;
+	struct regmap *reg = mipi->reg;
+	u8 addr_mode;
+	int ret;
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	mutex_lock(&tdev->dev_lock);
+
+	if (tdev->prepared)
+		goto out_unlock;
+
+	if (mipi->regulator) {
+		ret = regulator_enable(mipi->regulator);
+		if (ret) {
+			dev_err(dev, "Failed to enable regulator %d\n", ret);
+			goto out_unlock;
+		}
+	}
+
+	mipi_dbi_hw_reset(mipi);
+	ret = mipi_dbi_write(reg, MIPI_DCS_SOFT_RESET);
+	if (ret) {
+		dev_err(dev, "Error writing command %d\n", ret);
+		goto out_unlock;
+	}
+
+	msleep(150);
+
+	mipi_dbi_write(reg, MIPI_DCS_EXIT_SLEEP_MODE);
+	msleep(500);
+
+	mipi_dbi_write(reg, ST7735R_FRMCTR1, 0x01, 0x2C, 0x2D);
+	mipi_dbi_write(reg, ST7735R_FRMCTR2, 0x01, 0x2C, 0x2D);
+	mipi_dbi_write(reg, ST7735R_FRMCTR3,
+		       0x01, 0x2C, 0x2D, 0x01, 0x2C, 0x2D);
+	mipi_dbi_write(reg, ST7735R_INVCTR, 0x07);
+
+	mipi_dbi_write(reg, ST7735R_PWCTR1, 0xA2, 0x02, 0x84);
+	mipi_dbi_write(reg, ST7735R_PWCTR2, 0xC5);
+	mipi_dbi_write(reg, ST7735R_PWCTR3, 0x0A, 0x00);
+	mipi_dbi_write(reg, ST7735R_PWCTR4, 0x8A, 0x2A);
+	mipi_dbi_write(reg, ST7735R_PWCTR5, 0x8A, 0xEE);
+
+	mipi_dbi_write(reg, ST7735R_VMCTR1, 0x0E);
+	mipi_dbi_write(reg, MIPI_DCS_EXIT_INVERT_MODE);
+
+	switch (mipi->rotation) {
+	default:
+		addr_mode = ST7735R_MADCTL_MX | ST7735R_MADCTL_MY;
+		break;
+	case 90:
+		addr_mode = ST7735R_MADCTL_MX | ST7735R_MADCTL_MV;
+		break;
+	case 180:
+		addr_mode = 0;
+		break;
+	case 270:
+		addr_mode = ST7735R_MADCTL_MY | ST7735R_MADCTL_MV;
+		break;
+	}
+	mipi_dbi_write(reg, MIPI_DCS_SET_ADDRESS_MODE, addr_mode);
+
+	mipi_dbi_write(reg, MIPI_DCS_SET_PIXEL_FORMAT, 0x05);
+
+	mipi_dbi_write(reg, ST7735R_GAMCTRP1,
+		       0x02, 0x1c, 0x07, 0x12, 0x37, 0x32, 0x29, 0x2d,
+		       0x29, 0x25, 0x2B, 0x39, 0x00, 0x01, 0x03, 0x10);
+	mipi_dbi_write(reg, ST7735R_GAMCTRN1,
+		       0x03, 0x1d, 0x07, 0x06, 0x2E, 0x2C, 0x29, 0x2D,
+		       0x2E, 0x2E, 0x37, 0x3F, 0x00, 0x00, 0x02, 0x10);
+
+	mipi_dbi_write(reg, MIPI_DCS_ENTER_NORMAL_MODE);
+	msleep(20);
+
+	mipi_dbi_write(reg, MIPI_DCS_SET_DISPLAY_ON);
+	msleep(100);
+
+	tdev->prepared = true;
+	if (pipe->plane.state->fb)
+		schedule_work(&tdev->dirty_work);
+
+out_unlock:
+	mutex_unlock(&tdev->dev_lock);
+}
+
+static const struct adafruit_tft_display adafruit_tft_displays[] = {
+	[ADAFRUIT_797] = {
+		.mode = {
+			TINYDRM_MODE(176, 220, 34, 43),
+		},
+		.funcs = {
+			.enable = adafruit_tft_797_enable,
+			.disable = mipi_dbi_pipe_disable,
+			.update = tinydrm_display_pipe_update,
+		},
+		.write_only = true,
+	},
+	[ADAFRUIT_358] = {
+		.mode = {
+			TINYDRM_MODE(128, 160, 28, 35),
+		},
+		.funcs = {
+			.enable = adafruit_tft_358_enable,
+			.disable = mipi_dbi_pipe_disable,
+			.update = tinydrm_display_pipe_update,
+		},
+		.dc = true,
+		.write_only = true,
+	},
+};
+
+static const struct of_device_id adafruit_tft_of_match[] = {
+	{ .compatible = "adafruit,tft797",  .data = (void *)ADAFRUIT_797 },
+	{ .compatible = "adafruit,tft358",  .data = (void *)ADAFRUIT_358 },
+	{},
+};
+MODULE_DEVICE_TABLE(of, adafruit_tft_of_match);
+
+static const struct spi_device_id adafruit_tft_id[] = {
+	{ "tft797",  ADAFRUIT_797 },
+	{ "tft358",  ADAFRUIT_358 },
+	{ },
+};
+MODULE_DEVICE_TABLE(spi, adafruit_tft_id);
+
+static struct drm_driver adafruit_tft_driver = {
+	.driver_features	= DRIVER_GEM | DRIVER_MODESET | DRIVER_PRIME |
+				  DRIVER_ATOMIC,
+	TINYDRM_GEM_DRIVER_OPS,
+	.lastclose		= tinydrm_lastclose,
+	.debugfs_init		= mipi_dbi_debugfs_init,
+	.debugfs_cleanup	= mipi_dbi_debugfs_cleanup,
+	.name			= "adafruit-tft",
+	.desc			= "Adafruit TFT",
+	.date			= "20160317",
+	.major			= 1,
+	.minor			= 0,
+};
+
+static int adafruit_tft_probe(struct spi_device *spi)
+{
+	const struct adafruit_tft_display *display;
+	const struct of_device_id *of_id;
+	struct device *dev = &spi->dev;
+	struct tinydrm_device *tdev;
+	struct gpio_desc *dc = NULL;
+	struct mipi_dbi *mipi;
+	u32 rotation = 0;
+	int id, ret;
+
+	of_id = of_match_device(adafruit_tft_of_match, dev);
+	if (of_id) {
+		id = (int)of_id->data;
+	} else {
+		const struct spi_device_id *spi_id = spi_get_device_id(spi);
+
+		if (!spi_id)
+			return -EINVAL;
+
+		id = spi_id->driver_data;
+	}
+
+	if (!dev->coherent_dma_mask) {
+		ret = dma_coerce_mask_and_coherent(dev, DMA_BIT_MASK(32));
+		if (ret)
+			dev_warn(dev, "Failed to set dma mask %d\n", ret);
+	}
+
+	display = &adafruit_tft_displays[id];
+
+	mipi = devm_kzalloc(dev, sizeof(*mipi), GFP_KERNEL);
+	if (!mipi)
+		return -ENOMEM;
+
+	mipi->reset = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(mipi->reset)) {
+		dev_err(dev, "Failed to get gpio 'reset'\n");
+		return PTR_ERR(mipi->reset);
+	}
+
+	if (display->dc) {
+		dc = devm_gpiod_get_optional(dev, "dc", GPIOD_OUT_LOW);
+		if (IS_ERR(dc)) {
+			dev_err(dev, "Failed to get gpio 'dc'\n");
+			return PTR_ERR(dc);
+		}
+	}
+
+	mipi->regulator = devm_regulator_get_optional(dev, "power");
+	if (IS_ERR(mipi->regulator)) {
+		ret = PTR_ERR(mipi->regulator);
+		if (ret != -ENODEV)
+			return ret;
+
+		mipi->regulator = NULL;
+	}
+
+	mipi->backlight = tinydrm_of_find_backlight(dev);
+	if (IS_ERR(mipi->backlight))
+		return PTR_ERR(mipi->backlight);
+
+	device_property_read_u32(dev, "rotation", &rotation);
+
+	mipi->reg = mipi_dbi_spi_init(spi, dc, display->write_only);
+	if (IS_ERR(mipi->reg))
+		return PTR_ERR(mipi->reg);
+
+	ret = mipi_dbi_init(dev, mipi, &display->funcs, &adafruit_tft_driver,
+			    &display->mode, rotation);
+	if (ret)
+		return ret;
+
+	tdev = &mipi->tinydrm;
+
+	ret = devm_tinydrm_register(tdev);
+	if (ret)
+		return ret;
+
+	spi_set_drvdata(spi, tdev);
+
+	DRM_DEBUG_DRIVER("Initialized %s:%s @%uMHz on minor %d\n",
+			 tdev->drm.driver->name, dev_name(dev),
+			 spi->max_speed_hz / 1000000,
+			 tdev->drm.primary->index);
+
+	return 0;
+}
+
+static struct spi_driver adafruit_tft_spi_driver = {
+	.driver = {
+		.name = "adafruit-tft",
+		.owner = THIS_MODULE,
+		.of_match_table = adafruit_tft_of_match,
+		.pm = &tinydrm_simple_pm_ops,
+	},
+	.id_table = adafruit_tft_id,
+	.probe = adafruit_tft_probe,
+	.shutdown = tinydrm_spi_shutdown,
+};
+module_spi_driver(adafruit_tft_spi_driver);
+
+MODULE_DESCRIPTION("Adafruit MIPI compatible SPI displays");
+MODULE_AUTHOR("Noralf Tr√∏nnes");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/tinydrm/core/Makefile b/drivers/gpu/drm/tinydrm/core/Makefile
new file mode 100644
index 000000000000..4e317e86ccfa
--- /dev/null
+++ b/drivers/gpu/drm/tinydrm/core/Makefile
@@ -0,0 +1,6 @@
+ccflags-y += -I$(src)/../include
+
+tinydrm-y := tinydrm-core.o tinydrm-pipe.o tinydrm-fb.o tinydrm-helpers.o
+tinydrm-$(CONFIG_REGMAP) += tinydrm-regmap.o
+
+obj-$(CONFIG_DRM_TINYDRM) += tinydrm.o
diff --git a/drivers/gpu/drm/tinydrm/core/tinydrm-core.c b/drivers/gpu/drm/tinydrm/core/tinydrm-core.c
new file mode 100644
index 000000000000..e14d94dda1a2
--- /dev/null
+++ b/drivers/gpu/drm/tinydrm/core/tinydrm-core.c
@@ -0,0 +1,388 @@
+/*
+ * Copyright (C) 2016 Noralf Tr√∏nnes
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <drm/drmP.h>
+#include <drm/drm_atomic.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_fb_cma_helper.h>
+#include <drm/drm_fb_helper.h>
+#include <drm/tinydrm/tinydrm.h>
+#include <linux/console.h>
+#include <linux/device.h>
+#include <linux/dma-buf.h>
+
+/**
+ * DOC: Overview
+ *
+ * This library provides helpers for displays with onboard graphics memory
+ * connected through a slow interface.
+ *
+ * In order for the display to turn off at shutdown, the device driver shutdown
+ * callback has to be set. This function should call tinydrm_shutdown().
+ */
+
+/**
+ * tinydrm_lastclose - DRM .lastclose() helper
+ * @drm: DRM device
+ *
+ * This function ensures that fbdev is restored when drm_lastclose() is called
+ * on the last drm_release(). If fbdev is disabled the pipeline is disabled
+ * instead. tinydrm drivers should use this as their &drm_driver->lastclose
+ * callback.
+ */
+void tinydrm_lastclose(struct drm_device *drm)
+{
+	struct tinydrm_device *tdev = drm_to_tinydrm(drm);
+
+	DRM_DEBUG_KMS("\n");
+	drm_fbdev_cma_restore_mode(tdev->fbdev_cma);
+}
+EXPORT_SYMBOL(tinydrm_lastclose);
+
+/**
+ * tinydrm_gem_cma_free_object - free resources associated with a CMA GEM
+ *                               object
+ * @gem_obj: GEM object to free
+ *
+ * This function frees the backing memory of the CMA GEM object, cleans up the
+ * GEM object state and frees the memory used to store the object itself using
+ * drm_gem_cma_free_object(). It also handles PRIME buffers which has the kernel
+ * virtual address set by tinydrm_gem_cma_prime_import_sg_table(). tinydrm
+ * drivers should set this as their &drm_driver->gem_free_object callback.
+ */
+void tinydrm_gem_cma_free_object(struct drm_gem_object *gem_obj)
+{
+	if (gem_obj->import_attach) {
+		struct drm_gem_cma_object *cma_obj;
+
+		cma_obj = to_drm_gem_cma_obj(gem_obj);
+		dma_buf_vunmap(gem_obj->import_attach->dmabuf, cma_obj->vaddr);
+		cma_obj->vaddr = NULL;
+	}
+
+	drm_gem_cma_free_object(gem_obj);
+}
+EXPORT_SYMBOL_GPL(tinydrm_gem_cma_free_object);
+
+/**
+ * tinydrm_gem_cma_prime_import_sg_table - produce a CMA GEM object from
+ *     another driver's scatter/gather table of pinned pages
+ * @drm: device to import into
+ * @attach: DMA-BUF attachment
+ * @sgt: scatter/gather table of pinned pages
+ *
+ * This function imports a scatter/gather table exported via DMA-BUF by
+ * another driver using drm_gem_cma_prime_import_sg_table(). It also sets the
+ * kernel virtual address on the CMA object. tinydrm drivers should use this
+ * as their &drm_driver->gem_prime_import_sg_table callback.
+ *
+ * Returns:
+ * A pointer to a newly created GEM object or an ERR_PTR-encoded negative
+ * error code on failure.
+ */
+struct drm_gem_object *
+tinydrm_gem_cma_prime_import_sg_table(struct drm_device *drm,
+				      struct dma_buf_attachment *attach,
+				      struct sg_table *sgt)
+{
+	struct drm_gem_cma_object *cma_obj;
+	struct drm_gem_object *obj;
+	void *vaddr;
+
+	vaddr = dma_buf_vmap(attach->dmabuf);
+	if (!vaddr) {
+		DRM_ERROR("Failed to vmap PRIME buffer\n");
+		return ERR_PTR(-ENOMEM);
+	}
+
+	obj = drm_gem_cma_prime_import_sg_table(drm, attach, sgt);
+	if (IS_ERR(obj)) {
+		dma_buf_vunmap(attach->dmabuf, vaddr);
+		return obj;
+	}
+
+	cma_obj = to_drm_gem_cma_obj(obj);
+	cma_obj->vaddr = vaddr;
+
+	return obj;
+}
+EXPORT_SYMBOL(tinydrm_gem_cma_prime_import_sg_table);
+
+const struct file_operations tinydrm_fops = {
+	.owner		= THIS_MODULE,
+	.open		= drm_open,
+	.release	= drm_release,
+	.unlocked_ioctl	= drm_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl	= drm_compat_ioctl,
+#endif
+	.poll		= drm_poll,
+	.read		= drm_read,
+	.llseek		= no_llseek,
+	.mmap		= drm_gem_cma_mmap,
+};
+EXPORT_SYMBOL(tinydrm_fops);
+
+static const struct drm_mode_config_funcs tinydrm_mode_config_funcs = {
+	.fb_create = tinydrm_fb_create,
+	.atomic_check = drm_atomic_helper_check,
+	.atomic_commit = drm_atomic_helper_commit,
+};
+
+static void tinydrm_dirty_work(struct work_struct *work)
+{
+	struct tinydrm_device *tdev = container_of(work, struct tinydrm_device,
+						   dirty_work);
+	struct drm_framebuffer *fb = tdev->pipe.plane.fb;
+	struct drm_crtc *crtc = &tdev->pipe.crtc;
+
+	if (fb && fb->funcs->dirty)
+		fb->funcs->dirty(fb, NULL, 0, 0, NULL, 0);
+
+	if (tdev->event) {
+		DRM_DEBUG_KMS("crtc event\n");
+		spin_lock_irq(&crtc->dev->event_lock);
+		drm_crtc_send_vblank_event(crtc, tdev->event);
+		spin_unlock_irq(&crtc->dev->event_lock);
+		tdev->event = NULL;
+	}
+}
+
+static int tinydrm_init(struct device *parent, struct tinydrm_device *tdev,
+			const struct drm_framebuffer_funcs *fb_funcs,
+			struct drm_driver *driver)
+{
+	struct drm_device *drm = &tdev->drm;
+	int ret;
+
+	INIT_WORK(&tdev->dirty_work, tinydrm_dirty_work);
+	mutex_init(&tdev->dev_lock);
+	tdev->fb_funcs = fb_funcs;
+
+	ret = drm_dev_init(drm, driver, parent);
+	if (ret)
+		return ret;
+
+	drm_mode_config_init(drm);
+	drm->mode_config.funcs = &tinydrm_mode_config_funcs;
+
+	return 0;
+}
+
+static void tinydrm_fini(struct tinydrm_device *tdev)
+{
+	struct drm_device *drm = &tdev->drm;
+
+	DRM_DEBUG_KMS("\n");
+
+	drm_mode_config_cleanup(drm);
+	drm_dev_unref(drm);
+	mutex_destroy(&tdev->dev_lock);
+}
+
+static void devm_tinydrm_release(struct device *dev, void *res)
+{
+	tinydrm_fini(*(struct tinydrm_device **)res);
+}
+
+/**
+ * devm_tinydrm_init - Initialize tinydrm device
+ * @parent: Parent device object
+ * @tdev: tinydrm device
+ * @fb_funcs: Framebuffer functions
+ * @driver: DRM driver
+ *
+ * This function initializes @tdev, the underlying DRM device and it's
+ * mode_config. Additionally it sets &drm_mode_config_funcs using
+ * tinydrm_fb_create() for framebuffer creation.
+ * Resources will be automatically freed on driver detach (devres) using
+ * drm_mode_config_cleanup() and drm_dev_unref().
+ *
+ * Returns:
+ * Zero on success, negative error code on failure.
+ */
+int devm_tinydrm_init(struct device *parent, struct tinydrm_device *tdev,
+		      const struct drm_framebuffer_funcs *fb_funcs,
+		      struct drm_driver *driver)
+{
+	struct tinydrm_device **ptr;
+	int ret;
+
+	ptr = devres_alloc(devm_tinydrm_release, sizeof(*ptr), GFP_KERNEL);
+	if (!ptr)
+		return -ENOMEM;
+
+	ret = tinydrm_init(parent, tdev, fb_funcs, driver);
+	if (ret) {
+		devres_free(ptr);
+		return ret;
+	}
+
+	*ptr = tdev;
+	devres_add(parent, ptr);
+
+	return 0;
+}
+EXPORT_SYMBOL(devm_tinydrm_init);
+
+static int tinydrm_register(struct tinydrm_device *tdev)
+{
+	struct drm_device *drm = &tdev->drm;
+	int ret;
+
+	ret = drm_dev_register(drm, 0);
+	if (ret)
+		return ret;
+
+	ret = tinydrm_fbdev_init(tdev);
+	if (ret)
+		DRM_ERROR("Failed to initialize fbdev: %d\n", ret);
+
+	return 0;
+}
+
+static void tinydrm_unregister(struct tinydrm_device *tdev)
+{
+	struct drm_device *drm = &tdev->drm;
+
+	DRM_DEBUG_KMS("\n");
+
+	drm_crtc_force_disable_all(drm);
+	cancel_work_sync(&tdev->dirty_work);
+	tinydrm_fbdev_fini(tdev);
+	drm_dev_unregister(drm);
+}
+
+static void devm_tinydrm_register_release(struct device *dev, void *res)
+{
+	tinydrm_unregister(*(struct tinydrm_device **)res);
+}
+
+/**
+ * devm_tinydrm_register - Register tinydrm device
+ * @tdev: tinydrm device
+ *
+ * This function registers the underlying DRM device, connectors and fbdev.
+ * These resources will be automatically unregistered on driver detach (devres)
+ * and the display pipeline will be disabled.
+ *
+ * Returns:
+ * Zero on success, negative error code on failure.
+ */
+int devm_tinydrm_register(struct tinydrm_device *tdev)
+{
+	struct device *dev = tdev->drm.dev;
+	struct tinydrm_device **ptr;
+	int ret;
+
+	ptr = devres_alloc(devm_tinydrm_register_release, sizeof(*ptr),
+			   GFP_KERNEL);
+	if (!ptr)
+		return -ENOMEM;
+
+	ret = tinydrm_register(tdev);
+	if (ret) {
+		devres_free(ptr);
+		return ret;
+	}
+
+	*ptr = tdev;
+	devres_add(dev, ptr);
+
+	return 0;
+}
+EXPORT_SYMBOL(devm_tinydrm_register);
+
+/**
+ * tinydrm_shutdown - Shutdown tinydrm
+ * @tdev: tinydrm device
+ *
+ * This function makes sure that tinydrm is disabled and unprepared.
+ * Used by drivers in their shutdown callback to turn off the display
+ * on machine shutdown and reboot.
+ */
+void tinydrm_shutdown(struct tinydrm_device *tdev)
+{
+	struct drm_device *drm = &tdev->drm;
+
+	drm_crtc_force_disable_all(drm);
+}
+EXPORT_SYMBOL(tinydrm_shutdown);
+
+/**
+ * tinydrm_suspend - Suspend tinydrm
+ * @tdev: tinydrm device
+ *
+ * Used in driver PM operations to suspend tinydrm.
+ * Suspends fbdev and DRM.
+ * Resume with tinydrm_resume().
+ *
+ * Returns:
+ * Zero on success, negative error code on failure.
+ */
+int tinydrm_suspend(struct tinydrm_device *tdev)
+{
+	struct drm_device *drm = &tdev->drm;
+	struct drm_atomic_state *state;
+
+	if (tdev->suspend_state) {
+		DRM_ERROR("Failed to suspend: state already set\n");
+		return -EINVAL;
+	}
+
+	drm_fbdev_cma_set_suspend_unlocked(tdev->fbdev_cma, 1);
+	state = drm_atomic_helper_suspend(drm);
+	if (IS_ERR(state)) {
+		drm_fbdev_cma_set_suspend_unlocked(tdev->fbdev_cma, 0);
+		return PTR_ERR(state);
+	}
+
+	tdev->suspend_state = state;
+
+	return 0;
+}
+EXPORT_SYMBOL(tinydrm_suspend);
+
+/**
+ * tinydrm_resume - Resume tinydrm
+ * @tdev: tinydrm device
+ *
+ * Used in driver PM operations to resume tinydrm.
+ * Suspend with tinydrm_suspend().
+ *
+ * Returns:
+ * Zero on success, negative error code on failure.
+ */
+int tinydrm_resume(struct tinydrm_device *tdev)
+{
+	struct drm_atomic_state *state = tdev->suspend_state;
+	struct drm_device *drm = &tdev->drm;
+	int ret;
+
+	if (!state) {
+		DRM_ERROR("Failed to resume: state is not set\n");
+		return -EINVAL;
+	}
+
+	tdev->suspend_state = NULL;
+
+	ret = drm_atomic_helper_resume(drm, state);
+	if (ret) {
+		DRM_ERROR("Error resuming state: %d\n", ret);
+		return ret;
+	}
+
+	drm_fbdev_cma_set_suspend_unlocked(tdev->fbdev_cma, 0);
+
+	return 0;
+}
+EXPORT_SYMBOL(tinydrm_resume);
+
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/tinydrm/core/tinydrm-fb.c b/drivers/gpu/drm/tinydrm/core/tinydrm-fb.c
new file mode 100644
index 000000000000..f054875fb0ba
--- /dev/null
+++ b/drivers/gpu/drm/tinydrm/core/tinydrm-fb.c
@@ -0,0 +1,141 @@
+/*
+ * Copyright (C) 2016 Noralf Tr√∏nnes
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <drm/drmP.h>
+#include <drm/drm_crtc.h>
+#include <drm/drm_fb_cma_helper.h>
+#include <drm/drm_fb_helper.h>
+#include <drm/tinydrm/tinydrm.h>
+
+/**
+ * DOC: Framebuffer
+ *
+ * The tinydrm &drm_framebuffer is backed by a &drm_gem_cma_object buffer
+ * object. Userspace creates this buffer by calling the
+ * DRM_IOCTL_MODE_CREATE_DUMB ioctl. To flush the buffer to the display,
+ * userpace calls the DRM_IOCTL_MODE_DIRTYFB ioctl on the framebuffer which
+ * in turn calls the &drm_framebuffer_funcs->dirty callback.
+ * This functionality is available by using tinydrm_fb_create() as the
+ * &drm_mode_config_funcs->fb_create callback which devm_tinydrm_init() does.
+ */
+
+/**
+ * tinydrm_check_dirty - check before flushing framebuffer
+ * @fb: framebuffer
+ * @clips: pointer to dirty clip rectangles array
+ * @num_clips: pointer to number of clips
+ *
+ * This function checks that the device is prepared and that @fb is the
+ * framebuffer set on the plane. If the device hasn't been enabled, which
+ * makes this the first flush, do flush everything.
+ * Caller has to hold the dev_lock.
+ *
+ * Returns:
+ * True if the dirty call can proceed, false otherwise.
+ */
+bool tinydrm_check_dirty(struct drm_framebuffer *fb,
+			 struct drm_clip_rect **clips, unsigned int *num_clips)
+{
+	struct tinydrm_device *tdev = drm_to_tinydrm(fb->dev);
+
+	WARN_ON_ONCE(!mutex_is_locked(&tdev->dev_lock));
+
+	if (!tdev->prepared)
+		return false;
+
+	/* fbdev can flush even when we're not interested */
+	if (tdev->pipe.plane.fb != fb)
+		return false;
+
+	/* Make sure to flush everything the first time */
+	if (!tdev->enabled) {
+		*clips = NULL;
+		*num_clips = 0;
+	}
+
+	return true;
+}
+EXPORT_SYMBOL(tinydrm_check_dirty);
+
+/**
+ * tinydrm_fb_create - tinydrm .fb_create() helper
+ * @drm: DRM device
+ * @file_priv: DRM file info
+ * @mode_cmd: metadata from the userspace fb creation request
+ *
+ * Helper for the &drm_mode_config_funcs->fb_create callback.
+ * It sets up a &drm_framebuffer backed by the &drm_gem_cma_object buffer
+ * object provided in @mode_cmd.
+ */
+struct drm_framebuffer *
+tinydrm_fb_create(struct drm_device *drm, struct drm_file *file_priv,
+		  const struct drm_mode_fb_cmd2 *mode_cmd)
+{
+	struct tinydrm_device *tdev = drm_to_tinydrm(drm);
+
+	return drm_fb_cma_create_with_funcs(drm, file_priv, mode_cmd,
+					    tdev->fb_funcs);
+}
+EXPORT_SYMBOL(tinydrm_fb_create);
+
+/**
+ * DOC: fbdev emulation
+ *
+ * tinydrm provides fbdev emulation using the drm_fb_cma_helper library.
+ * It is backed by it's own &drm_framebuffer and CMA buffer object.
+ * Framebuffer flushing is handled by the fb helper library which in turn
+ * calls the dirty callback on the framebuffer. This callback is part of
+ * &drm_framebuffer_funcs which is one of the arguments to devm_tinydrm_init().
+ * fbdev support is initialized using tinydrm_fbdev_init().
+ *
+ * The tinydrm_lastclose() function ensures that fbdev operation is restored
+ * when userspace closes the drm device.
+ */
+
+/**
+ * tinydrm_fbdev_init - initialize tinydrm fbdev emulation
+ * @tdev: tinydrm device
+ *
+ * Initialize tinydrm fbdev emulation. Tear down with tinydrm_fbdev_fini().
+ * If &mode_config->preferred_depth is set it is used as preferred bpp.
+ */
+int tinydrm_fbdev_init(struct tinydrm_device *tdev)
+{
+	struct drm_device *drm = &tdev->drm;
+	struct drm_fbdev_cma *fbdev;
+	int bpp;
+
+	DRM_DEBUG_KMS("\n");
+
+	bpp = drm->mode_config.preferred_depth;
+	fbdev = drm_fbdev_cma_init_with_funcs(drm, bpp ? bpp : 32,
+					      drm->mode_config.num_crtc,
+					      drm->mode_config.num_connector,
+					      tdev->fb_funcs);
+	if (IS_ERR(fbdev))
+		return PTR_ERR(fbdev);
+
+	tdev->fbdev_cma = fbdev;
+
+	return 0;
+}
+EXPORT_SYMBOL(tinydrm_fbdev_init);
+
+/**
+ * tinydrm_fbdev_fini - finalize tinydrm fbdev emulation
+ * @tdev: tinydrm device
+ *
+ * This function tears down the fbdev emulation
+ */
+void tinydrm_fbdev_fini(struct tinydrm_device *tdev)
+{
+	drm_fbdev_cma_fini(tdev->fbdev_cma);
+	tdev->fbdev_cma = NULL;
+}
+EXPORT_SYMBOL(tinydrm_fbdev_fini);
diff --git a/drivers/gpu/drm/tinydrm/core/tinydrm-helpers.c b/drivers/gpu/drm/tinydrm/core/tinydrm-helpers.c
new file mode 100644
index 000000000000..4834a1f0db2b
--- /dev/null
+++ b/drivers/gpu/drm/tinydrm/core/tinydrm-helpers.c
@@ -0,0 +1,289 @@
+/*
+ * Copyright (C) 2016 Noralf Tr√∏nnes
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <drm/drmP.h>
+#include <drm/tinydrm/tinydrm.h>
+#include <linux/backlight.h>
+#include <linux/pm.h>
+#include <linux/spi/spi.h>
+
+/**
+ * tinydrm_merge_clips - merge clip rectangles
+ * @dst: destination clip rectangle
+ * @src: source clip rectangle(s)
+ * @num_clips: number of @src clip rectangles
+ * @flags: dirty fb ioctl flags
+ * @max_width: maximum width of @dst
+ * @max_height: maximum height of @dst
+ *
+ * This function merges @src clip rectangle(s) into @dst. If @src is NULL,
+ * @max_width and @min_width is used to set a full @dst clip rectangle.
+ *
+ * Returns:
+ * true if it's a full clip, false otherwise
+ */
+bool tinydrm_merge_clips(struct drm_clip_rect *dst,
+			 struct drm_clip_rect *src, unsigned int num_clips,
+			 unsigned int flags, u32 max_width, u32 max_height)
+{
+	unsigned int i;
+
+	if (!src || !num_clips) {
+		dst->x1 = 0;
+		dst->x2 = max_width;
+		dst->y1 = 0;
+		dst->y2 = max_height;
+		return true;
+	}
+
+	dst->x1 = ~0;
+	dst->y1 = ~0;
+	dst->x2 = 0;
+	dst->y2 = 0;
+
+	for (i = 0; i < num_clips; i++) {
+		if (flags & DRM_MODE_FB_DIRTY_ANNOTATE_COPY)
+			i++;
+		dst->x1 = min(dst->x1, src[i].x1);
+		dst->x2 = max(dst->x2, src[i].x2);
+		dst->y1 = min(dst->y1, src[i].y1);
+		dst->y2 = max(dst->y2, src[i].y2);
+	}
+
+	if (dst->x2 > max_width || dst->y2 > max_height ||
+	    dst->x1 >= dst->x2 || dst->y1 >= dst->y2) {
+		DRM_DEBUG_KMS("Illegal clip: x1=%u, x2=%u, y1=%u, y2=%u\n",
+			      dst->x1, dst->x2, dst->y1, dst->y2);
+		dst->x1 = 0;
+		dst->y1 = 0;
+		dst->x2 = max_width;
+		dst->y2 = max_height;
+	}
+
+	return (dst->x2 - dst->x1) == max_width &&
+	       (dst->y2 - dst->y1) == max_height;
+}
+EXPORT_SYMBOL(tinydrm_merge_clips);
+
+/**
+ * tinydrm_memcpy - Copy clip buffer
+ * @dst: Destination buffer
+ * @vaddr: Source buffer
+ * @fb: DRM framebuffer
+ * @clip: Clip rectangle area to copy
+ */
+void tinydrm_memcpy(void *dst, void *vaddr, struct drm_framebuffer *fb,
+		    struct drm_clip_rect *clip)
+{
+	unsigned int cpp = drm_format_plane_cpp(fb->format->format, 0);
+	unsigned int pitch = fb->pitches[0];
+	void *src = vaddr + (clip->y1 * pitch) + (clip->x1 * cpp);
+	size_t len = (clip->x2 - clip->x1) * cpp;
+	unsigned int y;
+
+	for (y = clip->y1; y < clip->y2; y++) {
+		memcpy(dst, src, len);
+		src += pitch;
+		dst += len;
+	}
+}
+EXPORT_SYMBOL(tinydrm_memcpy);
+
+/**
+ * tinydrm_swab16 - Swap bytes into clip buffer
+ * @dst: rgb565 destination buffer
+ * @vaddr: rgb565 source buffer
+ * @fb: DRM framebuffer
+ * @clip: Clip rectangle area to copy
+ */
+void tinydrm_swab16(u16 *dst, void *vaddr, struct drm_framebuffer *fb,
+		    struct drm_clip_rect *clip)
+{
+	unsigned int pitch = fb->pitches[0];
+	unsigned int x, y;
+	u16 *src;
+
+	for (y = clip->y1; y < clip->y2; y++) {
+		src = vaddr + (y * pitch);
+		src += clip->x1;
+		for (x = clip->x1; x < clip->x2; x++)
+			*dst++ = swab16(*src++);
+	}
+}
+EXPORT_SYMBOL(tinydrm_swab16);
+
+/**
+ * tinydrm_xrgb8888_to_rgb565 - convert xrgb8888 to rgb565 clip buffer
+ * @dst: rgb565 destination buffer
+ * @vaddr: xrgb8888 source buffer
+ * @fb: DRM framebuffer
+ * @clip: Clip rectangle area to copy
+ * @swap: Swap bytes
+ *
+ * Drivers can use this function for rgb565 devices that don't natively
+ * support xrgb8888.
+ */
+void tinydrm_xrgb8888_to_rgb565(u16 *dst, void *vaddr,
+				struct drm_framebuffer *fb,
+				struct drm_clip_rect *clip, bool swap)
+{
+	unsigned int pitch = fb->pitches[0];
+	unsigned int x, y;
+	u16 val16;
+	u32 *src;
+
+	for (y = clip->y1; y < clip->y2; y++) {
+		src = vaddr + (y * pitch);
+		src += clip->x1;
+		for (x = clip->x1; x < clip->x2; x++) {
+			val16 = ((*src & 0x00F80000) >> 8) |
+				((*src & 0x0000FC00) >> 5) |
+				((*src & 0x000000F8) >> 3);
+			src++;
+			if (swap)
+				*dst++ = swab16(val16);
+			else
+				*dst++ = val16;
+		}
+	}
+}
+EXPORT_SYMBOL(tinydrm_xrgb8888_to_rgb565);
+
+#ifdef CONFIG_BACKLIGHT_CLASS_DEVICE
+/**
+ * tinydrm_of_find_backlight - find backlight device in device-tree
+ * @dev: device
+ *
+ * This function looks for a DT node pointed to by a property named 'backlight'
+ * and uses of_find_backlight_by_node() to get the backlight device.
+ * Additionally if the brightness property is zero, it is set to
+ * max_brightness.
+ *
+ * Returns:
+ * NULL if there's no backlight property.
+ * Error pointer -EPROBE_DEFER if the DT node is found, but no backlight device
+ * is found.
+ * If the backlight device is found, a pointer to the structure is returned.
+ */
+struct backlight_device *tinydrm_of_find_backlight(struct device *dev)
+{
+	struct backlight_device *backlight;
+	struct device_node *np;
+
+	np = of_parse_phandle(dev->of_node, "backlight", 0);
+	if (!np)
+		return NULL;
+
+	backlight = of_find_backlight_by_node(np);
+	of_node_put(np);
+
+	if (!backlight)
+		return ERR_PTR(-EPROBE_DEFER);
+
+	if (!backlight->props.brightness) {
+		backlight->props.brightness = backlight->props.max_brightness;
+		DRM_DEBUG_KMS("Backlight brightness set to %d\n",
+			      backlight->props.brightness);
+	}
+
+	return backlight;
+}
+EXPORT_SYMBOL(tinydrm_of_find_backlight);
+
+/**
+ * tinydrm_enable_backlight - enable backlight helper
+ * @backlight: backlight device
+ *
+ * Helper to enable backlight for use in &tinydrm_funcs ->enable callback
+ * functions.
+ */
+int tinydrm_enable_backlight(struct backlight_device *backlight)
+{
+	unsigned int old_state;
+
+	if (!backlight)
+		return 0;
+
+	old_state = backlight->props.state;
+	backlight->props.state &= ~BL_CORE_SUSPENDED;
+	DRM_DEBUG_KMS("Backlight state: 0x%x -> 0x%x\n", old_state,
+		      backlight->props.state);
+
+	return backlight_update_status(backlight);
+}
+EXPORT_SYMBOL(tinydrm_enable_backlight);
+
+/**
+ * tinydrm_disable_backlight - disable backlight helper
+ * @backlight: backlight device
+ *
+ * Helper to disable backlight for use in &tinydrm_funcs ->disable callback
+ * functions.
+ */
+void tinydrm_disable_backlight(struct backlight_device *backlight)
+{
+	unsigned int old_state;
+	int ret;
+
+	if (!backlight)
+		return;
+
+	old_state = backlight->props.state;
+	backlight->props.state |= BL_CORE_SUSPENDED;
+	DRM_DEBUG_KMS("Backlight state: 0x%x -> 0x%x\n", old_state,
+		      backlight->props.state);
+	ret = backlight_update_status(backlight);
+	if (ret)
+		DRM_ERROR("Failed to disable backlight %d\n", ret);
+}
+EXPORT_SYMBOL(tinydrm_disable_backlight);
+#endif
+
+static int __maybe_unused tinydrm_pm_suspend(struct device *dev)
+{
+	struct tinydrm_device *tdev = dev_get_drvdata(dev);
+
+	return tdev ? tinydrm_suspend(tdev) : -EINVAL;
+}
+
+static int __maybe_unused tinydrm_pm_resume(struct device *dev)
+{
+	struct tinydrm_device *tdev = dev_get_drvdata(dev);
+
+	return tdev ? tinydrm_resume(tdev) : -EINVAL;
+}
+
+/*
+ * tinydrm_simple_pm_ops - tinydrm simple power management operations
+ *
+ * This provides simple suspend/resume power management and can be assigned
+ * to the drivers &device_driver->pm property. &tinydrm_device must be set
+ * on the device using dev_set_drvdata() or equivalent.
+ */
+const struct dev_pm_ops tinydrm_simple_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(tinydrm_pm_suspend, tinydrm_pm_resume)
+};
+EXPORT_SYMBOL(tinydrm_simple_pm_ops);
+
+/**
+ * tinydrm_spi_shutdown - SPI driver shutdown callback helper
+ * @spi: SPI device
+ *
+ * This is a helper function for the &spi_driver ->shutdown callback which
+ * makes sure that the tinydrm device is disabled and unprepared on shutdown.
+ * &tinydrm_device must be set on the device using spi_set_drvdata().
+ */
+void tinydrm_spi_shutdown(struct spi_device *spi)
+{
+	struct tinydrm_device *tdev = spi_get_drvdata(spi);
+
+	if (tdev)
+		tinydrm_shutdown(tdev);
+}
+EXPORT_SYMBOL(tinydrm_spi_shutdown);
diff --git a/drivers/gpu/drm/tinydrm/core/tinydrm-pipe.c b/drivers/gpu/drm/tinydrm/core/tinydrm-pipe.c
new file mode 100644
index 000000000000..107398587fb4
--- /dev/null
+++ b/drivers/gpu/drm/tinydrm/core/tinydrm-pipe.c
@@ -0,0 +1,248 @@
+/*
+ * Copyright (C) 2016 Noralf Tr√∏nnes
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <drm/drmP.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_fb_helper.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_simple_kms_helper.h>
+#include <drm/tinydrm/tinydrm.h>
+
+struct tinydrm_connector {
+	struct drm_connector base;
+	const struct drm_display_mode *mode;
+};
+
+static inline struct tinydrm_connector *
+to_tinydrm_connector(struct drm_connector *connector)
+{
+	return container_of(connector, struct tinydrm_connector, base);
+}
+
+static int tinydrm_connector_get_modes(struct drm_connector *connector)
+{
+	struct tinydrm_connector *tconn = to_tinydrm_connector(connector);
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, tconn->mode);
+	if (!mode) {
+		DRM_ERROR("Failed to duplicate mode\n");
+		return 0;
+	}
+
+	if (mode->name[0] == '\0')
+		drm_mode_set_name(mode);
+
+	mode->type |= DRM_MODE_TYPE_PREFERRED;
+	drm_mode_probed_add(connector, mode);
+
+	if (mode->width_mm) {
+		connector->display_info.width_mm = mode->width_mm;
+		connector->display_info.height_mm = mode->height_mm;
+	}
+
+	return 1;
+}
+
+static const struct drm_connector_helper_funcs tinydrm_connector_hfuncs = {
+	.get_modes = tinydrm_connector_get_modes,
+	.best_encoder = drm_atomic_helper_best_encoder,
+};
+
+static enum drm_connector_status
+tinydrm_connector_detect(struct drm_connector *connector, bool force)
+{
+	if (drm_device_is_unplugged(connector->dev))
+		return connector_status_disconnected;
+
+	return connector->status;
+}
+
+static void tinydrm_connector_destroy(struct drm_connector *connector)
+{
+	struct tinydrm_connector *tconn = to_tinydrm_connector(connector);
+
+	drm_connector_cleanup(connector);
+	kfree(tconn);
+}
+
+static const struct drm_connector_funcs tinydrm_connector_funcs = {
+	.dpms = drm_atomic_helper_connector_dpms,
+	.reset = drm_atomic_helper_connector_reset,
+	.detect = tinydrm_connector_detect,
+	.fill_modes = drm_helper_probe_single_connector_modes,
+	.destroy = tinydrm_connector_destroy,
+	.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
+};
+
+/**
+ * tinydrm_connector_create - Create simple connector
+ * @drm: DRM device
+ * @mode: Supported display mode
+ * @connector_type: Connector type
+ *
+ * This function creates a simple &drm_connector with one fixed
+ * &drm_display_mode.
+ *
+ * Returns:
+ * DRM connector on success, error pointer on failure.
+ */
+struct drm_connector *
+tinydrm_connector_create(struct drm_device *drm,
+			 const struct drm_display_mode *mode,
+			 int connector_type)
+{
+	struct tinydrm_connector *tconn;
+	struct drm_connector *connector;
+	int ret;
+
+	tconn = kzalloc(sizeof(*tconn), GFP_KERNEL);
+	if (!tconn)
+		return ERR_PTR(-ENOMEM);
+
+	tconn->mode = mode;
+	connector = &tconn->base;
+
+	drm_connector_helper_add(connector, &tinydrm_connector_hfuncs);
+	ret = drm_connector_init(drm, connector, &tinydrm_connector_funcs,
+				 connector_type);
+	if (ret) {
+		kfree(tconn);
+		return ERR_PTR(ret);
+	}
+
+	connector->status = connector_status_connected;
+
+	return connector;
+}
+EXPORT_SYMBOL(tinydrm_connector_create);
+
+/**
+ * tinydrm_display_pipe_update - Display pipe update helper
+ * @pipe: Simple display pipe
+ * @old_state: Old plane state
+ *
+ * This function schedules a full framebuffer flush if the plane framebuffer
+ * has changed. It also detects if fbdev is being used.
+ * Drivers can use this as their &drm_simple_display_pipe_funcs->update
+ * callback.
+ */
+void tinydrm_display_pipe_update(struct drm_simple_display_pipe *pipe,
+				 struct drm_plane_state *old_state)
+{
+	struct tinydrm_device *tdev = pipe_to_tinydrm(pipe);
+	struct drm_framebuffer *fb = pipe->plane.state->fb;
+	struct drm_crtc *crtc = &tdev->pipe.crtc;
+
+	if (!fb)
+		DRM_DEBUG_KMS("fb unset\n");
+	else if (fb != old_state->fb)
+		DRM_DEBUG_KMS("fb changed\n");
+	else
+		DRM_DEBUG_KMS("No fb change\n");
+
+	if (fb && (fb != old_state->fb)) {
+		struct tinydrm_device *tdev = pipe_to_tinydrm(pipe);
+
+		if (crtc->state->event) {
+			tdev->event = crtc->state->event;
+			crtc->state->event = NULL;
+		}
+
+		pipe->plane.fb = fb;
+		schedule_work(&tdev->dirty_work);
+	}
+
+	if (crtc->state->event) {
+		DRM_DEBUG_KMS("crtc event\n");
+		spin_lock_irq(&crtc->dev->event_lock);
+		drm_crtc_send_vblank_event(crtc, crtc->state->event);
+		spin_unlock_irq(&crtc->dev->event_lock);
+		crtc->state->event = NULL;
+	}
+}
+EXPORT_SYMBOL(tinydrm_display_pipe_update);
+
+static int tinydrm_rotate_mode(struct drm_display_mode *mode,
+			       unsigned int rotation)
+{
+	if (rotation == 0 || rotation == 180) {
+		return 0;
+	} else if (rotation == 90 || rotation == 270) {
+		swap(mode->hdisplay, mode->vdisplay);
+		swap(mode->hsync_start, mode->vsync_start);
+		swap(mode->hsync_end, mode->vsync_end);
+		swap(mode->htotal, mode->vtotal);
+		swap(mode->width_mm, mode->height_mm);
+		return 0;
+	} else {
+		return -EINVAL;
+	}
+}
+
+/**
+ * tinydrm_display_pipe_init - Initialize display pipe
+ * @tdev: tinydrm device
+ * @funcs: Display pipe functions
+ * @connector_type: Connector type
+ * @formats: Array of supported formats (%DRM_FORMAT_*)
+ * @format_count: Number of elements in @formats
+ * @mode: Supported mode
+ * @rotation: Initial @mode rotation in degrees Counter Clock Wise
+ *
+ * This function sets up a &drm_simple_display_pipe with a &drm_connector that
+ * has one fixed &drm_display_mode which is rotated according to @rotation.
+ *
+ * Returns:
+ * Zero on success, negative error code on failure.
+ */
+int
+tinydrm_display_pipe_init(struct tinydrm_device *tdev,
+			  const struct drm_simple_display_pipe_funcs *funcs,
+			  int connector_type,
+			  const uint32_t *formats,
+			  unsigned int format_count,
+			  const struct drm_display_mode *mode,
+			  unsigned int rotation)
+{
+	struct drm_device *drm = &tdev->drm;
+	struct drm_display_mode *mode_copy;
+	struct drm_connector *connector;
+	int ret;
+
+	mode_copy = devm_kmalloc(drm->dev, sizeof(*mode_copy), GFP_KERNEL);
+	if (!mode_copy)
+		return -ENOMEM;
+
+	*mode_copy = *mode;
+	ret = tinydrm_rotate_mode(mode_copy, rotation);
+	if (ret) {
+		DRM_ERROR("Illegal rotation value %u\n", rotation);
+		return -EINVAL;
+	}
+
+	drm->mode_config.min_width = mode_copy->hdisplay;
+	drm->mode_config.max_width = mode_copy->hdisplay;
+	drm->mode_config.min_height = mode_copy->vdisplay;
+	drm->mode_config.max_height = mode_copy->vdisplay;
+
+	connector = tinydrm_connector_create(drm, mode_copy, connector_type);
+	if (IS_ERR(connector))
+		return PTR_ERR(connector);
+
+	ret = drm_simple_display_pipe_init(drm, &tdev->pipe, funcs, formats,
+					   format_count, connector);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+EXPORT_SYMBOL(tinydrm_display_pipe_init);
diff --git a/drivers/gpu/drm/tinydrm/core/tinydrm-regmap.c b/drivers/gpu/drm/tinydrm/core/tinydrm-regmap.c
new file mode 100644
index 000000000000..e5fa2f6d07c9
--- /dev/null
+++ b/drivers/gpu/drm/tinydrm/core/tinydrm-regmap.c
@@ -0,0 +1,262 @@
+#define DEBUG
+/*
+ * Copyright (C) 2016 Noralf Tr√∏nnes
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <drm/drmP.h>
+#include <drm/tinydrm/tinydrm.h>
+#include <drm/tinydrm/tinydrm-helpers.h>
+#include <drm/tinydrm/tinydrm-regmap.h>
+#include <linux/module.h>
+#include <linux/regmap.h>
+#include <linux/spi/spi.h>
+
+static unsigned int spi_max;
+module_param(spi_max, uint, 0400);
+MODULE_PARM_DESC(spi_max, "Set a lower SPI max transfer size");
+
+#if IS_ENABLED(CONFIG_SPI)
+
+/**
+ * tinydrm_spi_max_transfer_size - Determine max SPI transfer size
+ * @spi: SPI device
+ * @max_len: Maximum buffer size needed (optional)
+ *
+ * This function returns the maximum size to use for SPI transfers. It checks
+ * the SPI master, the optional @max_len and the module parameter spi_max and
+ * returns the smallest.
+ *
+ * Returns:
+ * Maximum size for SPI transfers
+ */
+size_t tinydrm_spi_max_transfer_size(struct spi_device *spi, size_t max_len)
+{
+	size_t ret;
+
+	ret = min(spi_max_transfer_size(spi), spi->master->max_dma_len);
+	if (max_len)
+		ret = min(ret, max_len);
+	if (spi_max)
+		ret = min_t(size_t, ret, spi_max);
+	ret &= ~0x3;
+	if (ret < 4)
+		ret = 4;
+
+	return ret;
+}
+EXPORT_SYMBOL(tinydrm_spi_max_transfer_size);
+
+/**
+ * tinydrm_spi_bpw_supported - Check if bits per word is supported
+ * @spi: SPI device
+ * @bpw: Bits per word
+ *
+ * This function checks to see if the SPI master driver supports @bpw.
+ *
+ * Returns:
+ * True if @bpw is supported, false otherwise.
+ */
+bool tinydrm_spi_bpw_supported(struct spi_device *spi, u8 bpw)
+{
+	u32 bpw_mask = spi->master->bits_per_word_mask;
+
+	if (bpw == 8)
+		return true;
+
+	if (!bpw_mask) {
+		dev_warn_once(&spi->dev,
+			      "bits_per_word_mask not set, assume 8-bit only\n");
+		return false;
+	}
+
+	if (bpw_mask & SPI_BPW_MASK(bpw))
+		return true;
+
+	return false;
+}
+EXPORT_SYMBOL(tinydrm_spi_bpw_supported);
+
+/* hexdump that can do u16, useful on little endian where bytes are swapped */
+static void tinydrm_hexdump(char *linebuf, size_t linebuflen, const void *buf,
+			    size_t len, size_t bpw, size_t max)
+{
+	if (bpw > 16) {
+		snprintf(linebuf, linebuflen, "bpw not supported");
+	} else if (bpw > 8) {
+		size_t count = len > max ? max / 2 : (len / 2);
+		const u16 *buf16 = buf;
+		unsigned int j, lx = 0;
+		int ret;
+
+		for (j = 0; j < count; j++) {
+			ret = snprintf(linebuf + lx, linebuflen - lx,
+				       "%s%4.4x", j ? " " : "", *buf16++);
+			if (ret >= linebuflen - lx) {
+				snprintf(linebuf, linebuflen, "ERROR");
+				break;
+			}
+			lx += ret;
+		}
+	} else {
+		hex_dump_to_buffer(buf, len, max, 1, linebuf, linebuflen,
+				   false);
+	}
+}
+
+/* called through TINYDRM_DEBUG_REG_WRITE() */
+void tinydrm_debug_reg_write(const void *reg, size_t reg_len, const void *val,
+			     size_t val_len, size_t val_width)
+{
+	unsigned int regnr;
+
+	if (reg_len != 1 && reg_len != 2)
+		return;
+
+	regnr = (reg_len == 1) ? *(u8 *)reg : *(u16 *)reg;
+
+	if (val && val_len) {
+		char linebuf[3 * 32];
+
+		tinydrm_hexdump(linebuf, ARRAY_SIZE(linebuf), val, val_len,
+				val_width, 16);
+		drm_printk(KERN_DEBUG, DRM_UT_CORE,
+			   "regnr=0x%0*x, data(%zu)= %s%s\n",
+			   reg_len == 1 ? 2 : 4, regnr,
+			   val_len, linebuf, val_len > 32 ? " ..." : "");
+	} else {
+		drm_printk(KERN_DEBUG, DRM_UT_CORE,
+			   "regnr=0x%0*x\n",
+			   reg_len == 1 ? 2 : 4, regnr);
+	}
+}
+EXPORT_SYMBOL(tinydrm_debug_reg_write);
+
+/* called through tinydrm_dbg_spi_message() */
+void _tinydrm_dbg_spi_message(struct spi_device *spi, struct spi_message *m)
+{
+	struct spi_master *master = spi->master;
+	struct spi_transfer *tmp;
+	struct list_head *pos;
+	char linebuf[3 * 32];
+	int i = 0;
+
+	list_for_each(pos, &m->transfers) {
+		tmp = list_entry(pos, struct spi_transfer, transfer_list);
+
+		if (tmp->tx_buf) {
+			bool dma = false;
+
+			if (master->can_dma)
+				dma = master->can_dma(master, spi, tmp);
+
+			tinydrm_hexdump(linebuf, ARRAY_SIZE(linebuf),
+					tmp->tx_buf, tmp->len,
+					tmp->bits_per_word, 16);
+			printk(KERN_DEBUG "    tr[%i]: bpw=%i, dma=%u, len=%u, tx_buf(%p)=[%s%s]\n",
+			       i, tmp->bits_per_word, dma, tmp->len,
+			       tmp->tx_buf, linebuf,
+			       tmp->len > 16 ? " ..." : "");
+		}
+		if (tmp->rx_buf) {
+			tinydrm_hexdump(linebuf, ARRAY_SIZE(linebuf),
+					tmp->rx_buf, tmp->len,
+					tmp->bits_per_word, 16);
+			printk(KERN_DEBUG "    tr[%i]: bpw=%i,        len=%u, rx_buf(%p)=[%s%s]\n",
+			       i, tmp->bits_per_word, tmp->len, tmp->rx_buf,
+			       linebuf, tmp->len > 16 ? " ..." : "");
+		}
+		i++;
+	}
+}
+EXPORT_SYMBOL(_tinydrm_dbg_spi_message);
+
+/**
+ * tinydrm_spi_transfer - SPI transfer helper
+ * @spi: SPI device
+ * @speed_hz: Override speed (optional)
+ * @header: Optional header transfer
+ * @bpw: Bits per word
+ * @buf: Buffer to transfer
+ * @len: Buffer length
+ * @swap_buf: Swap buffer used on Little Endian when 16 bpw is not supported
+ * @max_chunk: Break up buffer into chunks of this size (optional)
+ *
+ * This SPI transfer helper breaks up the transfer of @buf into @max_chunk
+ * chunks. If the machine is Little Endian and the SPI master driver doesn't
+ * support @bpw=16, it swaps the bytes using @swap_buf and does a 8-bit
+ * transfer. If @header is set, it is prepended to each SPI message.
+ *
+ * Returns:
+ * Zero on success, negative error code on failure.
+ */
+int tinydrm_spi_transfer(struct spi_device *spi, u32 speed_hz,
+			 struct spi_transfer *header, u8 bpw, const void *buf,
+			 size_t len, u16 *swap_buf, size_t max_chunk)
+{
+	struct spi_transfer tr = {
+		.bits_per_word = bpw,
+		.speed_hz = speed_hz,
+	};
+	struct spi_message m;
+	bool swap = false;
+	size_t chunk;
+	int ret = 0;
+
+	if (WARN_ON_ONCE(bpw != 8 && bpw != 16))
+		return -EINVAL;
+
+	max_chunk = tinydrm_spi_max_transfer_size(spi, max_chunk);
+
+	if (drm_debug & DRM_UT_CORE)
+		pr_debug("[drm:%s] bpw=%u, max_chunk=%zu, transfers:\n",
+			 __func__, bpw, max_chunk);
+
+	if (tinydrm_get_machine_endian() == REGMAP_ENDIAN_LITTLE &&
+	    bpw == 16 && !tinydrm_spi_bpw_supported(spi, 16)) {
+		if (!swap_buf)
+			return -EINVAL;
+
+		swap = true;
+		tr.bits_per_word = 8;
+	}
+
+	spi_message_init(&m);
+	if (header)
+		spi_message_add_tail(header, &m);
+	spi_message_add_tail(&tr, &m);
+
+	while (len) {
+		chunk = min(len, max_chunk);
+
+		tr.tx_buf = buf;
+		tr.len = chunk;
+
+		if (swap) {
+			const u16 *buf16 = buf;
+			unsigned int i;
+
+			for (i = 0; i < chunk / 2; i++)
+				swap_buf[i] = swab16(buf16[i]);
+
+			tr.tx_buf = swap_buf;
+		}
+
+		buf += chunk;
+		len -= chunk;
+
+		tinydrm_dbg_spi_message(spi, &m);
+		ret = spi_sync(spi, &m);
+		if (ret)
+			return ret;
+	};
+
+	return 0;
+}
+EXPORT_SYMBOL(tinydrm_spi_transfer);
+
+#endif /* CONFIG_SPI */
diff --git a/drivers/gpu/drm/tinydrm/mi0283qt.c b/drivers/gpu/drm/tinydrm/mi0283qt.c
new file mode 100644
index 000000000000..5bc8db099507
--- /dev/null
+++ b/drivers/gpu/drm/tinydrm/mi0283qt.c
@@ -0,0 +1,307 @@
+#define DEBUG
+
+/*
+ * DRM driver for Multi-Inno MI0283QT panels
+ *
+ * Copyright 2016 Noralf Tr√∏nnes
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+/* TODO: DT binding
+
+of: Add vendor prefix for Multi-Inno
+Multi-Inno Technology Co.,Ltd is a Hong Kong based company offering
+LCD, LCD module products and complete panel solutions.
+
+Documentation/devicetree/bindings/vendor-prefixes.txt
+-------------------------------------------------------------------------------
+multi-inno	Multi-Inno Technology Co.,Ltd
+-------------------------------------------------------------------------------
+
+dt-bindings: Add Multi-Inno MI0283QT binding
+Add device-tree binding documentation for the MI0283QT display panel.
+
+Documentation/devicetree/bindings/display/multi-inno,mi0283qt.txt
+-------------------------------------------------------------------------------
+Multi-Inno MI0283QT display panel
+
+Required properties:
+- compatible:	"multi-inno,mi0283qt".
+
+The node for this driver must be a child node of a SPI controller, hence
+all mandatory properties described in ../spi/spi-bus.txt must be specified.
+
+Optional properties:
+- dc-gpios:	D/C pin. The presence/absence of this GPIO determines
+		the panel interface mode (IM[3:0] pins):
+		- present: IM=x110 4-wire 8-bit data serial interface
+		- absent:  IM=x101 3-wire 9-bit data serial interface
+- reset-gpios:	Reset pin
+- power-supply:	A regulator node for the supply voltage.
+- backlight:	phandle of the backlight device attached to the panel
+- rotation:	panel rotation in degrees counter clockwise (0,90,180,270)
+- write-only:	LCD controller is write only. This depends on the interface
+		mode, SPI master driver and wiring:
+		- IM=11xx and MISO not connected
+		- IM=01xx and SPI master driver doesn't support spi-3wire (SDA)
+
+Example:
+	mi0283qt@0{
+		compatible = "multi-inno,mi0283qt";
+		reg = <0>;
+		spi-max-frequency = <32000000>;
+		rotation = <90>;
+		dc-gpios = <&gpio 25 0>;
+		backlight = <&backlight>;
+	};
+-------------------------------------------------------------------------------
+*/
+
+#include <drm/tinydrm/ili9341.h>
+#include <drm/tinydrm/mipi-dbi.h>
+#include <drm/tinydrm/tinydrm.h>
+#include <drm/tinydrm/tinydrm-helpers.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/property.h>
+#include <linux/regulator/consumer.h>
+#include <linux/spi/spi.h>
+#include <video/mipi_display.h>
+
+static void mi0283qt_enable(struct drm_simple_display_pipe *pipe,
+			    struct drm_crtc_state *crtc_state)
+{
+	struct tinydrm_device *tdev = pipe_to_tinydrm(pipe);
+	struct mipi_dbi *mipi = mipi_dbi_from_tinydrm(tdev);
+	struct device *dev = tdev->drm.dev;
+	struct regmap *reg = mipi->reg;
+	u8 addr_mode;
+	int ret;
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	mutex_lock(&tdev->dev_lock);
+
+	if (tdev->prepared)
+		goto out_unlock;
+
+	if (mipi->regulator) {
+		ret = regulator_enable(mipi->regulator);
+		if (ret) {
+			dev_err(dev, "Failed to enable regulator %d\n", ret);
+			goto out_unlock;
+		}
+	}
+
+	/* Avoid flicker by skipping setup if the bootloader has done it */
+	if (mipi_dbi_display_is_on(reg)) {
+		tdev->prepared = true;
+		goto out_unlock;
+	}
+
+	mipi_dbi_hw_reset(mipi);
+	ret = mipi_dbi_write(reg, MIPI_DCS_SOFT_RESET);
+	if (ret) {
+		dev_err(dev, "Error writing command %d\n", ret);
+		goto out_unlock;
+	}
+
+	msleep(20);
+
+	mipi_dbi_write(reg, MIPI_DCS_SET_DISPLAY_OFF);
+
+	mipi_dbi_write(reg, ILI9341_PWCTRLB, 0x00, 0x83, 0x30);
+	mipi_dbi_write(reg, ILI9341_PWRSEQ, 0x64, 0x03, 0x12, 0x81);
+	mipi_dbi_write(reg, ILI9341_DTCTRLA, 0x85, 0x01, 0x79);
+	mipi_dbi_write(reg, ILI9341_PWCTRLA, 0x39, 0x2c, 0x00, 0x34, 0x02);
+	mipi_dbi_write(reg, ILI9341_PUMPCTRL, 0x20);
+	mipi_dbi_write(reg, ILI9341_DTCTRLB, 0x00, 0x00);
+
+	/* Power Control */
+	mipi_dbi_write(reg, ILI9341_PWCTRL1, 0x26);
+	mipi_dbi_write(reg, ILI9341_PWCTRL2, 0x11);
+	/* VCOM */
+	mipi_dbi_write(reg, ILI9341_VMCTRL1, 0x35, 0x3e);
+	mipi_dbi_write(reg, ILI9341_VMCTRL2, 0xbe);
+
+	/* Memory Access Control */
+	mipi_dbi_write(reg, MIPI_DCS_SET_PIXEL_FORMAT, 0x55);
+
+	switch (mipi->rotation) {
+	default:
+		addr_mode = ILI9341_MADCTL_MV | ILI9341_MADCTL_MY |
+			    ILI9341_MADCTL_MX;
+		break;
+	case 90:
+		addr_mode = ILI9341_MADCTL_MY;
+		break;
+	case 180:
+		addr_mode = ILI9341_MADCTL_MV;
+		break;
+	case 270:
+		addr_mode = ILI9341_MADCTL_MX;
+		break;
+	}
+	addr_mode |= ILI9341_MADCTL_BGR;
+	mipi_dbi_write(reg, MIPI_DCS_SET_ADDRESS_MODE, addr_mode);
+
+	/* Frame Rate */
+	mipi_dbi_write(reg, ILI9341_FRMCTR1, 0x00, 0x1b);
+
+	/* Gamma */
+	mipi_dbi_write(reg, ILI9341_EN3GAM, 0x08);
+	mipi_dbi_write(reg, MIPI_DCS_SET_GAMMA_CURVE, 0x01);
+	mipi_dbi_write(reg, ILI9341_PGAMCTRL,
+		       0x1f, 0x1a, 0x18, 0x0a, 0x0f, 0x06, 0x45, 0x87,
+		       0x32, 0x0a, 0x07, 0x02, 0x07, 0x05, 0x00);
+	mipi_dbi_write(reg, ILI9341_NGAMCTRL,
+		       0x00, 0x25, 0x27, 0x05, 0x10, 0x09, 0x3a, 0x78,
+		       0x4d, 0x05, 0x18, 0x0d, 0x38, 0x3a, 0x1f);
+
+	/* DDRAM */
+	mipi_dbi_write(reg, ILI9341_ETMOD, 0x07);
+
+	/* Display */
+	mipi_dbi_write(reg, ILI9341_DISCTRL, 0x0a, 0x82, 0x27, 0x00);
+	mipi_dbi_write(reg, MIPI_DCS_EXIT_SLEEP_MODE);
+	msleep(100);
+
+	mipi_dbi_write(reg, MIPI_DCS_SET_DISPLAY_ON);
+	msleep(100);
+
+	tdev->prepared = true;
+	if (pipe->plane.state->fb)
+		schedule_work(&tdev->dirty_work);
+
+out_unlock:
+	mutex_unlock(&tdev->dev_lock);
+}
+
+static const struct drm_simple_display_pipe_funcs mi0283qt_pipe_funcs = {
+	.enable = mi0283qt_enable,
+	.disable = mipi_dbi_pipe_disable,
+	.update = tinydrm_display_pipe_update,
+};
+
+static const struct drm_display_mode mi0283qt_mode = {
+	TINYDRM_MODE(320, 240, 58, 43),
+};
+
+static const struct of_device_id mi0283qt_of_match[] = {
+	{ .compatible = "multi-inno,mi0283qt" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, mi0283qt_of_match);
+
+static const struct spi_device_id mi0283qt_id[] = {
+	{ "mi0283qt", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(spi, mi0283qt_id);
+
+static struct drm_driver mi0283qt_driver = {
+	.driver_features	= DRIVER_GEM | DRIVER_MODESET | DRIVER_PRIME |
+				  DRIVER_ATOMIC,
+	TINYDRM_GEM_DRIVER_OPS,
+	.lastclose		= tinydrm_lastclose,
+	.debugfs_init		= mipi_dbi_debugfs_init,
+	.debugfs_cleanup	= mipi_dbi_debugfs_cleanup,
+	.name			= "mi0283qt",
+	.desc			= "Multi-Inno MI0283QT",
+	.date			= "20160614",
+	.major			= 1,
+	.minor			= 0,
+};
+
+static int mi0283qt_probe(struct spi_device *spi)
+{
+	struct device *dev = &spi->dev;
+	struct tinydrm_device *tdev;
+	struct mipi_dbi *mipi;
+	struct gpio_desc *dc;
+	u32 rotation = 0;
+	bool writeonly;
+	int ret;
+
+	if (!dev->coherent_dma_mask) {
+		ret = dma_coerce_mask_and_coherent(dev, DMA_BIT_MASK(32));
+		if (ret)
+			dev_warn(dev, "Failed to set dma mask %d\n", ret);
+	}
+
+	mipi = devm_kzalloc(dev, sizeof(*mipi), GFP_KERNEL);
+	if (!mipi)
+		return -ENOMEM;
+
+	mipi->reset = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(mipi->reset)) {
+		dev_err(dev, "Failed to get gpio 'reset'\n");
+		return PTR_ERR(mipi->reset);
+	}
+
+	dc = devm_gpiod_get_optional(dev, "dc", GPIOD_OUT_LOW);
+	if (IS_ERR(dc)) {
+		dev_err(dev, "Failed to get gpio 'dc'\n");
+		return PTR_ERR(dc);
+	}
+
+	mipi->regulator = devm_regulator_get_optional(dev, "power");
+	if (IS_ERR(mipi->regulator)) {
+		ret = PTR_ERR(mipi->regulator);
+		if (ret != -ENODEV)
+			return ret;
+
+		mipi->regulator = NULL;
+	}
+
+	mipi->enable_delay_ms = 50;
+	mipi->backlight = tinydrm_of_find_backlight(dev);
+	if (IS_ERR(mipi->backlight))
+		return PTR_ERR(mipi->backlight);
+
+	writeonly = device_property_read_bool(dev, "write-only");
+	device_property_read_u32(dev, "rotation", &rotation);
+
+	ret = mipi_dbi_spi_init(spi, mipi, dc, writeonly,
+				&mi0283qt_pipe_funcs, &mi0283qt_driver,
+				&mi0283qt_mode, rotation);
+	if (ret)
+		return ret;
+
+	tdev = &mipi->tinydrm;
+
+	ret = devm_tinydrm_register(tdev);
+	if (ret)
+		return ret;
+
+	spi_set_drvdata(spi, tdev);
+
+	DRM_DEBUG_DRIVER("Initialized %s:%s @%uMHz on minor %d\n",
+			 tdev->drm.driver->name, dev_name(dev),
+			 spi->max_speed_hz / 1000000,
+			 tdev->drm.primary->index);
+
+	return 0;
+}
+
+static struct spi_driver mi0283qt_spi_driver = {
+	.driver = {
+		.name = "mi0283qt",
+		.owner = THIS_MODULE,
+		.of_match_table = mi0283qt_of_match,
+		.pm = &tinydrm_simple_pm_ops,
+	},
+	.id_table = mi0283qt_id,
+	.probe = mi0283qt_probe,
+	.shutdown = tinydrm_spi_shutdown,
+};
+module_spi_driver(mi0283qt_spi_driver);
+
+MODULE_DESCRIPTION("Multi-Inno MI0283QT DRM driver");
+MODULE_AUTHOR("Noralf Tr√∏nnes");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/tinydrm/mipi-dbi.c b/drivers/gpu/drm/tinydrm/mipi-dbi.c
new file mode 100644
index 000000000000..4d0e79fe4b30
--- /dev/null
+++ b/drivers/gpu/drm/tinydrm/mipi-dbi.c
@@ -0,0 +1,1090 @@
+#define DEBUG
+#define VERBOSE_DEBUG
+/*
+ * MIPI Display Bus Interface (DBI) LCD controller support
+ *
+ * Copyright 2016 Noralf Tr√∏nnes
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_fb_cma_helper.h>
+#include <drm/tinydrm/mipi-dbi.h>
+#include <drm/tinydrm/tinydrm.h>
+#include <drm/tinydrm/tinydrm-helpers.h>
+#include <drm/tinydrm/tinydrm-regmap.h>
+#include <linux/dma-buf.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/spi/spi.h>
+#include <linux/swab.h>
+#include <video/mipi_display.h>
+
+#define MIPI_DBI_MAX_SPI_READ_SPEED 2000000 /* 2MHz */
+
+#define DCS_POWER_MODE_DISPLAY			BIT(2)
+#define DCS_POWER_MODE_DISPLAY_NORMAL_MODE	BIT(3)
+#define DCS_POWER_MODE_SLEEP_MODE		BIT(4)
+#define DCS_POWER_MODE_PARTIAL_MODE		BIT(5)
+#define DCS_POWER_MODE_IDLE_MODE		BIT(6)
+#define DCS_POWER_MODE_RESERVED_MASK		(BIT(0) | BIT(1) | BIT(7))
+
+struct mipi_dbi_spi {
+	struct spi_device *spi;
+	struct regmap *map;
+	struct gpio_desc *dc;
+	bool write_only;
+};
+
+/**
+ * DOC: overview
+ *
+ * This library provides helpers for MIPI Display Bus Interface (DBI)
+ * compatible display controllers.
+ *
+ * Many controllers are MIPI compliant and can use this library.
+ * If a controller uses registers 0x2A and 0x2B to set the area to update
+ * and uses register 0x2C to write to frame memory, it is most likely MIPI
+ * compliant.
+ *
+ * Only MIPI Type 1 displays are supported since a full frame memory is needed.
+ *
+ * There are 3 MIPI DBI implementation types:
+ *
+ * A. Motorola 6800 type parallel bus
+ *
+ * B. Intel 8080 type parallel bus
+ *
+ * C. SPI type with 3 options:
+ *
+ *    1. 9-bit with the Data/Command signal as the ninth bit
+ *    2. Same as above except it's sent as 16 bits
+ *    3. 8-bit with the Data/Command signal as a separate D/CX pin
+ *
+ * Currently mipi_dbi only supports Type C options 1 and 3 with
+ * mipi_dbi_spi_init().
+ */
+
+/**
+ * mipi_dbi_write_buf - Write command and parameter array
+ * @reg: Controller register
+ * @cmd: Command
+ * @parameters: Array of parameters (optional)
+ * @num: Number of parameters
+ */
+int mipi_dbi_write_buf(struct regmap *reg, unsigned int cmd,
+		       const u8 *parameters, size_t num)
+{
+	u8 *buf;
+	int ret;
+
+	if (parameters && num) {
+		buf = kmemdup(parameters, num, GFP_KERNEL);
+	} else {
+		buf = kmalloc(1, GFP_KERNEL);
+		num = 0;
+	}
+
+	if (!buf)
+		return -ENOMEM;
+
+	ret = regmap_raw_write(reg, cmd, buf, num);
+	kfree(buf);
+
+	return ret;
+}
+EXPORT_SYMBOL(mipi_dbi_write_buf);
+
+static size_t mipi_dbi_spi_clamp_size(struct spi_device *spi, size_t size)
+{
+	size_t max_spi, clamped;
+
+	max_spi = min(spi_max_transfer_size(spi), spi->master->max_dma_len);
+	if (!size)
+		size = max_spi;
+	clamped = clamp_val(size, 4, max_spi);
+	clamped &= ~0x3;
+
+	return clamped;
+}
+
+/*
+ * MIPI DBI Type C Option 1
+ *
+ * If the SPI controller doesn't have 9 bits per word support,
+ * use blocks of 9 bytes to send 8x 9-bit words with a 8-bit SPI transfer.
+ * Pad partial blocks with MIPI_DCS_NOP (zero).
+ */
+
+#define SHIFT_U9_INTO_U64(_dst, _src, _pos) \
+{ \
+	(_dst) |= 1ULL << (63 - ((_pos) * 9)); \
+	(_dst) |= (u64)(_src) << (63 - 8 - ((_pos) * 9)); \
+}
+
+static int mipi_dbi_spi1e_transfer(struct mipi_dbi_spi *mspi, int dc,
+				   const void *buf, size_t len,
+				   size_t max_chunk)
+{
+	struct spi_device *spi = mspi->spi;
+	struct spi_transfer tr = {
+		.bits_per_word = 8,
+	};
+	struct spi_message m;
+	size_t max_src_chunk, chunk;
+	int i, ret = 0;
+	u8 *dst;
+	void *buf_dc;
+	const u8 *src = buf;
+
+	max_chunk = mipi_dbi_spi_clamp_size(spi, max_chunk);
+	if (max_chunk < 9)
+		return -EINVAL;
+
+	if (drm_debug & DRM_UT_CORE)
+		pr_debug("[drm:%s] dc=%d, max_chunk=%zu, transfers:\n",
+			 __func__, dc, max_chunk);
+
+	spi_message_init_with_transfers(&m, &tr, 1);
+
+	if (!dc) {
+		/* pad at beginning of block */
+		if (WARN_ON_ONCE(len != 1))
+			return -EINVAL;
+
+		dst = kzalloc(9, GFP_KERNEL);
+		if (!dst)
+			return -ENOMEM;
+
+		dst[8] = *src;
+		tr.tx_buf = dst;
+		tr.len = 9;
+
+		tinydrm_dbg_spi_message(spi, &m);
+		ret = spi_sync(spi, &m);
+		kfree(dst);
+
+		return ret;
+	}
+
+	/* 8-byte aligned max_src_chunk that fits max_chunk */
+	max_src_chunk = max_chunk / 9 * 8;
+	max_src_chunk = min(max_src_chunk, len);
+	max_src_chunk = max_t(size_t, 8, max_src_chunk & ~0x7);
+
+	max_chunk = max_src_chunk + (max_src_chunk / 8);
+	buf_dc = kmalloc(max_chunk, GFP_KERNEL);
+	if (!buf_dc)
+		return -ENOMEM;
+
+	tr.tx_buf = buf_dc;
+
+	while (len) {
+		size_t added = 0;
+
+		chunk = min(len, max_src_chunk);
+		len -= chunk;
+		dst = buf_dc;
+
+		if (chunk < 8) {
+			/* pad at end of block */
+			u64 tmp = 0;
+			int j;
+
+			for (j = 0; j < chunk; j++)
+				SHIFT_U9_INTO_U64(tmp, *src++, j);
+
+			*(u64 *)dst = cpu_to_be64(tmp);
+			dst[8] = 0x00;
+			chunk = 8;
+			added = 1;
+		} else {
+			for (i = 0; i < chunk; i += 8) {
+				u64 tmp = 0;
+
+				SHIFT_U9_INTO_U64(tmp, *src++, 0);
+				SHIFT_U9_INTO_U64(tmp, *src++, 1);
+				SHIFT_U9_INTO_U64(tmp, *src++, 2);
+				SHIFT_U9_INTO_U64(tmp, *src++, 3);
+				SHIFT_U9_INTO_U64(tmp, *src++, 4);
+				SHIFT_U9_INTO_U64(tmp, *src++, 5);
+				SHIFT_U9_INTO_U64(tmp, *src++, 6);
+
+				tmp |= 0x1;
+				/* TODO: unaligned access here? */
+				*(u64 *)dst = cpu_to_be64(tmp);
+				dst += 8;
+				*dst++ = *src++;
+				added++;
+			}
+		}
+
+		tr.len = chunk + added;
+
+		tinydrm_dbg_spi_message(spi, &m);
+		ret = spi_sync(spi, &m);
+		if (ret)
+			goto err_free;
+	};
+
+err_free:
+	kfree(buf_dc);
+
+	return ret;
+}
+
+static int mipi_dbi_spi1_transfer(struct mipi_dbi_spi *mspi, int dc,
+				  const void *buf, size_t len,
+				  size_t max_chunk)
+{
+	struct spi_device *spi = mspi->spi;
+	struct spi_transfer tr = {
+		.bits_per_word = 9,
+	};
+	const u8 *src8 = buf;
+	struct spi_message m;
+	size_t max_src_chunk;
+	int ret = 0;
+	u16 *dst16;
+
+	if (!tinydrm_spi_bpw_supported(spi, 9))
+		return mipi_dbi_spi1e_transfer(mspi, dc, buf, len, max_chunk);
+
+	max_chunk = mipi_dbi_spi_clamp_size(spi, max_chunk);
+
+	if (drm_debug & DRM_UT_CORE)
+		pr_debug("[drm:%s] dc=%d, max_chunk=%zu, transfers:\n",
+			 __func__, dc, max_chunk);
+
+	max_src_chunk = min(max_chunk / 2, len);
+
+	dst16 = kmalloc(max_src_chunk * 2, GFP_KERNEL);
+	if (!dst16)
+		return -ENOMEM;
+
+	spi_message_init_with_transfers(&m, &tr, 1);
+	tr.tx_buf = dst16;
+
+	while (len) {
+		size_t chunk = min(len, max_src_chunk);
+		unsigned int i;
+
+		for (i = 0; i < chunk; i++) {
+			dst16[i] = *src8++;
+			if (dc)
+				dst16[i] |= 0x0100;
+		}
+
+		tr.len = chunk;
+		len -= chunk;
+
+		tinydrm_dbg_spi_message(spi, &m);
+		ret = spi_sync(spi, &m);
+		if (ret)
+			goto err_free;
+	};
+
+err_free:
+	kfree(dst16);
+
+	return ret;
+}
+
+static int mipi_dbi_spi1_gather_write(void *context, const void *reg,
+				      size_t reg_len, const void *val,
+				      size_t val_len)
+{
+	struct mipi_dbi_spi *mspi = context;
+	int ret;
+
+	if (reg_len != 1)
+		return -EINVAL;
+
+	TINYDRM_DEBUG_REG_WRITE(reg, reg_len, val, val_len, 8);
+
+	ret = mipi_dbi_spi1_transfer(mspi, 0, reg, reg_len, 4096);
+	if (ret)
+		return ret;
+
+	if (val && val_len)
+		ret = mipi_dbi_spi1_transfer(mspi, 1, val, val_len, 4096);
+
+	return ret;
+}
+
+static int mipi_dbi_spi1_write(void *context, const void *data, size_t count)
+{
+	return mipi_dbi_spi1_gather_write(context, data, 1,
+					  data + 1, count - 1);
+}
+
+static int mipi_dbi_spi1_read(void *context, const void *reg, size_t reg_size,
+			      void *val, size_t val_size)
+{
+	return -ENOTSUPP;
+}
+
+static const struct regmap_bus mipi_dbi_regmap_bus1 = {
+	.write = mipi_dbi_spi1_write,
+	.gather_write = mipi_dbi_spi1_gather_write,
+	.read = mipi_dbi_spi1_read,
+	.reg_format_endian_default = REGMAP_ENDIAN_DEFAULT,
+	.val_format_endian_default = REGMAP_ENDIAN_DEFAULT,
+};
+
+/* MIPI DBI Type C Option 3 */
+
+static int mipi_dbi_spi3_gather_write(void *context, const void *reg,
+				      size_t reg_len, const void *val,
+				      size_t val_len)
+{
+	struct mipi_dbi_spi *mspi = context;
+	struct spi_device *spi = mspi->spi;
+	int ret;
+
+	if (reg_len != 1)
+		return -EINVAL;
+
+	TINYDRM_DEBUG_REG_WRITE(reg, reg_len, val, val_len, 8);
+
+	gpiod_set_value_cansleep(mspi->dc, 0);
+	ret = tinydrm_spi_transfer(spi, 0, NULL, 8, reg, 1, NULL, 0);
+	if (ret)
+		return ret;
+
+	if (val && val_len) {
+		gpiod_set_value_cansleep(mspi->dc, 1);
+		ret = tinydrm_spi_transfer(spi, 0, NULL, 8, val,
+					   val_len, NULL, 0);
+	}
+
+	return ret;
+}
+
+static int mipi_dbi_spi3_write(void *context, const void *data, size_t count)
+{
+	return mipi_dbi_spi3_gather_write(context, data, 1,
+					  data + 1, count - 1);
+}
+
+static int mipi_dbi_spi3_read(void *context, const void *reg, size_t reg_len,
+			      void *val, size_t val_len)
+{
+	struct mipi_dbi_spi *mspi = context;
+	struct spi_device *spi = mspi->spi;
+	u32 speed_hz = min_t(u32, MIPI_DBI_MAX_SPI_READ_SPEED,
+			     spi->max_speed_hz / 2);
+	struct spi_transfer tr[2] = {
+		{
+			.speed_hz = speed_hz,
+			.tx_buf = reg,
+			.len = 1,
+		}, {
+			.speed_hz = speed_hz,
+			.len = val_len,
+		},
+	};
+	struct spi_message m;
+	u8 cmd = *(u8 *)reg;
+	u8 *buf;
+	int ret;
+
+	if (mspi->write_only)
+		return -EACCES;
+
+	if (drm_debug & DRM_UT_CORE)
+		pr_debug("[drm:%s] regnr=0x%02x, len=%zu, transfers:\n",
+			 __func__, cmd, val_len);
+
+	/*
+	 * Support non-standard 24-bit and 32-bit Nokia read commands which
+	 * start with a dummy clock, so we need to read an extra byte.
+	 */
+	if (cmd == MIPI_DCS_GET_DISPLAY_ID ||
+	    cmd == MIPI_DCS_GET_DISPLAY_STATUS) {
+		if (!(val_len == 3 || val_len == 4))
+			return -EINVAL;
+
+		tr[1].len = val_len + 1;
+	}
+
+	buf = kmalloc(tr[1].len, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	tr[1].rx_buf = buf;
+	gpiod_set_value_cansleep(mspi->dc, 0);
+
+	/*
+	 * Can't use spi_write_then_read() because reading speed is slower
+	 * than writing speed and that is set on the transfer.
+	 */
+	spi_message_init_with_transfers(&m, tr, ARRAY_SIZE(tr));
+	ret = spi_sync(spi, &m);
+	tinydrm_dbg_spi_message(spi, &m);
+
+	if (tr[1].len == val_len) {
+		memcpy(val, buf, val_len);
+	} else {
+		u8 *data = val;
+		unsigned int i;
+
+		for (i = 0; i < val_len; i++)
+			data[i] = (buf[i] << 1) | !!(buf[i + 1] & BIT(7));
+	}
+	kfree(buf);
+
+	return ret;
+}
+
+/* MIPI DBI Type C Option 3 */
+static const struct regmap_bus mipi_dbi_regmap_bus3 = {
+	.write = mipi_dbi_spi3_write,
+	.gather_write = mipi_dbi_spi3_gather_write,
+	.read = mipi_dbi_spi3_read,
+	.reg_format_endian_default = REGMAP_ENDIAN_DEFAULT,
+	.val_format_endian_default = REGMAP_ENDIAN_DEFAULT,
+};
+
+/**
+ * mipi_dbi_spi_init - Initialize MIPI DBI SPI interfaced controller
+ * @spi: SPI device
+ * @dc: D/C gpio (optional)
+ * @write_only: Controller is write-only
+ * @mipi: &mipi_dbi structure to initialize
+ * @pipe_funcs: Display pipe functions
+ * @driver: DRM driver
+ * @mode: Display mode
+ * @rotation: Initial rotation in degrees Counter Clock Wise
+ *
+ * This function initializes a &mipi_dbi structure using mipi_dbi_init()
+ * and intitalizes a &regmap that can be used to send commands to
+ * the controller. mipi_dbi_write() can be used to send commands.
+ * If @dc is set, a Type C Option 3 interface is assumed, if not
+ * Type C Option 1.
+ *
+ * If the SPI master driver doesn't support the necessary bits per word,
+ * the following transformation is used:
+ *
+ * - 9-bit: reorder buffer as 9x 8-bit words, padded with no-op command.
+ * - 16-bit: if big endian send as 8-bit, if little endian swap bytes
+ *
+ * Returns:
+ * Zero on success, negative error code on failure.
+ */
+int mipi_dbi_spi_init(struct spi_device *spi, struct mipi_dbi *mipi,
+		      struct gpio_desc *dc, bool write_only,
+		      const struct drm_simple_display_pipe_funcs *pipe_funcs,
+		      struct drm_driver *driver,
+		      const struct drm_display_mode *mode,
+		      unsigned int rotation)
+{
+	struct regmap_config config = {
+		.reg_bits = 8,
+		.val_bits = 8,
+		.cache_type = REGCACHE_NONE,
+	};
+	struct device *dev = &spi->dev;
+	struct mipi_dbi_spi *mspi;
+
+	mspi = devm_kzalloc(dev, sizeof(*mspi), GFP_KERNEL);
+	if (!mspi)
+		return -ENOMEM;
+
+	mspi->write_only = write_only;
+	mspi->spi = spi;
+	mspi->dc = dc;
+
+	if (dc)
+		mspi->map = devm_regmap_init(dev, &mipi_dbi_regmap_bus3, mspi,
+					     &config);
+	else
+		mspi->map = devm_regmap_init(dev, &mipi_dbi_regmap_bus1, mspi,
+					     &config);
+	mipi->reg = mspi->map;
+
+	if (tinydrm_get_machine_endian() == REGMAP_ENDIAN_LITTLE &&
+	    !tinydrm_spi_bpw_supported(spi, 16))
+		mipi->swap_bytes = true;
+
+	return mipi_dbi_init(dev, mipi, pipe_funcs, driver, mode, rotation);
+}
+EXPORT_SYMBOL(mipi_dbi_spi_init);
+
+static int mipi_dbi_buf_copy(void *dst, struct drm_framebuffer *fb,
+				struct drm_clip_rect *clip, bool swap)
+{
+	struct drm_gem_cma_object *cma_obj = drm_fb_cma_get_gem_obj(fb, 0);
+	struct dma_buf_attachment *import_attach = cma_obj->base.import_attach;
+	struct drm_format_name_buf format_name;
+	void *src = cma_obj->vaddr;
+	int ret = 0;
+
+	if (import_attach) {
+		ret = dma_buf_begin_cpu_access(import_attach->dmabuf,
+					       DMA_FROM_DEVICE);
+		if (ret)
+			return ret;
+	}
+
+	switch (fb->format->format) {
+	case DRM_FORMAT_RGB565:
+		if (swap)
+			tinydrm_swab16(dst, src, fb, clip);
+		else
+			tinydrm_memcpy(dst, src, fb, clip);
+		break;
+	case DRM_FORMAT_XRGB8888:
+		tinydrm_xrgb8888_to_rgb565(dst, src, fb, clip, swap);
+		break;
+	default:
+		dev_err_once(fb->dev->dev, "Format is not supported: %s\n",
+			     drm_get_format_name(fb->format->format,
+						 &format_name));
+		return -EINVAL;
+	}
+
+	if (import_attach)
+		ret = dma_buf_end_cpu_access(import_attach->dmabuf,
+					     DMA_FROM_DEVICE);
+	return ret;
+}
+
+static int mipi_dbi_fb_dirty(struct drm_framebuffer *fb,
+			     struct drm_file *file_priv,
+			     unsigned int flags, unsigned int color,
+			     struct drm_clip_rect *clips,
+			     unsigned int num_clips)
+{
+	struct drm_gem_cma_object *cma_obj = drm_fb_cma_get_gem_obj(fb, 0);
+	struct tinydrm_device *tdev = drm_to_tinydrm(fb->dev);
+	struct mipi_dbi *mipi = mipi_dbi_from_tinydrm(tdev);
+	struct regmap *reg = mipi->reg;
+	bool swap = mipi->swap_bytes;
+	struct drm_clip_rect clip;
+	int ret = 0;
+	bool full;
+	void *tr;
+
+	mutex_lock(&tdev->dev_lock);
+
+	if (!tinydrm_check_dirty(fb, &clips, &num_clips))
+		goto out_unlock;
+
+	full = tinydrm_merge_clips(&clip, clips, num_clips, flags,
+				   fb->width, fb->height);
+
+	DRM_DEBUG("Flushing [FB:%d] x1=%u, x2=%u, y1=%u, y2=%u\n", fb->base.id,
+		  clip.x1, clip.x2, clip.y1, clip.y2);
+
+	if (!full || swap || fb->format->format == DRM_FORMAT_XRGB8888) {
+		tr = mipi->tx_buf;
+		ret = mipi_dbi_buf_copy(mipi->tx_buf, fb, &clip, swap);
+		if (ret)
+			goto out_unlock;
+	} else {
+		tr = cma_obj->vaddr;
+	}
+
+	mipi_dbi_write(reg, MIPI_DCS_SET_COLUMN_ADDRESS,
+		       (clip.x1 >> 8) & 0xFF, clip.x1 & 0xFF,
+		       (clip.x2 >> 8) & 0xFF, (clip.x2 - 1) & 0xFF);
+	mipi_dbi_write(reg, MIPI_DCS_SET_PAGE_ADDRESS,
+		       (clip.y1 >> 8) & 0xFF, clip.y1 & 0xFF,
+		       (clip.y2 >> 8) & 0xFF, (clip.y2 - 1) & 0xFF);
+
+	ret = regmap_raw_write(reg, MIPI_DCS_WRITE_MEMORY_START, tr,
+			       (clip.x2 - clip.x1) * (clip.y2 - clip.y1) * 2);
+	if (ret)
+		goto out_unlock;
+
+	if (!tdev->enabled) {
+		if (mipi->enable_delay_ms)
+			msleep(mipi->enable_delay_ms);
+		ret = tinydrm_enable_backlight(mipi->backlight);
+		if (ret) {
+			DRM_ERROR("Failed to enable backlight %d\n", ret);
+			goto out_unlock;
+		}
+		tdev->enabled = true;
+	}
+
+out_unlock:
+	mutex_unlock(&tdev->dev_lock);
+
+	if (ret)
+		dev_err_once(fb->dev->dev, "Failed to update display %d\n",
+			     ret);
+
+	return ret;
+}
+
+static const struct drm_framebuffer_funcs mipi_dbi_fb_funcs = {
+	.destroy	= drm_fb_cma_destroy,
+	.create_handle	= drm_fb_cma_create_handle,
+	.dirty		= mipi_dbi_fb_dirty,
+};
+
+static void mipi_dbi_blank(struct mipi_dbi *mipi)
+{
+	struct drm_device *drm = &mipi->tinydrm.drm;
+	int height = drm->mode_config.min_height;
+	int width = drm->mode_config.min_width;
+	unsigned int num_pixels = width * height;
+	struct regmap *reg = mipi->reg;
+	u16 *buf;
+
+	buf = kzalloc(num_pixels * 2, GFP_KERNEL);
+	if (!buf)
+		return;
+
+	mipi_dbi_write(reg, MIPI_DCS_SET_COLUMN_ADDRESS, 0, 0,
+		       (width >> 8) & 0xFF, (width - 1) & 0xFF);
+	mipi_dbi_write(reg, MIPI_DCS_SET_PAGE_ADDRESS, 0, 0,
+		       (height >> 8) & 0xFF, (height - 1) & 0xFF);
+	regmap_raw_write(reg, MIPI_DCS_WRITE_MEMORY_START, buf,
+			 num_pixels * 2);
+	kfree(buf);
+}
+
+/**
+ * mipi_dbi_pipe_disable - MIPI DBI pipe disable helper
+ * @pipe: Display pipe
+ *
+ * This function disables the display pipeline by disabling backlight and
+ * regulator if present.
+ * Drivers can use this as their &drm_simple_display_pipe_funcs->disable
+ * callback.
+ */
+void mipi_dbi_pipe_disable(struct drm_simple_display_pipe *pipe)
+{
+	struct tinydrm_device *tdev = pipe_to_tinydrm(pipe);
+	struct mipi_dbi *mipi = mipi_dbi_from_tinydrm(tdev);
+	struct regmap *reg = mipi->reg;
+
+	DRM_DEBUG_KMS("\n");
+
+	mutex_lock(&tdev->dev_lock);
+
+	if (tdev->enabled) {
+		if (mipi->backlight)
+			tinydrm_disable_backlight(mipi->backlight);
+		else if (!mipi->regulator)
+			mipi_dbi_blank(mipi);
+	}
+	tdev->enabled = false;
+
+	if (tdev->prepared) {
+		if (mipi->backlight) {
+			/*
+			 * This usually turns the pixels off letting backlight
+			 * shine through, so only do it if we control backlight
+			 *
+			 * TODO
+			 * Maybe just leave the display prepared. Very little
+			 * power savings in doing this. And it would speed up
+			 * re-enabling the pipeline (100-500ms).
+			 */
+			mipi_dbi_write(reg, MIPI_DCS_SET_DISPLAY_OFF);
+			mipi_dbi_write(reg, MIPI_DCS_ENTER_SLEEP_MODE);
+			tdev->prepared = false;
+		}
+
+		if (mipi->regulator) {
+			regulator_disable(mipi->regulator);
+			tdev->prepared = false;
+		}
+	}
+
+	mutex_unlock(&tdev->dev_lock);
+}
+EXPORT_SYMBOL(mipi_dbi_pipe_disable);
+
+static const uint32_t mipi_dbi_formats[] = {
+	DRM_FORMAT_RGB565,
+	DRM_FORMAT_XRGB8888,
+};
+
+/**
+ * mipi_dbi_init - MIPI DBI initialization
+ * @dev: Parent device
+ * @mipi: &mipi_dbi structure to initialize
+ * @pipe_funcs: Display pipe functions
+ * @driver: DRM driver
+ * @mode: Display mode
+ * @rotation: Initial rotation in degrees Counter Clock Wise
+ *
+ * This function initializes a &mipi_dbi structure and it's underlying
+ * @tinydrm_device and &drm_device. It also sets up the display pipeline.
+ * Supported formats: Native RGB565 and emulated XRGB8888.
+ * Objects created by this function will be automatically freed on driver
+ * detach (devres).
+ *
+ * Returns:
+ * Zero on success, negative error code on failure.
+ */
+int mipi_dbi_init(struct device *dev, struct mipi_dbi *mipi,
+		  const struct drm_simple_display_pipe_funcs *pipe_funcs,
+		  struct drm_driver *driver,
+		  const struct drm_display_mode *mode, unsigned int rotation)
+{
+	size_t bufsize = mode->vdisplay * mode->hdisplay * sizeof(u16);
+	struct tinydrm_device *tdev = &mipi->tinydrm;
+	struct drm_device *drm = &tdev->drm;
+	int ret;
+
+	mipi->tx_buf = devm_kmalloc(dev, bufsize, GFP_KERNEL);
+	if (!mipi->tx_buf)
+		return -ENOMEM;
+
+	ret = devm_tinydrm_init(dev, tdev, &mipi_dbi_fb_funcs, driver);
+	if (ret)
+		return ret;
+
+	/* TODO: Maybe add DRM_MODE_CONNECTOR_SPI */
+	ret = tinydrm_display_pipe_init(tdev, pipe_funcs,
+					DRM_MODE_CONNECTOR_VIRTUAL,
+					mipi_dbi_formats,
+					ARRAY_SIZE(mipi_dbi_formats), mode,
+					rotation);
+	if (ret)
+		return ret;
+
+	drm->mode_config.preferred_depth = 16;
+	mipi->rotation = rotation;
+
+	drm_mode_config_reset(drm);
+
+	DRM_DEBUG_KMS("preferred_depth=%u, rotation = %u\n",
+		      drm->mode_config.preferred_depth, rotation);
+
+	return 0;
+}
+EXPORT_SYMBOL(mipi_dbi_init);
+
+/**
+ * mipi_dbi_hw_reset - Hardware reset of controller
+ * @mipi: MIPI DBI structure
+ *
+ * Reset controller if the &mipi_dbi->reset gpio is set.
+ */
+void mipi_dbi_hw_reset(struct mipi_dbi *mipi)
+{
+	if (!mipi->reset)
+		return;
+
+	gpiod_set_value_cansleep(mipi->reset, 0);
+	msleep(20);
+	gpiod_set_value_cansleep(mipi->reset, 1);
+	msleep(120);
+}
+EXPORT_SYMBOL(mipi_dbi_hw_reset);
+
+/**
+ * mipi_dbi_display_is_on - check if display is on
+ * @reg: LCD register
+ *
+ * This function checks the Power Mode register (if readable) to see if
+ * display output is turned on. This can be used to see if the bootloader
+ * has already turned on the display avoiding flicker when the pipeline is
+ * enabled.
+ *
+ * Returns:
+ * true if the display can be verified to be on, false otherwise.
+ */
+bool mipi_dbi_display_is_on(struct regmap *reg)
+{
+	u8 val;
+
+	if (regmap_raw_read(reg, MIPI_DCS_GET_POWER_MODE, &val, 1))
+		return false;
+
+	val &= ~DCS_POWER_MODE_RESERVED_MASK;
+
+	if (val != (DCS_POWER_MODE_DISPLAY |
+	    DCS_POWER_MODE_DISPLAY_NORMAL_MODE | DCS_POWER_MODE_SLEEP_MODE))
+		return false;
+
+	DRM_DEBUG_DRIVER("Display is ON\n");
+
+	return true;
+}
+EXPORT_SYMBOL(mipi_dbi_display_is_on);
+
+#ifdef CONFIG_DEBUG_FS
+
+static bool mipi_dbi_debugfs_readreg(struct seq_file *m, struct regmap *reg,
+				     unsigned int regnr, const char *desc,
+				     u8 *buf, size_t len)
+{
+	int ret;
+
+	ret = regmap_raw_read(reg, regnr, buf, len);
+	if (ret) {
+		seq_printf(m, "\n%s: command %02Xh failed: %d\n", desc, regnr,
+			   ret);
+		return false;
+	}
+
+	seq_printf(m, "\n%s (%02Xh=%*phN):\n", desc, regnr, len, buf);
+
+	return true;
+}
+
+static void
+seq_bit_val(struct seq_file *m, const char *desc, u32 val, u8 bit)
+{
+	bool bit_val = !!(val & BIT(bit));
+
+	seq_printf(m, "    D%u=%u: %s\n", bit, bit_val, desc);
+}
+
+static void
+seq_bit_reserved(struct seq_file *m, u32 val, u8 end, u8 start)
+{
+	int i;
+
+	for (i = end; i >= start; i--)
+		seq_bit_val(m, "Reserved", val, i);
+}
+
+static void
+seq_bit_array(struct seq_file *m, const char *desc, u32 val, u8 end, u8 start)
+{
+	u32 bits_val = (val & GENMASK(end, start)) >> start;
+	int i;
+
+	seq_printf(m, "    D[%u:%u]=%u: %s ", end, start, bits_val, desc);
+	for (i = end; i >= start; i--)
+		seq_printf(m, "%u ", !!(val & BIT(i)));
+
+	seq_putc(m, '\n');
+}
+
+static void
+seq_bit_text(struct seq_file *m, const char *desc, u32 val, u8 bit,
+	     const char *on, const char *off)
+{
+	bool bit_val = val & BIT(bit);
+
+	seq_printf(m, "    D%u=%u: %s %s\n", bit, bit_val, desc,
+		   bit_val ? on : off);
+}
+
+static inline void
+seq_bit_on_off(struct seq_file *m, const char *desc, u32 val, u8 bit)
+{
+	seq_bit_text(m, desc, val, bit, "On", "Off");
+}
+
+static char *mipi_pixel_format_str(u8 val)
+{
+	switch (val) {
+	case 0:
+		return "Reserved";
+	case 1:
+		return "3 bits/pixel";
+	case 2:
+		return "8 bits/pixel";
+	case 3:
+		return "12 bits/pixel";
+	case 4:
+		return "Reserved";
+	case 5:
+		return "16 bits/pixel";
+	case 6:
+		return "18 bits/pixel";
+	case 7:
+		return "24 bits/pixel";
+	default:
+		return "Illegal format";
+	}
+}
+
+static int mipi_dbi_debugfs_show(struct seq_file *m, void *arg)
+{
+	struct drm_info_node *node = (struct drm_info_node *)m->private;
+	struct drm_device *drm = node->minor->dev;
+	struct tinydrm_device *tdev = drm_to_tinydrm(drm);
+	struct mipi_dbi *mipi = mipi_dbi_from_tinydrm(tdev);
+	struct regmap *reg = mipi->reg;
+	u8 buf[4];
+	u8 val8;
+	int ret;
+
+	ret = regmap_raw_read(reg, MIPI_DCS_GET_POWER_MODE, buf, 1);
+	if (ret == -EACCES || ret == -ENOTSUPP) {
+		seq_puts(m, "Controller is write-only\n");
+		return 0;
+	}
+
+	/*
+	 * Read Display ID (04h) and Read Display Status (09h) are
+	 * non-standard commands that Nokia wanted back in the day,
+	 * so most vendors implemented them.
+	 */
+	if (mipi_dbi_debugfs_readreg(m, reg, MIPI_DCS_GET_DISPLAY_ID,
+				     "Display ID", buf, 3)) {
+		seq_printf(m, "    ID1 = 0x%02x\n", buf[0]);
+		seq_printf(m, "    ID2 = 0x%02x\n", buf[1]);
+		seq_printf(m, "    ID3 = 0x%02x\n", buf[2]);
+	}
+
+	if (mipi_dbi_debugfs_readreg(m, reg, MIPI_DCS_GET_DISPLAY_STATUS,
+				     "Display status", buf, 4)) {
+		u32 stat;
+
+		stat = (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];
+
+		seq_bit_on_off(m, "Booster voltage status:", stat, 31);
+		seq_bit_val(m, "Row address order", stat, 30);
+		seq_bit_val(m, "Column address order", stat, 29);
+		seq_bit_val(m, "Row/column exchange", stat, 28);
+		seq_bit_text(m, "Vertical refresh:", stat, 27,
+			     "Bottom to Top", "Top to Bottom");
+		seq_bit_text(m, "RGB/BGR order:", stat, 26, "BGR", "RGB");
+		seq_bit_text(m, "Horizontal refresh order:", stat, 25,
+			     "Right to Left", "Left to Right");
+		seq_bit_reserved(m, stat, 24, 23);
+		seq_bit_array(m, "Interface color pixel format:", stat, 22, 20);
+		seq_bit_on_off(m, "Idle mode:", stat, 19);
+		seq_bit_on_off(m, "Partial mode:", stat, 18);
+		seq_bit_text(m, "Sleep:", stat, 17, "Out", "In");
+		seq_bit_on_off(m, "Display normal mode:", stat, 16);
+		seq_bit_on_off(m, "Vertical scrolling status:", stat, 15);
+		seq_bit_reserved(m, stat, 14, 14);
+		seq_bit_val(m, "Inversion status", stat, 13);
+		seq_bit_val(m, "All pixel ON", stat, 12);
+		seq_bit_val(m, "All pixel OFF", stat, 11);
+		seq_bit_on_off(m, "Display:", stat, 10);
+		seq_bit_on_off(m, "Tearing effect line:", stat, 9);
+		seq_bit_array(m, "Gamma curve selection:", stat, 8, 6);
+		seq_bit_text(m, "Tearing effect line mode:", stat, 5,
+			     "Mode 2, both H-Blanking and V-Blanking",
+			     "Mode 1, V-Blanking only");
+		seq_bit_reserved(m, stat, 4, 0);
+	}
+
+	if (mipi_dbi_debugfs_readreg(m, reg, MIPI_DCS_GET_POWER_MODE,
+				     "Power mode", &val8, 1)) {
+		seq_bit_text(m, "Booster", val8, 7, "On", "Off or faulty");
+		seq_bit_on_off(m, "Idle Mode", val8, 6);
+		seq_bit_on_off(m, "Partial Mode", val8, 5);
+		seq_bit_text(m, "Sleep", val8, 4, "Out Mode", "In Mode");
+		seq_bit_on_off(m, "Display Normal Mode", val8, 3);
+		seq_bit_on_off(m, "Display is", val8, 2);
+		seq_bit_reserved(m, val8, 1, 0);
+	}
+
+	if (mipi_dbi_debugfs_readreg(m, reg, MIPI_DCS_GET_ADDRESS_MODE,
+				     "Address mode", &val8, 1)) {
+		seq_bit_text(m, "Page Address Order:", val8, 7,
+			     "Bottom to Top", "Top to Bottom");
+		seq_bit_text(m, "Column Address Order:", val8, 6,
+			     "Right to Left", "Left to Right");
+		seq_bit_text(m, "Page/Column Order:", val8, 5,
+			     "Reverse Mode", "Normal Mode");
+		seq_bit_text(m, "Line Address Order: LCD Refresh", val8, 4,
+			     "Bottom to Top", "Top to Bottom");
+		seq_bit_text(m, "RGB/BGR Order:", val8, 3, "BGR", "RGB");
+		seq_bit_text(m, "Display Data Latch Data Order: LCD Refresh",
+			     val8, 2, "Right to Left", "Left to Right");
+		seq_bit_reserved(m, val8, 1, 0);
+	}
+
+	if (mipi_dbi_debugfs_readreg(m, reg, MIPI_DCS_GET_PIXEL_FORMAT,
+				     "Pixel format", &val8, 1)) {
+		u8 dpi = (val8 >> 4) & 0x7;
+		u8 dbi = val8 & 0x7;
+
+		seq_bit_reserved(m, val8, 7, 7);
+		seq_printf(m, "    D[6:4]=%u: DPI: %s\n", dpi,
+			   mipi_pixel_format_str(dpi));
+		seq_bit_reserved(m, val8, 3, 3);
+		seq_printf(m, "    D[2:0]=%u: DBI: %s\n", dbi,
+			   mipi_pixel_format_str(dbi));
+	}
+
+	if (mipi_dbi_debugfs_readreg(m, reg, MIPI_DCS_GET_DISPLAY_MODE,
+				     "Image Mode", &val8, 1)) {
+		u8 gc = val8 & 0x7;
+
+		seq_bit_on_off(m, "Vertical Scrolling Status:", val8, 7);
+		seq_bit_reserved(m, val8, 6, 6);
+		seq_bit_on_off(m, "Inversion:", val8, 5);
+		seq_bit_reserved(m, val8, 4, 3);
+		seq_printf(m, "    D[2:0]=%u: Gamma Curve Selection: ", gc);
+		if (gc < 4)
+			seq_printf(m, "GC%u\n", gc);
+		else
+			seq_puts(m, "Reserved\n");
+	}
+
+	if (mipi_dbi_debugfs_readreg(m, reg, MIPI_DCS_GET_SIGNAL_MODE,
+				     "Signal Mode", &val8, 1)) {
+		seq_bit_on_off(m, "Tearing Effect Line:", val8, 7);
+		seq_bit_text(m, "Tearing Effect Line Output Mode: Mode",
+			     val8, 6, "2", "1");
+		seq_bit_reserved(m, val8, 5, 0);
+	}
+
+	if (mipi_dbi_debugfs_readreg(m, reg, MIPI_DCS_GET_DIAGNOSTIC_RESULT,
+				     "Diagnostic result", &val8, 1)) {
+		seq_bit_text(m, "Register Loading Detection:", val8, 7,
+			     "OK", "Fault or reset");
+		seq_bit_text(m, "Functionality Detection:", val8, 6,
+			     "OK", "Fault or reset");
+		seq_bit_text(m, "Chip Attachment Detection:", val8, 5,
+			     "Fault", "OK or unimplemented");
+		seq_bit_text(m, "Display Glass Break Detection:", val8, 4,
+			     "Fault", "OK or unimplemented");
+		seq_bit_reserved(m, val8, 3, 0);
+	}
+
+	return 0;
+}
+
+static const struct drm_info_list mipi_dbi_debugfs_list[] = {
+	{ "fb",   drm_fb_cma_debugfs_show, 0 },
+	{ "mipi",   mipi_dbi_debugfs_show, 0 },
+};
+
+/**
+ * mipi_dbi_debugfs_init - Create debugfs entries
+ * @minor: DRM minor
+ *
+ * Drivers can use this as their &drm_driver->debugfs_init callback.
+ *
+ * Returns:
+ * Zero on success, negative error code on failure.
+ */
+int mipi_dbi_debugfs_init(struct drm_minor *minor)
+{
+	return drm_debugfs_create_files(mipi_dbi_debugfs_list,
+					ARRAY_SIZE(mipi_dbi_debugfs_list),
+					minor->debugfs_root, minor);
+}
+EXPORT_SYMBOL(mipi_dbi_debugfs_init);
+
+/**
+ * mipi_dbi_debugfs_cleanup - Cleanup debugfs entries
+ * @minor: DRM minor
+ *
+ * Drivers can use this as their &drm_driver->debugfs_cleanup callback.
+ */
+void mipi_dbi_debugfs_cleanup(struct drm_minor *minor)
+{
+	drm_debugfs_remove_files(mipi_dbi_debugfs_list,
+				 ARRAY_SIZE(mipi_dbi_debugfs_list), minor);
+}
+EXPORT_SYMBOL(mipi_dbi_debugfs_cleanup);
+
+#endif
+
+MODULE_LICENSE("GPL");
diff --git a/include/drm/tinydrm/hx8340.h b/include/drm/tinydrm/hx8340.h
new file mode 100644
index 000000000000..4fc975f698a3
--- /dev/null
+++ b/include/drm/tinydrm/hx8340.h
@@ -0,0 +1,46 @@
+/*
+ * HX8340 LCD controller
+ *
+ * Copyright 2016 Noralf Tr√∏nnes
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __LINUX_HX8340_H
+#define __LINUX_HX8340_H
+
+#define HX8340_SETOSC      0xB0
+#define HX8340_SETPWCTR1   0xB1
+#define HX8340_SETPWCTR2   0xB2
+#define HX8340_SETPWCTR3   0xB3
+#define HX8340_SETPWCTR4   0xB4
+#define HX8340_SETPWCTR5   0xB5
+#define HX8340_SETDISCTRL  0xB6
+#define HX8340_SETFRMCTRL  0xB7
+#define HX8340_SETDISCYCC  0xB8
+#define HX8340_SETINVCTRL  0xB9
+#define HX8340_RGBBPCTR    0xBA
+#define HX8340_SETRGBIF    0xBB
+#define HX8340_SETDODC     0xBC
+#define HX8340_SETINTMODE  0xBD
+#define HX8340_SETPANEL    0xBE
+
+#define HX8340_SETONOFF    0xC0
+#define HX8340_SETEXTCMD   0xC1
+#define HX8340_SETGAMMAP   0xC2
+#define HX8340_SETGAMMAN   0xC3
+#define HX8340_SETOTP      0xC7
+
+#define HX8340_RDID1       0xDA
+#define HX8340_RDID2       0xDB
+#define HX8340_RDID3       0xDC
+
+#define HX8340_MADCTL_BGR  BIT(3)
+#define HX8340_MADCTL_MV   BIT(5)
+#define HX8340_MADCTL_MX   BIT(6)
+#define HX8340_MADCTL_MY   BIT(7)
+
+#endif /* __LINUX_HX8340_H */
diff --git a/include/drm/tinydrm/ili9341.h b/include/drm/tinydrm/ili9341.h
new file mode 100644
index 000000000000..807a09f43cad
--- /dev/null
+++ b/include/drm/tinydrm/ili9341.h
@@ -0,0 +1,54 @@
+/*
+ * ILI9341 LCD controller
+ *
+ * Copyright 2016 Noralf Tr√∏nnes
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __LINUX_ILI9341_H
+#define __LINUX_ILI9341_H
+
+#define ILI9341_FRMCTR1    0xb1
+#define ILI9341_FRMCTR2    0xb2
+#define ILI9341_FRMCTR3    0xb3
+#define ILI9341_INVTR      0xb4
+#define ILI9341_PRCTR      0xb5
+#define ILI9341_DISCTRL    0xb6
+#define ILI9341_ETMOD      0xb7
+
+#define ILI9341_PWCTRL1    0xc0
+#define ILI9341_PWCTRL2    0xc1
+#define ILI9341_VMCTRL1    0xc5
+#define ILI9341_VMCTRL2    0xc7
+#define ILI9341_PWCTRLA    0xcb
+#define ILI9341_PWCTRLB    0xcf
+
+#define ILI9341_RDID1      0xda
+#define ILI9341_RDID2      0xdb
+#define ILI9341_RDID3      0xdc
+#define ILI9341_RDID4      0xd3
+
+#define ILI9341_PGAMCTRL   0xe0
+#define ILI9341_NGAMCTRL   0xe1
+#define ILI9341_DGAMCTRL1  0xe2
+#define ILI9341_DGAMCTRL2  0xe3
+#define ILI9341_DTCTRLA    0xe8
+#define ILI9341_DTCTRLB    0xea
+#define ILI9341_PWRSEQ     0xed
+
+#define ILI9341_EN3GAM     0xf2
+#define ILI9341_IFCTRL     0xf6
+#define ILI9341_PUMPCTRL   0xf7
+
+#define ILI9341_MADCTL_MH  BIT(2)
+#define ILI9341_MADCTL_BGR BIT(3)
+#define ILI9341_MADCTL_ML  BIT(4)
+#define ILI9341_MADCTL_MV  BIT(5)
+#define ILI9341_MADCTL_MX  BIT(6)
+#define ILI9341_MADCTL_MY  BIT(7)
+
+#endif /* __LINUX_ILI9341_H */
diff --git a/include/drm/tinydrm/mipi-dbi.h b/include/drm/tinydrm/mipi-dbi.h
new file mode 100644
index 000000000000..bc8a0ca018f8
--- /dev/null
+++ b/include/drm/tinydrm/mipi-dbi.h
@@ -0,0 +1,90 @@
+/*
+ * MIPI Display Bus Interface (DBI) LCD controller support
+ *
+ * Copyright 2016 Noralf Tr√∏nnes
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __LINUX_MIPI_DBI_H
+#define __LINUX_MIPI_DBI_H
+
+#include <drm/tinydrm/tinydrm.h>
+
+struct drm_gem_cma_object;
+struct drm_framebuffer;
+struct drm_clip_rect;
+struct spi_device;
+struct gpio_desc;
+struct regulator;
+
+/**
+ * mipi_dbi - MIPI DBI controller
+ * @tinydrm: tinydrm base
+ * @reg: register map
+ * @tx_buf: Buffer used for transfer (copy clip rect area)
+ * @swap_bytes: Swap bytes in buffer before transfer
+ * @reset: Optional reset gpio
+ * @rotation: initial rotation in degress Counter Clock Wise
+ * @backlight: backlight device (optional)
+ * @enable_delay_ms: Optional delay in milliseconds before turning on backlight
+ * @regulator: power regulator (optional)
+ */
+struct mipi_dbi {
+	struct tinydrm_device tinydrm;
+	struct regmap *reg;
+	u16 *tx_buf;
+	bool swap_bytes;
+	struct gpio_desc *reset;
+	unsigned int rotation;
+	struct backlight_device *backlight;
+	unsigned int enable_delay_ms;
+	struct regulator *regulator;
+};
+
+static inline struct mipi_dbi *
+mipi_dbi_from_tinydrm(struct tinydrm_device *tdev)
+{
+	return container_of(tdev, struct mipi_dbi, tinydrm);
+}
+
+int mipi_dbi_spi_init(struct spi_device *spi, struct mipi_dbi *mipi,
+		      struct gpio_desc *dc, bool write_only,
+		      const struct drm_simple_display_pipe_funcs *pipe_funcs,
+		      struct drm_driver *driver,
+		      const struct drm_display_mode *mode,
+		      unsigned int rotation);
+int mipi_dbi_init(struct device *dev, struct mipi_dbi *mipi,
+		  const struct drm_simple_display_pipe_funcs *pipe_funcs,
+		  struct drm_driver *driver,
+		  const struct drm_display_mode *mode, unsigned int rotation);
+void mipi_dbi_pipe_disable(struct drm_simple_display_pipe *pipe);
+void mipi_dbi_hw_reset(struct mipi_dbi *mipi);
+bool mipi_dbi_display_is_on(struct regmap *reg);
+
+/**
+ * mipi_dbi_write - Write command and optional parameter(s)
+ * @cmd: Command
+ * @...: Parameters
+ */
+#define mipi_dbi_write(reg, cmd, seq...) \
+({ \
+	u8 d[] = { seq }; \
+	mipi_dbi_write_buf(reg, cmd, d, ARRAY_SIZE(d)); \
+})
+
+int mipi_dbi_write_buf(struct regmap *reg, unsigned int cmd,
+		       const u8 *parameters, size_t num);
+
+#ifdef CONFIG_DEBUG_FS
+int mipi_dbi_debugfs_init(struct drm_minor *minor);
+void mipi_dbi_debugfs_cleanup(struct drm_minor *minor);
+#else
+#define mipi_dbi_debugfs_init		NULL
+#define mipi_dbi_debugfs_cleanup	NULL
+#endif
+
+#endif /* __LINUX_MIPI_DBI_H */
diff --git a/include/drm/tinydrm/st7735r.h b/include/drm/tinydrm/st7735r.h
new file mode 100644
index 000000000000..f2ba5352b634
--- /dev/null
+++ b/include/drm/tinydrm/st7735r.h
@@ -0,0 +1,44 @@
+/*
+ * ST7735R LCD controller
+ *
+ * Copyright 2016 Noralf Tr√∏nnes
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __LINUX_ST7735R_H
+#define __LINUX_ST7735R_H
+
+#define ST7735R_FRMCTR1		0xB1
+#define ST7735R_FRMCTR2		0xB2
+#define ST7735R_FRMCTR3		0xB3
+#define ST7735R_INVCTR		0xB4
+
+#define ST7735R_PWCTR1		0xC0
+#define ST7735R_PWCTR2		0xC1
+#define ST7735R_PWCTR3		0xC2
+#define ST7735R_PWCTR4		0xC3
+#define ST7735R_PWCTR5		0xC4
+#define ST7735R_VMCTR1		0xC5
+#define ST7735R_VMOFCTR		0xC7
+
+#define ST7735R_WRID2		0xD1
+#define ST7735R_WRID3		0xD2
+#define ST7735R_NVCTR1		0xD9
+#define ST7735R_RDID1		0xDA
+#define ST7735R_RDID2		0xDB
+#define ST7735R_RDID3		0xDC
+#define ST7735R_NVCTR2		0xDE
+#define ST7735R_NVCTR3		0xDF
+
+#define ST7735R_GAMCTRP1	0xE0
+#define ST7735R_GAMCTRN1	0xE1
+
+#define ST7735R_MADCTL_MV	BIT(5)
+#define ST7735R_MADCTL_MX	BIT(6)
+#define ST7735R_MADCTL_MY	BIT(7)
+
+#endif /* __LINUX_ST7735R_H */
diff --git a/include/drm/tinydrm/tinydrm-helpers.h b/include/drm/tinydrm/tinydrm-helpers.h
new file mode 100644
index 000000000000..d471415c2033
--- /dev/null
+++ b/include/drm/tinydrm/tinydrm-helpers.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2016 Noralf Tr√∏nnes
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __LINUX_TINYDRM_HELPERS_H
+#define __LINUX_TINYDRM_HELPERS_H
+
+struct backlight_device;
+struct tinydrm_device;
+struct drm_clip_rect;
+struct dev_pm_ops;
+struct spi_device;
+struct device;
+
+bool tinydrm_merge_clips(struct drm_clip_rect *dst,
+			 struct drm_clip_rect *src, unsigned int num_clips,
+			 unsigned int flags, u32 max_width, u32 max_height);
+void tinydrm_memcpy(void *dst, void *vaddr, struct drm_framebuffer *fb,
+		    struct drm_clip_rect *clip);
+void tinydrm_swab16(u16 *dst, void *vaddr, struct drm_framebuffer *fb,
+		    struct drm_clip_rect *clip);
+void tinydrm_xrgb8888_to_rgb565(u16 *dst, void *vaddr,
+				struct drm_framebuffer *fb,
+				struct drm_clip_rect *clip, bool swap);
+
+#ifdef CONFIG_BACKLIGHT_CLASS_DEVICE
+struct backlight_device *tinydrm_of_find_backlight(struct device *dev);
+int tinydrm_enable_backlight(struct backlight_device *backlight);
+void tinydrm_disable_backlight(struct backlight_device *backlight);
+#else
+static inline struct backlight_device *
+tinydrm_of_find_backlight(struct device *dev)
+{
+	return NULL;
+}
+
+static inline int tinydrm_enable_backlight(struct backlight_device *backlight)
+{
+	return 0;
+}
+
+static inline void
+tinydrm_disable_backlight(struct backlight_device *backlight)
+{
+}
+#endif
+
+extern const struct dev_pm_ops tinydrm_simple_pm_ops;
+void tinydrm_spi_shutdown(struct spi_device *spi);
+
+#endif /* __LINUX_TINYDRM_HELPERS_H */
diff --git a/include/drm/tinydrm/tinydrm-regmap.h b/include/drm/tinydrm/tinydrm-regmap.h
new file mode 100644
index 000000000000..c11440e65c97
--- /dev/null
+++ b/include/drm/tinydrm/tinydrm-regmap.h
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2016 Noralf Tr√∏nnes
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __LINUX_TINYDRM_REGMAP_H
+#define __LINUX_TINYDRM_REGMAP_H
+
+#include <linux/regmap.h>
+
+struct drm_framebuffer;
+struct drm_clip_rect;
+struct spi_transfer;
+struct spi_message;
+struct spi_device;
+
+size_t tinydrm_spi_max_transfer_size(struct spi_device *spi, size_t max_len);
+bool tinydrm_spi_bpw_supported(struct spi_device *spi, u8 bpw);
+int tinydrm_spi_transfer(struct spi_device *spi, u32 speed_hz,
+			 struct spi_transfer *header, u8 bpw, const void *buf,
+			 size_t len, u16 *swap_buf, size_t max_chunk);
+void tinydrm_debug_reg_write(const void *reg, size_t reg_len, const void *val,
+			     size_t val_len, size_t val_width);
+void _tinydrm_dbg_spi_message(struct spi_device *spi, struct spi_message *m);
+
+/**
+ * tinydrm_get_machine_endian - Get machine endianness
+ *
+ * Returns:
+ * REGMAP_ENDIAN_LITTLE or REGMAP_ENDIAN_BIG
+ */
+static inline enum regmap_endian tinydrm_get_machine_endian(void)
+{
+#if defined(__LITTLE_ENDIAN)
+	return REGMAP_ENDIAN_LITTLE;
+#elif defined(__BIG_ENDIAN)
+	return REGMAP_ENDIAN_BIG;
+#else
+#  error "could not determine byte order"
+#endif
+}
+
+#if defined(DEBUG)
+/**
+ * TINYDRM_DEBUG_REG_WRITE - Print info about register write
+ * @reg: Register number buffer
+ * @reg_len: Length of @reg buffer
+ * @val: Value buffer
+ * @val_len: Length of @val buffer
+ * @val_width: Word width of @val buffer
+ *
+ * This macro prints info to the log about a register write. Can be used in
+ * &regmap_bus ->gather_write functions. It's a wrapper around
+ * tinydrm_debug_reg_write().
+ * DEBUG has to be defined for this macro to be enabled alongside setting
+ * the DRM_UT_CORE bit of drm_debug.
+ */
+#define TINYDRM_DEBUG_REG_WRITE(reg, reg_len, val, val_len, val_width) \
+	do { \
+		if (unlikely(drm_debug & DRM_UT_CORE)) \
+			tinydrm_debug_reg_write(reg, reg_len, \
+						val, val_len, val_width); \
+	} while (0)
+
+/**
+ * tinydrm_dbg_spi_message - Dump SPI message
+ * @spi: SPI device
+ * @m: SPI message
+ *
+ * Dumps info about the transfers in a SPI message including start of buffers.
+ * DEBUG has to be defined for this function to be enabled alongside setting
+ * the DRM_UT_CORE bit of drm_debug.
+ */
+static inline void tinydrm_dbg_spi_message(struct spi_device *spi,
+					   struct spi_message *m)
+{
+	if (drm_debug & DRM_UT_CORE)
+		_tinydrm_dbg_spi_message(spi, m);
+}
+#else
+#define TINYDRM_DEBUG_REG_WRITE(reg, reg_len, val, val_len, val_width) \
+	do { \
+		if (0) \
+			tinydrm_debug_reg_write(reg, reg_len, \
+						val, val_len, val_width); \
+	} while (0)
+
+static inline void tinydrm_dbg_spi_message(struct spi_device *spi,
+					   struct spi_message *m)
+{
+}
+#endif
+
+#endif /* __LINUX_TINYDRM_REGMAP_H */
diff --git a/include/drm/tinydrm/tinydrm.h b/include/drm/tinydrm/tinydrm.h
new file mode 100644
index 000000000000..4fd874a5c19c
--- /dev/null
+++ b/include/drm/tinydrm/tinydrm.h
@@ -0,0 +1,145 @@
+/*
+ * Copyright (C) 2016 Noralf Tr√∏nnes
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __LINUX_TINYDRM_H
+#define __LINUX_TINYDRM_H
+
+#include <drm/drm_crtc.h>
+#include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_simple_kms_helper.h>
+
+struct tinydrm_debugfs_dirty;
+
+/**
+ * struct tinydrm_device - tinydrm device
+ * @drm: DRM device
+ * @pipe: Display pipe structure
+ * @dirty_work: framebuffer flusher
+ * @dev_lock: serializes device access and protects
+ *            prepared/enabled state changes
+ * @prepared: device prepared state (prepared for framebuffer flushing)
+ * @enabled: device enabled state (display is on)
+ * @fbdev_cma: fbdev CMA structure
+ * @fbdev_helper: fbdev helper (from the private fbdev CMA structure).
+ * @fbdev_used: fbdev has actually been used
+ * @suspend_state: atomic state when suspended
+ * @debugfs_dirty: debugfs dirty file control structure
+ */
+struct tinydrm_device {
+	struct drm_device drm;
+	struct drm_simple_display_pipe pipe;
+	struct drm_pending_vblank_event *event;
+	struct work_struct dirty_work;
+	struct mutex dev_lock;
+	bool prepared;
+	bool enabled;
+	struct drm_fbdev_cma *fbdev_cma;
+	struct drm_atomic_state *suspend_state;
+	struct tinydrm_debugfs_dirty *debugfs_dirty;
+/* private: */
+	const struct drm_framebuffer_funcs *fb_funcs;
+};
+
+static inline struct tinydrm_device *
+drm_to_tinydrm(struct drm_device *drm)
+{
+	return container_of(drm, struct tinydrm_device, drm);
+}
+
+static inline struct tinydrm_device *
+pipe_to_tinydrm(struct drm_simple_display_pipe *pipe)
+{
+	return container_of(pipe, struct tinydrm_device, pipe);
+}
+
+/*
+ * TINYDRM_GEM_DRIVER_OPS - default tinydrm gem operations
+ *
+ * This macro provides a shortcut for setting the tinydrm GEM operations in
+ * the &drm_driver structure.
+ */
+#define TINYDRM_GEM_DRIVER_OPS \
+	.gem_free_object	= tinydrm_gem_cma_free_object, \
+	.gem_vm_ops		= &drm_gem_cma_vm_ops, \
+	.prime_handle_to_fd	= drm_gem_prime_handle_to_fd, \
+	.prime_fd_to_handle	= drm_gem_prime_fd_to_handle, \
+	.gem_prime_import	= drm_gem_prime_import, \
+	.gem_prime_export	= drm_gem_prime_export, \
+	.gem_prime_get_sg_table	= drm_gem_cma_prime_get_sg_table, \
+	.gem_prime_import_sg_table = tinydrm_gem_cma_prime_import_sg_table, \
+	.gem_prime_vmap		= drm_gem_cma_prime_vmap, \
+	.gem_prime_vunmap	= drm_gem_cma_prime_vunmap, \
+	.gem_prime_mmap		= drm_gem_cma_prime_mmap, \
+	.dumb_create		= drm_gem_cma_dumb_create, \
+	.dumb_map_offset	= drm_gem_cma_dumb_map_offset, \
+	.dumb_destroy		= drm_gem_dumb_destroy, \
+	.fops			= &tinydrm_fops
+
+/**
+ * TINYDRM_MODE - tinydrm display mode
+ * @hd: horizontal resolution, width
+ * @vd: vertical resolution, height
+ * @hd_mm: display width in millimeters
+ * @vd_mm: display height in millimeters
+ *
+ * This macro creates a &drm_display_mode for use with tinydrm.
+ */
+#define TINYDRM_MODE(hd, vd, hd_mm, vd_mm) \
+	.hdisplay = (hd), \
+	.hsync_start = (hd), \
+	.hsync_end = (hd), \
+	.htotal = (hd), \
+	.vdisplay = (vd), \
+	.vsync_start = (vd), \
+	.vsync_end = (vd), \
+	.vtotal = (vd), \
+	.width_mm = (hd_mm), \
+	.height_mm = (vd_mm), \
+	.type = DRM_MODE_TYPE_DRIVER, \
+	.clock = 1 /* pass validation */
+
+extern const struct file_operations tinydrm_fops;
+void tinydrm_lastclose(struct drm_device *drm);
+void tinydrm_gem_cma_free_object(struct drm_gem_object *gem_obj);
+struct drm_gem_object *
+tinydrm_gem_cma_prime_import_sg_table(struct drm_device *drm,
+				      struct dma_buf_attachment *attach,
+				      struct sg_table *sgt);
+struct drm_framebuffer *
+tinydrm_fb_create(struct drm_device *drm, struct drm_file *file_priv,
+		  const struct drm_mode_fb_cmd2 *mode_cmd);
+bool tinydrm_check_dirty(struct drm_framebuffer *fb,
+			 struct drm_clip_rect **clips,
+			 unsigned int *num_clips);
+struct drm_connector *
+tinydrm_connector_create(struct drm_device *drm,
+			 const struct drm_display_mode *mode,
+			 int connector_type);
+void tinydrm_display_pipe_update(struct drm_simple_display_pipe *pipe,
+				 struct drm_plane_state *old_state);
+int
+tinydrm_display_pipe_init(struct tinydrm_device *tdev,
+			  const struct drm_simple_display_pipe_funcs *funcs,
+			  int connector_type,
+			  const uint32_t *formats,
+			  unsigned int format_count,
+			  const struct drm_display_mode *mode,
+			  unsigned int rotation);
+int devm_tinydrm_init(struct device *parent, struct tinydrm_device *tdev,
+		      const struct drm_framebuffer_funcs *fb_funcs,
+		      struct drm_driver *driver);
+int devm_tinydrm_register(struct tinydrm_device *tdev);
+void tinydrm_shutdown(struct tinydrm_device *tdev);
+int tinydrm_suspend(struct tinydrm_device *tdev);
+int tinydrm_resume(struct tinydrm_device *tdev);
+
+int tinydrm_fbdev_init(struct tinydrm_device *tdev);
+void tinydrm_fbdev_fini(struct tinydrm_device *tdev);
+
+#endif /* __LINUX_TINYDRM_H */
-- 
2.11.0

