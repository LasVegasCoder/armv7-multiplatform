From 95651f8d6d4a92b96596d4e77eadda15a3845c6d Mon Sep 17 00:00:00 2001
From: Robert Nelson <robertcnelson@gmail.com>
Date: Sun, 11 Dec 2016 14:48:55 -0600
Subject: [PATCH] merge: tinydrm

Signed-off-by: Robert Nelson <robertcnelson@gmail.com>
---
 drivers/gpu/drm/Kconfig                        |    1 +
 drivers/gpu/drm/Makefile                       |    1 +
 drivers/gpu/drm/tinydrm/Kconfig                |   38 +
 drivers/gpu/drm/tinydrm/Makefile               |   11 +
 drivers/gpu/drm/tinydrm/adafruit-tft.c         |  394 +++++++++
 drivers/gpu/drm/tinydrm/core/Makefile          |    7 +
 drivers/gpu/drm/tinydrm/core/tinydrm-core.c    |  411 +++++++++
 drivers/gpu/drm/tinydrm/core/tinydrm-debugfs.c |  439 ++++++++++
 drivers/gpu/drm/tinydrm/core/tinydrm-fb.c      |  182 ++++
 drivers/gpu/drm/tinydrm/core/tinydrm-helpers.c |  222 +++++
 drivers/gpu/drm/tinydrm/core/tinydrm-pipe.c    |  247 ++++++
 drivers/gpu/drm/tinydrm/core/tinydrm-regmap.c  |  326 +++++++
 drivers/gpu/drm/tinydrm/mi0283qt.c             |  310 +++++++
 drivers/gpu/drm/tinydrm/mipi-dbi.c             | 1087 ++++++++++++++++++++++++
 drivers/gpu/drm/tinydrm/utinydrm.c             |  652 ++++++++++++++
 include/drm/tinydrm/hx8340.h                   |   46 +
 include/drm/tinydrm/ili9341.h                  |   54 ++
 include/drm/tinydrm/mipi-dbi.h                 |   82 ++
 include/drm/tinydrm/st7735r.h                  |   44 +
 include/drm/tinydrm/tinydrm-helpers.h          |   50 ++
 include/drm/tinydrm/tinydrm-regmap.h           |   99 +++
 include/drm/tinydrm/tinydrm.h                  |  177 ++++
 include/uapi/drm/utinydrm.h                    |   73 ++
 23 files changed, 4953 insertions(+)
 create mode 100644 drivers/gpu/drm/tinydrm/Kconfig
 create mode 100644 drivers/gpu/drm/tinydrm/Makefile
 create mode 100644 drivers/gpu/drm/tinydrm/adafruit-tft.c
 create mode 100644 drivers/gpu/drm/tinydrm/core/Makefile
 create mode 100644 drivers/gpu/drm/tinydrm/core/tinydrm-core.c
 create mode 100644 drivers/gpu/drm/tinydrm/core/tinydrm-debugfs.c
 create mode 100644 drivers/gpu/drm/tinydrm/core/tinydrm-fb.c
 create mode 100644 drivers/gpu/drm/tinydrm/core/tinydrm-helpers.c
 create mode 100644 drivers/gpu/drm/tinydrm/core/tinydrm-pipe.c
 create mode 100644 drivers/gpu/drm/tinydrm/core/tinydrm-regmap.c
 create mode 100644 drivers/gpu/drm/tinydrm/mi0283qt.c
 create mode 100644 drivers/gpu/drm/tinydrm/mipi-dbi.c
 create mode 100644 drivers/gpu/drm/tinydrm/utinydrm.c
 create mode 100644 include/drm/tinydrm/hx8340.h
 create mode 100644 include/drm/tinydrm/ili9341.h
 create mode 100644 include/drm/tinydrm/mipi-dbi.h
 create mode 100644 include/drm/tinydrm/st7735r.h
 create mode 100644 include/drm/tinydrm/tinydrm-helpers.h
 create mode 100644 include/drm/tinydrm/tinydrm-regmap.h
 create mode 100644 include/drm/tinydrm/tinydrm.h
 create mode 100644 include/uapi/drm/utinydrm.h

diff --git a/drivers/gpu/drm/Kconfig b/drivers/gpu/drm/Kconfig
index 483059a..c882d09 100644
--- a/drivers/gpu/drm/Kconfig
+++ b/drivers/gpu/drm/Kconfig
@@ -300,3 +300,4 @@ config DRM_SAVAGE
 	  chipset. If M is selected the module will be called savage.
 
 endif # DRM_LEGACY
+source "drivers/gpu/drm/tinydrm/Kconfig"
diff --git a/drivers/gpu/drm/Makefile b/drivers/gpu/drm/Makefile
index 25c7204..11c4b8e 100644
--- a/drivers/gpu/drm/Makefile
+++ b/drivers/gpu/drm/Makefile
@@ -86,3 +86,4 @@ obj-$(CONFIG_DRM_FSL_DCU) += fsl-dcu/
 obj-$(CONFIG_DRM_ETNAVIV) += etnaviv/
 obj-$(CONFIG_DRM_ARCPGU)+= arc/
 obj-y			+= hisilicon/
+obj-$(CONFIG_DRM_TINYDRM)+= tinydrm/
diff --git a/drivers/gpu/drm/tinydrm/Kconfig b/drivers/gpu/drm/tinydrm/Kconfig
new file mode 100644
index 0000000..38a073e
--- /dev/null
+++ b/drivers/gpu/drm/tinydrm/Kconfig
@@ -0,0 +1,38 @@
+menuconfig DRM_TINYDRM
+	tristate "Support for small TFT LCD display modules"
+	depends on DRM
+	select DRM_KMS_HELPER
+	select DRM_KMS_CMA_HELPER
+	select VIDEOMODE_HELPERS
+	help
+	  Choose this option if you have a tinydrm supported display.
+	  If M is selected the module will be called tinydrm.
+
+config TINYDRM_MIPI_DBI
+	tristate
+	select REGMAP
+
+config TINYDRM_MI0283QT
+	tristate "DRM support for MI0283QT"
+	depends on DRM_TINYDRM && SPI
+	select TINYDRM_MIPI_DBI
+	help
+	  DRM driver for the following Multi-Inno MI0283QT display panels:
+	    MI0283QT-8, MI0283QT-9, MI0283QT-9A, MI0283QT-11, MI0283QT-13
+
+config TINYDRM_ADAFRUIT_TFT
+	tristate "DRM driver for Adafruit SPI TFT displays"
+	depends on DRM_TINYDRM && SPI
+	select TINYDRM_MIPI_DBI
+	help
+	  DRM driver for the following Adafruit displays:
+	    2.2" Color TFT LCD display - HX8340BN, 9-bit mode (#797)
+	    1.8" Color TFT LCD display - ST7735R (#358)
+
+config TINYDRM_USER
+	tristate "Userspace tinydrm driver"
+	depends on DRM_TINYDRM
+	help
+	  This option enables support for userspace tinydrm. Say 'y' to enable
+	  this support in kernel. To compile this driver as a module,
+	  choose 'm' here: the module will be called utinydrm.
diff --git a/drivers/gpu/drm/tinydrm/Makefile b/drivers/gpu/drm/tinydrm/Makefile
new file mode 100644
index 0000000..7417a5e
--- /dev/null
+++ b/drivers/gpu/drm/tinydrm/Makefile
@@ -0,0 +1,11 @@
+ccflags-y += -I$(src)/include
+
+obj-$(CONFIG_DRM_TINYDRM)		+= core/
+
+# Controllers
+obj-$(CONFIG_TINYDRM_MIPI_DBI)		+= mipi-dbi.o
+
+# Displays
+obj-$(CONFIG_TINYDRM_MI0283QT)		+= mi0283qt.o
+obj-$(CONFIG_TINYDRM_ADAFRUIT_TFT)	+= adafruit-tft.o
+obj-$(CONFIG_TINYDRM_USER)		+= utinydrm.o
diff --git a/drivers/gpu/drm/tinydrm/adafruit-tft.c b/drivers/gpu/drm/tinydrm/adafruit-tft.c
new file mode 100644
index 0000000..ef89c1b
--- /dev/null
+++ b/drivers/gpu/drm/tinydrm/adafruit-tft.c
@@ -0,0 +1,394 @@
+#define DEBUG
+
+/*
+ * DRM driver for Adafruit MIPI compatible SPI TFT displays
+ *
+ * Copyright 2016 Noralf Tr√∏nnes
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <drm/tinydrm/hx8340.h>
+#include <drm/tinydrm/mipi-dbi.h>
+#include <drm/tinydrm/st7735r.h>
+#include <drm/tinydrm/tinydrm.h>
+#include <drm/tinydrm/tinydrm-helpers.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/property.h>
+#include <linux/regulator/consumer.h>
+#include <linux/spi/spi.h>
+#include <video/mipi_display.h>
+
+struct adafruit_tft_display {
+	const struct drm_display_mode mode;
+	const struct drm_simple_display_pipe_funcs funcs;
+	bool write_only;
+	bool dc;
+};
+
+enum adafruit_tft_display_ids {
+	ADAFRUIT_797,
+	ADAFRUIT_358,
+};
+
+/*
+ * 2.2" Color TFT LCD display - HX8340BN, 9-bit mode (#797)
+ * Product: http://www.adafruit.com/products/797
+ * Schematics: https://github.com/adafruit/Adafruit-2.2-SPI-TFT
+ *
+ * It's hard to tell if it should be possible to read from the controller.
+ * The datasheet says that SDI is used for input and output, but
+ * the schematics indicate that MISO is connected.
+ * One user reports a failed attempt to read from it. So err on the safe
+ * side and mark it is as write-only in case it tries to drive MOSI.
+ *
+ * Init sequence taken from the BTL221722-276L datasheet
+ */
+static void adafruit_tft_797_enable(struct drm_simple_display_pipe *pipe,
+				    struct drm_crtc_state *crtc_state)
+{
+	struct tinydrm_device *tdev = pipe_to_tinydrm(pipe);
+	struct mipi_dbi *mipi = mipi_dbi_from_tinydrm(tdev);
+	struct device *dev = tdev->drm.dev;
+	struct regmap *reg = mipi->reg;
+	u8 addr_mode;
+	int ret;
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	mutex_lock(&tdev->dev_lock);
+
+	if (tdev->prepared)
+		goto out_unlock;
+
+	if (mipi->regulator) {
+		ret = regulator_enable(mipi->regulator);
+		if (ret) {
+			dev_err(dev, "Failed to enable regulator %d\n", ret);
+			goto out_unlock;
+		}
+	}
+
+	mipi_dbi_hw_reset(mipi);
+	ret = mipi_dbi_write(reg, HX8340_SETEXTCMD, 0xFF, 0x83, 0x40);
+	if (ret) {
+		dev_err(dev, "Error writing command %d\n", ret);
+		goto out_unlock;
+	}
+
+	mipi_dbi_write(reg, MIPI_DCS_EXIT_SLEEP_MODE);
+	msleep(150);
+
+	/* Undocumented register */
+	mipi_dbi_write(reg, 0xCA, 0x70, 0x00, 0xD9);
+
+	mipi_dbi_write(reg, HX8340_SETOSC, 0x01, 0x11);
+
+	/* Driving ability Setting */
+	mipi_dbi_write(reg, 0xC9,
+		       0x90, 0x49, 0x10, 0x28, 0x28, 0x10, 0x00, 0x06);
+	msleep(20);
+
+	/* Gamma 2.2 Setting */
+	mipi_dbi_write(reg, HX8340_SETGAMMAP,
+		       0x60, 0x71, 0x01, 0x0E, 0x05, 0x02, 0x09, 0x31, 0x0A);
+	mipi_dbi_write(reg, HX8340_SETGAMMAN,
+		       0x67, 0x30, 0x61, 0x17, 0x48, 0x07, 0x05, 0x33);
+	msleep(10);
+
+	mipi_dbi_write(reg, HX8340_SETPWCTR5, 0x35, 0x20, 0x45);
+	mipi_dbi_write(reg, HX8340_SETPWCTR4, 0x33, 0x25, 0x4C);
+	msleep(10);
+
+	mipi_dbi_write(reg, MIPI_DCS_SET_PIXEL_FORMAT, 0x05);
+
+	switch (mipi->rotation) {
+	default:
+		addr_mode = 0;
+		break;
+	case 90:
+		addr_mode = HX8340_MADCTL_MV | HX8340_MADCTL_MY;
+		break;
+	case 180:
+		addr_mode = HX8340_MADCTL_MY;
+		break;
+	case 270:
+		addr_mode = HX8340_MADCTL_MX | HX8340_MADCTL_MV;
+		break;
+	}
+	addr_mode |= HX8340_MADCTL_BGR;
+	mipi_dbi_write(reg, MIPI_DCS_SET_ADDRESS_MODE, addr_mode);
+
+	mipi_dbi_write(reg, MIPI_DCS_SET_DISPLAY_ON);
+	msleep(50);
+
+	tdev->prepared = true;
+	if (pipe->plane.state->fb)
+		schedule_work(&tdev->dirty_work);
+
+out_unlock:
+	mutex_unlock(&tdev->dev_lock);
+}
+
+/*
+ * 1.8" Color TFT LCD display - ST7735R (#358)
+ * Product: https://www.adafruit.com/products/358
+ *
+ * Init sequence taken from the Adafruit-ST7735-Library (Black Tab)
+ */
+static void adafruit_tft_358_enable(struct drm_simple_display_pipe *pipe,
+				    struct drm_crtc_state *crtc_state)
+{
+	struct tinydrm_device *tdev = pipe_to_tinydrm(pipe);
+	struct mipi_dbi *mipi = mipi_dbi_from_tinydrm(tdev);
+	struct device *dev = tdev->drm.dev;
+	struct regmap *reg = mipi->reg;
+	u8 addr_mode;
+	int ret;
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	mutex_lock(&tdev->dev_lock);
+
+	if (tdev->prepared)
+		goto out_unlock;
+
+	if (mipi->regulator) {
+		ret = regulator_enable(mipi->regulator);
+		if (ret) {
+			dev_err(dev, "Failed to enable regulator %d\n", ret);
+			goto out_unlock;
+		}
+	}
+
+	mipi_dbi_hw_reset(mipi);
+	ret = mipi_dbi_write(reg, MIPI_DCS_SOFT_RESET);
+	if (ret) {
+		dev_err(dev, "Error writing command %d\n", ret);
+		goto out_unlock;
+	}
+
+	msleep(150);
+
+	mipi_dbi_write(reg, MIPI_DCS_EXIT_SLEEP_MODE);
+	msleep(500);
+
+	mipi_dbi_write(reg, ST7735R_FRMCTR1, 0x01, 0x2C, 0x2D);
+	mipi_dbi_write(reg, ST7735R_FRMCTR2, 0x01, 0x2C, 0x2D);
+	mipi_dbi_write(reg, ST7735R_FRMCTR3,
+		       0x01, 0x2C, 0x2D, 0x01, 0x2C, 0x2D);
+	mipi_dbi_write(reg, ST7735R_INVCTR, 0x07);
+
+	mipi_dbi_write(reg, ST7735R_PWCTR1, 0xA2, 0x02, 0x84);
+	mipi_dbi_write(reg, ST7735R_PWCTR2, 0xC5);
+	mipi_dbi_write(reg, ST7735R_PWCTR3, 0x0A, 0x00);
+	mipi_dbi_write(reg, ST7735R_PWCTR4, 0x8A, 0x2A);
+	mipi_dbi_write(reg, ST7735R_PWCTR5, 0x8A, 0xEE);
+
+	mipi_dbi_write(reg, ST7735R_VMCTR1, 0x0E);
+	mipi_dbi_write(reg, MIPI_DCS_EXIT_INVERT_MODE);
+
+	switch (mipi->rotation) {
+	default:
+		addr_mode = ST7735R_MADCTL_MX | ST7735R_MADCTL_MY;
+		break;
+	case 90:
+		addr_mode = ST7735R_MADCTL_MX | ST7735R_MADCTL_MV;
+		break;
+	case 180:
+		addr_mode = 0;
+		break;
+	case 270:
+		addr_mode = ST7735R_MADCTL_MY | ST7735R_MADCTL_MV;
+		break;
+	}
+	mipi_dbi_write(reg, MIPI_DCS_SET_ADDRESS_MODE, addr_mode);
+
+	mipi_dbi_write(reg, MIPI_DCS_SET_PIXEL_FORMAT, 0x05);
+
+	mipi_dbi_write(reg, ST7735R_GAMCTRP1,
+		       0x02, 0x1c, 0x07, 0x12, 0x37, 0x32, 0x29, 0x2d,
+		       0x29, 0x25, 0x2B, 0x39, 0x00, 0x01, 0x03, 0x10);
+	mipi_dbi_write(reg, ST7735R_GAMCTRN1,
+		       0x03, 0x1d, 0x07, 0x06, 0x2E, 0x2C, 0x29, 0x2D,
+		       0x2E, 0x2E, 0x37, 0x3F, 0x00, 0x00, 0x02, 0x10);
+
+	mipi_dbi_write(reg, MIPI_DCS_ENTER_NORMAL_MODE);
+	msleep(20);
+
+	mipi_dbi_write(reg, MIPI_DCS_SET_DISPLAY_ON);
+	msleep(100);
+
+	tdev->prepared = true;
+	if (pipe->plane.state->fb)
+		schedule_work(&tdev->dirty_work);
+
+out_unlock:
+	mutex_unlock(&tdev->dev_lock);
+}
+
+static const struct adafruit_tft_display adafruit_tft_displays[] = {
+	[ADAFRUIT_797] = {
+		.mode = {
+			TINYDRM_MODE(176, 220, 34, 43),
+		},
+		.funcs = {
+			.enable = adafruit_tft_797_enable,
+			.disable = mipi_dbi_pipe_disable,
+			.update = tinydrm_display_pipe_update,
+		},
+		.write_only = true,
+	},
+	[ADAFRUIT_358] = {
+		.mode = {
+			TINYDRM_MODE(128, 160, 28, 35),
+		},
+		.funcs = {
+			.enable = adafruit_tft_358_enable,
+			.disable = mipi_dbi_pipe_disable,
+			.update = tinydrm_display_pipe_update,
+		},
+		.dc = true,
+		.write_only = true,
+	},
+};
+
+static const struct of_device_id adafruit_tft_of_match[] = {
+	{ .compatible = "adafruit,tft797",  .data = (void *)ADAFRUIT_797 },
+	{ .compatible = "adafruit,tft358",  .data = (void *)ADAFRUIT_358 },
+	{},
+};
+MODULE_DEVICE_TABLE(of, adafruit_tft_of_match);
+
+static const struct spi_device_id adafruit_tft_id[] = {
+	{ "tft797",  ADAFRUIT_797 },
+	{ "tft358",  ADAFRUIT_358 },
+	{ },
+};
+MODULE_DEVICE_TABLE(spi, adafruit_tft_id);
+
+static struct drm_driver adafruit_tft_driver = {
+	.driver_features	= DRIVER_GEM | DRIVER_MODESET | DRIVER_PRIME |
+				  DRIVER_ATOMIC,
+	TINYDRM_GEM_DRIVER_OPS,
+	.lastclose		= tinydrm_lastclose,
+	.debugfs_init		= mipi_dbi_debugfs_init,
+	.debugfs_cleanup	= mipi_dbi_debugfs_cleanup,
+	.name			= "adafruit-tft",
+	.desc			= "Adafruit TFT",
+	.date			= "20160317",
+	.major			= 1,
+	.minor			= 0,
+};
+
+static int adafruit_tft_probe(struct spi_device *spi)
+{
+	const struct adafruit_tft_display *display;
+	const struct of_device_id *of_id;
+	struct device *dev = &spi->dev;
+	struct tinydrm_device *tdev;
+	struct gpio_desc *dc = NULL;
+	struct mipi_dbi *mipi;
+	u32 rotation = 0;
+	int id, ret;
+
+	of_id = of_match_device(adafruit_tft_of_match, dev);
+	if (of_id) {
+		id = (int)of_id->data;
+	} else {
+		const struct spi_device_id *spi_id = spi_get_device_id(spi);
+
+		if (!spi_id)
+			return -EINVAL;
+
+		id = spi_id->driver_data;
+	}
+
+	if (!dev->coherent_dma_mask) {
+		ret = dma_coerce_mask_and_coherent(dev, DMA_BIT_MASK(32));
+		if (ret)
+			dev_warn(dev, "Failed to set dma mask %d\n", ret);
+	}
+
+	display = &adafruit_tft_displays[id];
+
+	mipi = devm_kzalloc(dev, sizeof(*mipi), GFP_KERNEL);
+	if (!mipi)
+		return -ENOMEM;
+
+	mipi->reset = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(mipi->reset)) {
+		dev_err(dev, "Failed to get gpio 'reset'\n");
+		return PTR_ERR(mipi->reset);
+	}
+
+	if (display->dc) {
+		dc = devm_gpiod_get_optional(dev, "dc", GPIOD_OUT_LOW);
+		if (IS_ERR(dc)) {
+			dev_err(dev, "Failed to get gpio 'dc'\n");
+			return PTR_ERR(dc);
+		}
+	}
+
+	mipi->regulator = devm_regulator_get_optional(dev, "power");
+	if (IS_ERR(mipi->regulator)) {
+		ret = PTR_ERR(mipi->regulator);
+		if (ret != -ENODEV)
+			return ret;
+
+		mipi->regulator = NULL;
+	}
+
+	mipi->backlight = tinydrm_of_find_backlight(dev);
+	if (IS_ERR(mipi->backlight))
+		return PTR_ERR(mipi->backlight);
+
+	device_property_read_u32(dev, "rotation", &rotation);
+
+	mipi->reg = mipi_dbi_spi_init(spi, dc, display->write_only);
+	if (IS_ERR(mipi->reg))
+		return PTR_ERR(mipi->reg);
+
+	ret = mipi_dbi_init(dev, mipi, &display->funcs, &adafruit_tft_driver,
+			    &display->mode, rotation);
+	if (ret)
+		return ret;
+
+	tdev = &mipi->tinydrm;
+
+	ret = devm_tinydrm_register(tdev);
+	if (ret)
+		return ret;
+
+	spi_set_drvdata(spi, tdev);
+
+	DRM_DEBUG_DRIVER("Initialized %s:%s @%uMHz on minor %d\n",
+			 tdev->drm.driver->name, dev_name(dev),
+			 spi->max_speed_hz / 1000000,
+			 tdev->drm.primary->index);
+
+	return 0;
+}
+
+static struct spi_driver adafruit_tft_spi_driver = {
+	.driver = {
+		.name = "adafruit-tft",
+		.owner = THIS_MODULE,
+		.of_match_table = adafruit_tft_of_match,
+		.pm = &tinydrm_simple_pm_ops,
+	},
+	.id_table = adafruit_tft_id,
+	.probe = adafruit_tft_probe,
+	.shutdown = tinydrm_spi_shutdown,
+};
+module_spi_driver(adafruit_tft_spi_driver);
+
+MODULE_DESCRIPTION("Adafruit MIPI compatible SPI displays");
+MODULE_AUTHOR("Noralf Tr√∏nnes");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/tinydrm/core/Makefile b/drivers/gpu/drm/tinydrm/core/Makefile
new file mode 100644
index 0000000..c672d89
--- /dev/null
+++ b/drivers/gpu/drm/tinydrm/core/Makefile
@@ -0,0 +1,7 @@
+ccflags-y += -I$(src)/../include
+
+tinydrm-y := tinydrm-core.o tinydrm-pipe.o tinydrm-fb.o tinydrm-helpers.o
+tinydrm-$(CONFIG_REGMAP) += tinydrm-regmap.o
+tinydrm-$(CONFIG_DEBUG_FS) += tinydrm-debugfs.o
+
+obj-$(CONFIG_DRM_TINYDRM) += tinydrm.o
diff --git a/drivers/gpu/drm/tinydrm/core/tinydrm-core.c b/drivers/gpu/drm/tinydrm/core/tinydrm-core.c
new file mode 100644
index 0000000..da55c2c
--- /dev/null
+++ b/drivers/gpu/drm/tinydrm/core/tinydrm-core.c
@@ -0,0 +1,411 @@
+/*
+ * Copyright (C) 2016 Noralf Tr√∏nnes
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <drm/drmP.h>
+#include <drm/drm_atomic.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_fb_cma_helper.h>
+#include <drm/drm_fb_helper.h>
+#include <drm/tinydrm/tinydrm.h>
+#include <linux/console.h>
+#include <linux/device.h>
+#include <linux/dma-buf.h>
+
+/**
+ * DOC: Overview
+ *
+ * This library provides helpers for displays with onboard graphics memory
+ * connected through a slow interface.
+ *
+ * In order for the display to turn off at shutdown, the device driver shutdown
+ * callback has to be set. This function should call tinydrm_shutdown().
+ */
+
+/**
+ * tinydrm_lastclose - DRM .lastclose() helper
+ * @drm: DRM device
+ *
+ * This function ensures that fbdev is restored when drm_lastclose() is called
+ * on the last drm_release(). If fbdev is disabled the pipeline is disabled
+ * instead. tinydrm drivers should use this as their &drm_driver->lastclose
+ * callback.
+ */
+void tinydrm_lastclose(struct drm_device *drm)
+{
+	struct tinydrm_device *tdev = drm_to_tinydrm(drm);
+
+	DRM_DEBUG_KMS("\n");
+	if (tdev->fbdev_used)
+		drm_fbdev_cma_restore_mode(tdev->fbdev_cma);
+	else
+		drm_crtc_force_disable_all(drm);
+}
+EXPORT_SYMBOL(tinydrm_lastclose);
+
+/**
+ * tinydrm_gem_cma_free_object - free resources associated with a CMA GEM
+ *                               object
+ * @gem_obj: GEM object to free
+ *
+ * This function frees the backing memory of the CMA GEM object, cleans up the
+ * GEM object state and frees the memory used to store the object itself using
+ * drm_gem_cma_free_object(). It also handles PRIME buffers which has the kernel
+ * virtual address set by tinydrm_gem_cma_prime_import_sg_table(). tinydrm
+ * drivers should set this as their &drm_driver->gem_free_object callback.
+ */
+void tinydrm_gem_cma_free_object(struct drm_gem_object *gem_obj)
+{
+	if (gem_obj->import_attach) {
+		struct drm_gem_cma_object *cma_obj;
+
+		cma_obj = to_drm_gem_cma_obj(gem_obj);
+		dma_buf_vunmap(gem_obj->import_attach->dmabuf, cma_obj->vaddr);
+		cma_obj->vaddr = NULL;
+	}
+
+	drm_gem_cma_free_object(gem_obj);
+}
+EXPORT_SYMBOL_GPL(tinydrm_gem_cma_free_object);
+
+/**
+ * tinydrm_gem_cma_prime_import_sg_table - produce a CMA GEM object from
+ *     another driver's scatter/gather table of pinned pages
+ * @drm: device to import into
+ * @attach: DMA-BUF attachment
+ * @sgt: scatter/gather table of pinned pages
+ *
+ * This function imports a scatter/gather table exported via DMA-BUF by
+ * another driver using drm_gem_cma_prime_import_sg_table(). It also sets the
+ * kernel virtual address on the CMA object. tinydrm drivers should use this
+ * as their &drm_driver->gem_prime_import_sg_table callback.
+ *
+ * Returns:
+ * A pointer to a newly created GEM object or an ERR_PTR-encoded negative
+ * error code on failure.
+ */
+struct drm_gem_object *
+tinydrm_gem_cma_prime_import_sg_table(struct drm_device *drm,
+				      struct dma_buf_attachment *attach,
+				      struct sg_table *sgt)
+{
+	struct drm_gem_cma_object *cma_obj;
+	struct drm_gem_object *obj;
+	void *vaddr;
+
+	vaddr = dma_buf_vmap(attach->dmabuf);
+	if (!vaddr) {
+		DRM_ERROR("Failed to vmap PRIME buffer\n");
+		return ERR_PTR(-ENOMEM);
+	}
+
+	obj = drm_gem_cma_prime_import_sg_table(drm, attach, sgt);
+	if (IS_ERR(obj)) {
+		dma_buf_vunmap(attach->dmabuf, vaddr);
+		return obj;
+	}
+
+	cma_obj = to_drm_gem_cma_obj(obj);
+	cma_obj->vaddr = vaddr;
+
+	return obj;
+}
+EXPORT_SYMBOL(tinydrm_gem_cma_prime_import_sg_table);
+
+const struct file_operations tinydrm_fops = {
+	.owner		= THIS_MODULE,
+	.open		= drm_open,
+	.release	= drm_release,
+	.unlocked_ioctl	= drm_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl	= drm_compat_ioctl,
+#endif
+	.poll		= drm_poll,
+	.read		= drm_read,
+	.llseek		= no_llseek,
+	.mmap		= drm_gem_cma_mmap,
+};
+EXPORT_SYMBOL(tinydrm_fops);
+
+static const struct drm_mode_config_funcs tinydrm_mode_config_funcs = {
+	.fb_create = tinydrm_fb_create,
+	.atomic_check = drm_atomic_helper_check,
+	.atomic_commit = drm_atomic_helper_commit,
+};
+
+static void tinydrm_dirty_work(struct work_struct *work)
+{
+	struct tinydrm_device *tdev = container_of(work, struct tinydrm_device,
+						   dirty_work);
+	struct drm_framebuffer *fb = tdev->pipe.plane.fb;
+
+	if (fb && fb->funcs->dirty)
+		fb->funcs->dirty(fb, NULL, 0, 0, NULL, 0);
+}
+
+static int tinydrm_init(struct device *parent, struct tinydrm_device *tdev,
+			const struct drm_framebuffer_funcs *fb_funcs,
+			struct drm_driver *driver)
+{
+	struct drm_device *drm = &tdev->drm;
+	int ret;
+
+	INIT_WORK(&tdev->dirty_work, tinydrm_dirty_work);
+	mutex_init(&tdev->dev_lock);
+	tdev->fb_funcs = fb_funcs;
+
+	ret = drm_dev_init(drm, driver, parent);
+	if (ret)
+		return ret;
+
+	drm_mode_config_init(drm);
+	drm->mode_config.funcs = &tinydrm_mode_config_funcs;
+
+	return 0;
+}
+
+static void tinydrm_fini(struct tinydrm_device *tdev)
+{
+	struct drm_device *drm = &tdev->drm;
+
+	DRM_DEBUG_KMS("\n");
+
+	drm_mode_config_cleanup(drm);
+	drm_dev_unref(drm);
+	mutex_destroy(&tdev->dev_lock);
+}
+
+static void devm_tinydrm_release(struct device *dev, void *res)
+{
+	tinydrm_fini(*(struct tinydrm_device **)res);
+}
+
+/**
+ * devm_tinydrm_init - Initialize tinydrm device
+ * @parent: Parent device object
+ * @tdev: tinydrm device
+ * @fb_funcs: Framebuffer functions
+ * @driver: DRM driver
+ *
+ * This function initializes @tdev, the underlying DRM device and it's
+ * mode_config. Additionally it sets &drm_mode_config_funcs using
+ * tinydrm_fb_create() for framebuffer creation.
+ * Resources will be automatically freed on driver detach (devres) using
+ * drm_mode_config_cleanup() and drm_dev_unref().
+ *
+ * Returns:
+ * Zero on success, negative error code on failure.
+ */
+int devm_tinydrm_init(struct device *parent, struct tinydrm_device *tdev,
+		      const struct drm_framebuffer_funcs *fb_funcs,
+		      struct drm_driver *driver)
+{
+	struct tinydrm_device **ptr;
+	int ret;
+
+	ptr = devres_alloc(devm_tinydrm_release, sizeof(*ptr), GFP_KERNEL);
+	if (!ptr)
+		return -ENOMEM;
+
+	ret = tinydrm_init(parent, tdev, fb_funcs, driver);
+	if (ret) {
+		devres_free(ptr);
+		return ret;
+	}
+
+	*ptr = tdev;
+	devres_add(parent, ptr);
+
+	return 0;
+}
+EXPORT_SYMBOL(devm_tinydrm_init);
+
+static int tinydrm_register(struct tinydrm_device *tdev)
+{
+	struct drm_device *drm = &tdev->drm;
+	int ret;
+
+	ret = drm_dev_register(drm, 0);
+	if (ret)
+		return ret;
+
+	ret = tinydrm_fbdev_init(tdev);
+	if (ret)
+		DRM_ERROR("Failed to initialize fbdev: %d\n", ret);
+
+	return 0;
+}
+
+static void tinydrm_unregister(struct tinydrm_device *tdev)
+{
+	struct drm_device *drm = &tdev->drm;
+
+	DRM_DEBUG_KMS("\n");
+
+	drm_crtc_force_disable_all(drm);
+	cancel_work_sync(&tdev->dirty_work);
+	tinydrm_fbdev_fini(tdev);
+	drm_dev_unregister(drm);
+}
+
+static void devm_tinydrm_register_release(struct device *dev, void *res)
+{
+	tinydrm_unregister(*(struct tinydrm_device **)res);
+}
+
+/**
+ * devm_tinydrm_register - Register tinydrm device
+ * @tdev: tinydrm device
+ *
+ * This function registers the underlying DRM device, connectors and fbdev.
+ * These resources will be automatically unregistered on driver detach (devres)
+ * and the display pipeline will be disabled.
+ *
+ * Returns:
+ * Zero on success, negative error code on failure.
+ */
+int devm_tinydrm_register(struct tinydrm_device *tdev)
+{
+	struct device *dev = tdev->drm.dev;
+	struct tinydrm_device **ptr;
+	int ret;
+
+	ptr = devres_alloc(devm_tinydrm_register_release, sizeof(*ptr),
+			   GFP_KERNEL);
+	if (!ptr)
+		return -ENOMEM;
+
+	ret = tinydrm_register(tdev);
+	if (ret) {
+		devres_free(ptr);
+		return ret;
+	}
+
+	*ptr = tdev;
+	devres_add(dev, ptr);
+
+	return 0;
+}
+EXPORT_SYMBOL(devm_tinydrm_register);
+
+static int devm_tinydrm_register_match(struct device *dev, void *res, void *data)
+{
+	struct tinydrm_device **ptr = res, *tdev = data;
+
+        return *ptr == tdev;
+}
+
+void devm_tinydrm_unregister(struct tinydrm_device *tdev)
+{
+	struct device *dev = tdev->drm.dev;
+
+	if (WARN_ON(!dev))
+		return;
+
+	WARN_ON(devres_release(dev, devm_tinydrm_register_release, devm_tinydrm_register_match, tdev));
+}
+EXPORT_SYMBOL(devm_tinydrm_unregister);
+
+/**
+ * tinydrm_shutdown - Shutdown tinydrm
+ * @tdev: tinydrm device
+ *
+ * This function makes sure that tinydrm is disabled and unprepared.
+ * Used by drivers in their shutdown callback to turn off the display
+ * on machine shutdown and reboot.
+ */
+void tinydrm_shutdown(struct tinydrm_device *tdev)
+{
+	struct drm_device *drm = &tdev->drm;
+
+	drm_crtc_force_disable_all(drm);
+}
+EXPORT_SYMBOL(tinydrm_shutdown);
+
+static void tinydrm_fbdev_set_suspend(struct tinydrm_device *tdev, int state)
+{
+	if (!tdev->fbdev_helper)
+		return;
+
+	console_lock();
+	drm_fb_helper_set_suspend(tdev->fbdev_helper, state);
+	console_unlock();
+}
+
+/**
+ * tinydrm_suspend - Suspend tinydrm
+ * @tdev: tinydrm device
+ *
+ * Used in driver PM operations to suspend tinydrm.
+ * Suspends fbdev and DRM.
+ * Resume with tinydrm_resume().
+ *
+ * Returns:
+ * Zero on success, negative error code on failure.
+ */
+int tinydrm_suspend(struct tinydrm_device *tdev)
+{
+	struct drm_device *drm = &tdev->drm;
+	struct drm_atomic_state *state;
+
+	if (tdev->suspend_state) {
+		DRM_ERROR("Failed to suspend: state already set\n");
+		return -EINVAL;
+	}
+
+	tinydrm_fbdev_set_suspend(tdev, 1);
+	state = drm_atomic_helper_suspend(drm);
+	if (IS_ERR(state)) {
+		tinydrm_fbdev_set_suspend(tdev, 0);
+		return PTR_ERR(state);
+	}
+
+	tdev->suspend_state = state;
+
+	return 0;
+}
+EXPORT_SYMBOL(tinydrm_suspend);
+
+/**
+ * tinydrm_resume - Resume tinydrm
+ * @tdev: tinydrm device
+ *
+ * Used in driver PM operations to resume tinydrm.
+ * Suspend with tinydrm_suspend().
+ *
+ * Returns:
+ * Zero on success, negative error code on failure.
+ */
+int tinydrm_resume(struct tinydrm_device *tdev)
+{
+	struct drm_atomic_state *state = tdev->suspend_state;
+	struct drm_device *drm = &tdev->drm;
+	int ret;
+
+	if (!state) {
+		DRM_ERROR("Failed to resume: state is not set\n");
+		return -EINVAL;
+	}
+
+	tdev->suspend_state = NULL;
+
+	ret = drm_atomic_helper_resume(drm, state);
+	if (ret) {
+		DRM_ERROR("Error resuming state: %d\n", ret);
+		drm_atomic_state_free(state);
+		return ret;
+	}
+
+	tinydrm_fbdev_set_suspend(tdev, 0);
+
+	return 0;
+}
+EXPORT_SYMBOL(tinydrm_resume);
+
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/tinydrm/core/tinydrm-debugfs.c b/drivers/gpu/drm/tinydrm/core/tinydrm-debugfs.c
new file mode 100644
index 0000000..0c70146
--- /dev/null
+++ b/drivers/gpu/drm/tinydrm/core/tinydrm-debugfs.c
@@ -0,0 +1,439 @@
+/*
+ * Copyright (C) 2016 Noralf Tr√∏nnes
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <drm/drmP.h>
+#include <drm/drm_fb_cma_helper.h>
+#include <drm/tinydrm/tinydrm.h>
+#include <linux/debugfs.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+
+/**
+ * DOC: Performance reporting
+ *
+ * tinydrm can provide performance reporting when built with CONFIG_DEBUG_FS.
+ * This is available through the file ``dirty``.
+ * Writing a positive number <n> to this file (re)starts the process of
+ * collecting statistics for the last <n> framebuffer flushes.
+ * Writing a zero stops it.
+ * Reading this file will provide a list of the last <n> flushes.
+ * Reading will not clear the list.
+ *
+ * Example use::
+ *     # cd /sys/kernel/debug/dri/0
+ *     # echo 4 > dirty
+ *     # cat dirty
+ *     [ 2140.061740] 2798 KiB/s, 151 KiB in 54 ms,    full(320x240+0+0)
+ *     [ 2140.161710] 2798 KiB/s, 151 KiB in 54 ms,    full(320x240+0+0),  99 ms since last, 10 fps
+ *     [ 2140.301724] 2798 KiB/s, 151 KiB in 54 ms,    full(320x240+0+0), 140 ms since last,  7 fps
+ *     [ 2140.361702] 3552 KiB/s,  10 KiB in  3 ms, partial(320x16+0+224),  59 ms since last
+ *
+ * To get this functionality the driver needs to use tinydrm_debugfs_init() and
+ * tinydrm_debugfs_cleanup() in their &drm_driver. Additionally it has to call
+ * tinydrm_debugfs_dirty_init() to set it up and then bracket the framebuffer
+ * flushes with calls to tinydrm_debugfs_dirty_begin() and
+ * tinydrm_debugfs_dirty_end().
+ */
+
+#define MAX_DIRTY_ENTRIES 128
+
+struct tinydrm_dirty_entry {
+	struct list_head list;
+	struct drm_clip_rect clip;
+	bool full;
+	size_t len;
+	u64 start;
+	u64 end;
+};
+
+struct tinydrm_debugfs_dirty {
+	struct list_head list;
+	struct mutex list_lock;
+};
+
+/**
+ * tinydrm_debugfs_dirty_init - Initialize performance reporting
+ * @tdev: tinydrm device
+ *
+ * Returns:
+ * Zero on success, negative error code on failure.
+ */
+int tinydrm_debugfs_dirty_init(struct tinydrm_device *tdev)
+{
+	struct tinydrm_debugfs_dirty *dirty;
+
+	dirty = devm_kzalloc(tdev->drm.dev, sizeof(*dirty), GFP_KERNEL);
+	if (!dirty)
+		return -ENOMEM;
+
+	mutex_init(&dirty->list_lock);
+	INIT_LIST_HEAD(&dirty->list);
+	tdev->debugfs_dirty = dirty;
+
+	return 0;
+}
+EXPORT_SYMBOL(tinydrm_debugfs_dirty_init);
+
+static struct tinydrm_dirty_entry *
+tinydrm_debugfs_dirty_get_entry(struct tinydrm_debugfs_dirty *dirty)
+{
+	struct tinydrm_dirty_entry *entry;
+
+	entry = list_last_entry(&dirty->list,
+				struct tinydrm_dirty_entry, list);
+	if (entry->start) {
+		if (entry->end)
+			return NULL; /* buffer is full */
+		else
+			return entry; /* in progress */
+	}
+	/* The buffer hasn't been filled yet */
+	list_for_each_entry(entry, &dirty->list, list) {
+		if (!entry->end)
+			return entry;
+	}
+
+	WARN_ON(1);
+	return NULL;
+}
+
+/**
+ * tinydrm_debugfs_dirty_begin - Display update is starting
+ * @tdev: tinydrm device
+ * @fb: framebuffer
+ * @clip: The part of the display that is to be updated.
+ */
+void tinydrm_debugfs_dirty_begin(struct tinydrm_device *tdev,
+				 struct drm_framebuffer *fb,
+				 const struct drm_clip_rect *clip)
+{
+	struct tinydrm_debugfs_dirty *dirty = tdev->debugfs_dirty;
+	struct tinydrm_dirty_entry *entry;
+
+	if (!dirty)
+		return;
+
+	mutex_lock(&dirty->list_lock);
+
+	if (list_empty(&dirty->list))
+		goto out_unlock;
+
+	entry = tinydrm_debugfs_dirty_get_entry(dirty);
+	if (!entry) {
+		list_rotate_left(&dirty->list);
+		entry = list_last_entry(&dirty->list,
+					struct tinydrm_dirty_entry, list);
+	}
+
+	entry->clip = *clip;
+	entry->full = clip->x1 == 0 && clip->x2 == fb->width &&
+		      clip->y1 == 0 && clip->y2 == fb->height;
+	entry->start = local_clock();
+	entry->end = 0;
+
+out_unlock:
+	mutex_unlock(&dirty->list_lock);
+}
+EXPORT_SYMBOL(tinydrm_debugfs_dirty_begin);
+
+/**
+ * tinydrm_debugfs_dirty_end - Display update has ended
+ * @tdev: tinydrm device
+ * @len: Length of transfer buffer
+ * @bits_per_pixel: Used to calculate transfer length if @len is zero by
+ *                  multiplying with number of pixels in clip.
+ */
+void tinydrm_debugfs_dirty_end(struct tinydrm_device *tdev, size_t len,
+			       unsigned int bits_per_pixel)
+{
+	struct tinydrm_debugfs_dirty *dirty = tdev->debugfs_dirty;
+	struct tinydrm_dirty_entry *entry;
+
+	if (!dirty)
+		return;
+
+	mutex_lock(&dirty->list_lock);
+
+	if (list_empty(&dirty->list))
+		goto out_unlock;
+
+	entry = tinydrm_debugfs_dirty_get_entry(dirty);
+	if (WARN_ON(!entry))
+		goto out_unlock;
+
+	if (!entry->start)
+		goto out_unlock; /* enabled during an update */
+
+	if (!len)
+		len = (entry->clip.x2 - entry->clip.x1) *
+		      (entry->clip.y2 - entry->clip.y1) *
+		      bits_per_pixel / 8;
+	entry->end = local_clock();
+	entry->len = len;
+
+out_unlock:
+	mutex_unlock(&dirty->list_lock);
+}
+EXPORT_SYMBOL(tinydrm_debugfs_dirty_end);
+
+static int tinydrm_debugfs_dirty_seq_show(struct seq_file *s, void *v)
+{
+	struct tinydrm_debugfs_dirty *dirty = s->private;
+	struct tinydrm_dirty_entry *entry;
+	u64 previous_start = 0;
+	bool previous_full = false;
+
+	if (!dirty) {
+		seq_puts(s, "Performance reporting is not supported by this driver.\n");
+		return 0;
+	}
+
+	mutex_lock(&dirty->list_lock);
+
+	if (list_empty(&dirty->list)) {
+		seq_puts(s, "Performance reporting is disabled.\n");
+		seq_printf(s, "Enable by writing the number of wanted entries to this file (<%i)\n",
+			   MAX_DIRTY_ENTRIES + 1);
+		goto out_unlock;
+	}
+
+	list_for_each_entry(entry, &dirty->list, list) {
+		u32 start_rem_nsec, duration_ms, last_ms = 0;
+		u64 start_sec, throughput;
+
+		/* stop on empty entry (buffer not full nor empty) */
+		if (!entry->start)
+			break;
+
+		start_sec = div_u64_rem(entry->start, 1000000000,
+					&start_rem_nsec);
+		seq_printf(s, "[%5llu.%06u]", start_sec,
+			   start_rem_nsec / 1000);
+
+		if (!entry->end) {
+			seq_puts(s, " update in progress\n");
+			break;
+		}
+
+		if (entry->end <= entry->start) {
+			seq_puts(s, " illegal entry\n");
+			continue;
+		}
+
+		duration_ms = div_u64(entry->end - entry->start, 1000000);
+		if (!duration_ms)
+			duration_ms = 1;
+
+		throughput = entry->len * 1000 / duration_ms / SZ_1K;
+		seq_printf(s, " %5llu KiB/s", throughput);
+		if (entry->len < SZ_4K)
+			seq_printf(s, ", %4u bytes", entry->len);
+		else
+			seq_printf(s, ", %6u KiB", entry->len / SZ_1K);
+
+		seq_printf(s, " in %3u ms", duration_ms);
+
+		seq_printf(s, ", %s(%ux%u+%u+%u)",
+			   entry->full ? "   full" : "partial",
+			   entry->clip.x2 - entry->clip.x1,
+			   entry->clip.y2 - entry->clip.y1,
+			   entry->clip.x1, entry->clip.y1);
+
+		if (previous_start) {
+			last_ms = div_u64(entry->start - previous_start,
+					  1000000);
+			seq_printf(s, ", %3u ms since last", last_ms);
+		}
+
+		if (entry->full && previous_full && last_ms)
+			seq_printf(s, ", %2u fps", 1000 / last_ms);
+
+		seq_puts(s, "\n");
+		previous_start = entry->start;
+		previous_full = entry->full;
+	}
+
+out_unlock:
+	mutex_unlock(&dirty->list_lock);
+
+	return 0;
+}
+
+static int tinydrm_debugfs_dirty_open(struct inode *inode, struct file *file)
+{
+	struct drm_info_node *node = inode->i_private;
+	struct drm_device *drm = node->minor->dev;
+	struct tinydrm_device *tdev = drm_to_tinydrm(drm);
+
+	return single_open(file, tinydrm_debugfs_dirty_seq_show,
+			   tdev->debugfs_dirty);
+}
+
+static void
+tinydrm_debugfs_dirty_list_delete(struct tinydrm_debugfs_dirty *dirty)
+{
+	struct tinydrm_dirty_entry *entry, *tmp;
+
+	list_for_each_entry_safe(entry, tmp, &dirty->list, list) {
+		list_del(&entry->list);
+		kfree(entry);
+	}
+}
+
+static ssize_t tinydrm_debugfs_dirty_write(struct file *file,
+					   const char __user *buf,
+					   size_t len, loff_t *ppos)
+{
+	struct tinydrm_debugfs_dirty *dirty;
+	struct tinydrm_dirty_entry *entry;
+	unsigned long long val;
+	char set_buf[24];
+	ssize_t ret = 0;
+	size_t size;
+	int i;
+
+	dirty = ((struct seq_file *)file->private_data)->private;
+	if (!dirty)
+		return -ENODEV;
+
+	size = min(sizeof(set_buf) - 1, len);
+	if (copy_from_user(set_buf, buf, size))
+		return -EFAULT;
+
+	set_buf[size] = '\0';
+	ret = kstrtoull(set_buf, 0, &val);
+	if (ret)
+		return ret;
+
+	if (val > MAX_DIRTY_ENTRIES)
+		return -ERANGE;
+
+	mutex_lock(&dirty->list_lock);
+
+	if (!list_empty(&dirty->list))
+		tinydrm_debugfs_dirty_list_delete(dirty);
+
+	for (i = 0; i < val; i++) {
+		entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+		if (!entry) {
+			tinydrm_debugfs_dirty_list_delete(dirty);
+			ret = -ENOMEM;
+			break;
+		}
+		list_add(&entry->list, &dirty->list);
+	}
+
+	mutex_unlock(&dirty->list_lock);
+
+	return ret < 0 ? ret : len;
+}
+
+static const struct file_operations tinydrm_debugfs_dirty_file_ops = {
+	.owner   = THIS_MODULE,
+	.open    = tinydrm_debugfs_dirty_open,
+	.read    = seq_read,
+	.write   = tinydrm_debugfs_dirty_write,
+	.llseek  = seq_lseek,
+	.release = single_release,
+};
+
+/*
+ * TODO
+ * Maybe drm_debugfs_cleanup() can use debugfs_remove_recursive() instead of
+ * debugfs_remove(minor->debugfs_root). Then this hack wouldn't be needed.
+ * armada, i915, nouveau and sti do similar things.
+ */
+static int tinydrm_debugfs_create_file(const char *name, umode_t mode,
+				       struct dentry *root,
+				       struct drm_minor *minor,
+				       const struct file_operations *fops)
+{
+	struct drm_info_node *node;
+	struct dentry *ent;
+
+	node = kmalloc(sizeof(*node), GFP_KERNEL);
+	if (!node)
+		return -ENOMEM;
+
+	ent = debugfs_create_file(name, mode, root, node, fops);
+	if (!ent) {
+		DRM_ERROR("Cannot create /sys/kernel/debug/dri/%s/%s\n",
+			  root->d_name.name, name);
+		kfree(node);
+		return -ENOMEM;
+	}
+
+	node->minor = minor;
+	node->dent = ent;
+	node->info_ent = (const void *)fops;
+
+	mutex_lock(&minor->debugfs_lock);
+	list_add(&node->list, &minor->debugfs_list);
+	mutex_unlock(&minor->debugfs_lock);
+
+	return 0;
+}
+
+static void tinydrm_debugfs_remove_file(struct drm_minor *minor,
+					const struct file_operations *fops)
+{
+	drm_debugfs_remove_files((struct drm_info_list *)fops, 1, minor);
+}
+
+static const struct drm_info_list tinydrm_debugfs_list[] = {
+	{ "fb",   drm_fb_cma_debugfs_show, 0 },
+};
+
+/**
+ * tinydrm_debugfs_init - Create debugfs entries
+ * @minor: DRM minor
+ *
+ * Drivers can use this as their &drm_driver->debugfs_init callback.
+ *
+ * Returns:
+ * Zero on success, negative error code on failure.
+ */
+int tinydrm_debugfs_init(struct drm_minor *minor)
+{
+	int ret;
+
+	ret = drm_debugfs_create_files(tinydrm_debugfs_list,
+				       ARRAY_SIZE(tinydrm_debugfs_list),
+				       minor->debugfs_root, minor);
+	if (ret)
+		return ret;
+
+	ret = tinydrm_debugfs_create_file("dirty", S_IRUGO | S_IWUSR,
+					  minor->debugfs_root, minor,
+					  &tinydrm_debugfs_dirty_file_ops);
+
+	return ret;
+}
+EXPORT_SYMBOL(tinydrm_debugfs_init);
+
+/**
+ * tinydrm_debugfs_cleanup - Cleanup debugfs entries
+ * @minor: DRM minor
+ *
+ * Drivers can use this as their &drm_driver->debugfs_cleanup callback.
+ */
+void tinydrm_debugfs_cleanup(struct drm_minor *minor)
+{
+	struct tinydrm_device *tdev = drm_to_tinydrm(minor->dev);
+
+	drm_debugfs_remove_files(tinydrm_debugfs_list,
+				 ARRAY_SIZE(tinydrm_debugfs_list), minor);
+	tinydrm_debugfs_remove_file(minor, &tinydrm_debugfs_dirty_file_ops);
+	if (tdev->debugfs_dirty) {
+		tinydrm_debugfs_dirty_list_delete(tdev->debugfs_dirty);
+		tdev->debugfs_dirty = NULL;
+	}
+}
+EXPORT_SYMBOL(tinydrm_debugfs_cleanup);
diff --git a/drivers/gpu/drm/tinydrm/core/tinydrm-fb.c b/drivers/gpu/drm/tinydrm/core/tinydrm-fb.c
new file mode 100644
index 0000000..3150754
--- /dev/null
+++ b/drivers/gpu/drm/tinydrm/core/tinydrm-fb.c
@@ -0,0 +1,182 @@
+/*
+ * Copyright (C) 2016 Noralf Tr√∏nnes
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <drm/drmP.h>
+#include <drm/drm_crtc.h>
+#include <drm/drm_fb_cma_helper.h>
+#include <drm/drm_fb_helper.h>
+#include <drm/tinydrm/tinydrm.h>
+
+/**
+ * DOC: Framebuffer
+ *
+ * The tinydrm &drm_framebuffer is backed by a &drm_gem_cma_object buffer
+ * object. Userspace creates this buffer by calling the
+ * DRM_IOCTL_MODE_CREATE_DUMB ioctl. To flush the buffer to the display,
+ * userpace calls the DRM_IOCTL_MODE_DIRTYFB ioctl on the framebuffer which
+ * in turn calls the &drm_framebuffer_funcs->dirty callback.
+ * This functionality is available by using tinydrm_fb_create() as the
+ * &drm_mode_config_funcs->fb_create callback which devm_tinydrm_init() does.
+ */
+
+static unsigned int fbdefio_delay;
+module_param(fbdefio_delay, uint, 0);
+MODULE_PARM_DESC(fbdefio_delay, "fbdev deferred io delay in milliseconds");
+
+/**
+ * tinydrm_check_dirty - check before flushing framebuffer
+ * @fb: framebuffer
+ * @clips: pointer to dirty clip rectangles array
+ * @num_clips: pointer to number of clips
+ *
+ * This function checks that the device is prepared and that @fb is the
+ * framebuffer set on the plane. If the device hasn't been enabled, which
+ * makes this the first flush, do flush everything.
+ * Caller has to hold the dev_lock.
+ *
+ * Returns:
+ * True if the dirty call can proceed, false otherwise.
+ */
+bool tinydrm_check_dirty(struct drm_framebuffer *fb,
+			 struct drm_clip_rect **clips, unsigned int *num_clips)
+{
+	struct tinydrm_device *tdev = drm_to_tinydrm(fb->dev);
+
+	if (!tdev->prepared)
+		return false;
+
+	/* fbdev can flush even when we're not interested */
+	if (tdev->pipe.plane.fb != fb)
+		return false;
+
+	/* Make sure to flush everything the first time */
+	if (!tdev->enabled) {
+		*clips = NULL;
+		*num_clips = 0;
+	}
+
+	return true;
+}
+EXPORT_SYMBOL(tinydrm_check_dirty);
+
+/**
+ * tinydrm_fb_create - tinydrm .fb_create() helper
+ * @drm: DRM device
+ * @file_priv: DRM file info
+ * @mode_cmd: metadata from the userspace fb creation request
+ *
+ * Helper for the &drm_mode_config_funcs->fb_create callback.
+ * It sets up a &drm_framebuffer backed by the &drm_gem_cma_object buffer
+ * object provided in @mode_cmd.
+ */
+struct drm_framebuffer *
+tinydrm_fb_create(struct drm_device *drm, struct drm_file *file_priv,
+		  const struct drm_mode_fb_cmd2 *mode_cmd)
+{
+	struct tinydrm_device *tdev = drm_to_tinydrm(drm);
+	struct drm_framebuffer *fb;
+
+	fb = drm_fb_cma_create_with_funcs(drm, file_priv, mode_cmd,
+					  tdev->fb_funcs);
+	if (!IS_ERR(fb))
+		DRM_DEBUG_KMS("[FB:%d] pixel_format: %s\n", fb->base.id,
+			      drm_get_format_name(fb->pixel_format));
+
+	return fb;
+}
+EXPORT_SYMBOL(tinydrm_fb_create);
+
+/**
+ * DOC: fbdev emulation
+ *
+ * tinydrm provides fbdev emulation using the drm_fb_cma_helper library.
+ * It is backed by it's own &drm_framebuffer and CMA buffer object.
+ * Framebuffer flushing is handled by the fb helper library which in turn
+ * calls the dirty callback on the framebuffer. This callback is part of
+ * &drm_framebuffer_funcs which is one of the arguments to devm_tinydrm_init().
+ * fbdev support is initialized using tinydrm_fbdev_init().
+ *
+ * The tinydrm_lastclose() function ensures that fbdev operation is restored
+ * when userspace closes the drm device.
+ */
+
+static int tinydrm_fbdev_create(struct drm_fb_helper *helper,
+				struct drm_fb_helper_surface_size *sizes)
+{
+	struct tinydrm_device *tdev = drm_to_tinydrm(helper->dev);
+	int ret;
+
+	ret = drm_fbdev_cma_create_with_funcs(helper, sizes, tdev->fb_funcs);
+	if (ret)
+		return ret;
+
+	strncpy(helper->fbdev->fix.id, helper->dev->driver->name, 16);
+	tdev->fbdev_helper = helper;
+
+	if (fbdefio_delay) {
+		unsigned long delay;
+
+		delay = msecs_to_jiffies(fbdefio_delay);
+		helper->fbdev->fbdefio->delay = delay ? delay : 1;
+	}
+
+	DRM_DEBUG_KMS("fbdev: [FB:%d] pixel_format=%s, fbdefio->delay=%ums\n",
+		      helper->fb->base.id,
+		      drm_get_format_name(helper->fb->pixel_format),
+		      jiffies_to_msecs(helper->fbdev->fbdefio->delay));
+
+	return 0;
+}
+
+static const struct drm_fb_helper_funcs tinydrm_fb_helper_funcs = {
+	.fb_probe = tinydrm_fbdev_create,
+};
+
+/**
+ * tinydrm_fbdev_init - initialize tinydrm fbdev emulation
+ * @tdev: tinydrm device
+ *
+ * Initialize tinydrm fbdev emulation. Tear down with tinydrm_fbdev_fini().
+ * If &mode_config->preferred_depth is set it is used as preferred bpp.
+ */
+int tinydrm_fbdev_init(struct tinydrm_device *tdev)
+{
+	struct drm_device *drm = &tdev->drm;
+	struct drm_fbdev_cma *fbdev;
+	int bpp;
+
+	DRM_DEBUG_KMS("\n");
+
+	bpp = drm->mode_config.preferred_depth;
+	fbdev = drm_fbdev_cma_init_with_funcs(drm, bpp ? bpp : 32,
+					      drm->mode_config.num_crtc,
+					      drm->mode_config.num_connector,
+					      &tinydrm_fb_helper_funcs);
+	if (IS_ERR(fbdev))
+		return PTR_ERR(fbdev);
+
+	tdev->fbdev_cma = fbdev;
+
+	return 0;
+}
+EXPORT_SYMBOL(tinydrm_fbdev_init);
+
+/**
+ * tinydrm_fbdev_fini - finalize tinydrm fbdev emulation
+ * @tdev: tinydrm device
+ *
+ * This function tears down the fbdev emulation
+ */
+void tinydrm_fbdev_fini(struct tinydrm_device *tdev)
+{
+	drm_fbdev_cma_fini(tdev->fbdev_cma);
+	tdev->fbdev_cma = NULL;
+	tdev->fbdev_helper = NULL;
+}
+EXPORT_SYMBOL(tinydrm_fbdev_fini);
diff --git a/drivers/gpu/drm/tinydrm/core/tinydrm-helpers.c b/drivers/gpu/drm/tinydrm/core/tinydrm-helpers.c
new file mode 100644
index 0000000..27683e9
--- /dev/null
+++ b/drivers/gpu/drm/tinydrm/core/tinydrm-helpers.c
@@ -0,0 +1,222 @@
+/*
+ * Copyright (C) 2016 Noralf Tr√∏nnes
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <drm/drmP.h>
+#include <drm/tinydrm/tinydrm.h>
+#include <linux/backlight.h>
+#include <linux/pm.h>
+#include <linux/spi/spi.h>
+
+/**
+ * tinydrm_merge_clips - merge clip rectangles
+ * @dst: destination clip rectangle
+ * @src: source clip rectangle(s)
+ * @num_clips: number of @src clip rectangles
+ * @flags: dirty fb ioctl flags
+ * @max_width: maximum width of @dst
+ * @max_height: maximum height of @dst
+ *
+ * This function merges @src clip rectangle(s) into @dst. If @src is NULL,
+ * @max_width and @min_width is used to set a full @dst clip rectangle.
+ */
+void tinydrm_merge_clips(struct drm_clip_rect *dst,
+			 struct drm_clip_rect *src, unsigned int num_clips,
+			 unsigned int flags, u32 max_width, u32 max_height)
+{
+	unsigned int i;
+
+	if (!src || !num_clips) {
+		dst->x1 = 0;
+		dst->x2 = max_width;
+		dst->y1 = 0;
+		dst->y2 = max_height;
+		return;
+	}
+
+	dst->x1 = ~0;
+	dst->y1 = ~0;
+	dst->x2 = 0;
+	dst->y2 = 0;
+
+	for (i = 0; i < num_clips; i++) {
+		if (flags & DRM_MODE_FB_DIRTY_ANNOTATE_COPY)
+			i++;
+		dst->x1 = min(dst->x1, src[i].x1);
+		dst->x2 = max(dst->x2, src[i].x2);
+		dst->y1 = min(dst->y1, src[i].y1);
+		dst->y2 = max(dst->y2, src[i].y2);
+	}
+
+	if (dst->x2 > max_width || dst->y2 > max_height ||
+	    dst->x1 >= dst->x2 || dst->y1 >= dst->y2) {
+		DRM_DEBUG_KMS("Illegal clip: x1=%u, x2=%u, y1=%u, y2=%u\n",
+			      dst->x1, dst->x2, dst->y1, dst->y2);
+		dst->x1 = 0;
+		dst->y1 = 0;
+		dst->x2 = max_width;
+		dst->y2 = max_height;
+	}
+}
+EXPORT_SYMBOL(tinydrm_merge_clips);
+
+/**
+ * tinydrm_xrgb8888_to_rgb565 - convert xrgb8888 to rgb565
+ * @src: xrgb8888 source buffer
+ * @dst: rgb565 destination buffer
+ * @num_pixels: number of pixels to copy
+ *
+ * Drivers can use this function for rgb565 devices that don't natively
+ * support xrgb8888.
+ */
+void tinydrm_xrgb8888_to_rgb565(u32 *src, u16 *dst, unsigned int num_pixels)
+{
+	int i;
+
+	for (i = 0; i < num_pixels; i++) {
+		*dst = ((*src & 0x00F80000) >> 8) |
+		       ((*src & 0x0000FC00) >> 5) |
+		       ((*src & 0x000000F8) >> 3);
+		src++;
+		dst++;
+	}
+}
+EXPORT_SYMBOL(tinydrm_xrgb8888_to_rgb565);
+
+#ifdef CONFIG_BACKLIGHT_CLASS_DEVICE
+/**
+ * tinydrm_of_find_backlight - find backlight device in device-tree
+ * @dev: device
+ *
+ * This function looks for a DT node pointed to by a property named 'backlight'
+ * and uses of_find_backlight_by_node() to get the backlight device.
+ * Additionally if the brightness property is zero, it is set to
+ * max_brightness.
+ *
+ * Returns:
+ * NULL if there's no backlight property.
+ * Error pointer -EPROBE_DEFER if the DT node is found, but no backlight device
+ * is found.
+ * If the backlight device is found, a pointer to the structure is returned.
+ */
+struct backlight_device *tinydrm_of_find_backlight(struct device *dev)
+{
+	struct backlight_device *backlight;
+	struct device_node *np;
+
+	np = of_parse_phandle(dev->of_node, "backlight", 0);
+	if (!np)
+		return NULL;
+
+	backlight = of_find_backlight_by_node(np);
+	of_node_put(np);
+
+	if (!backlight)
+		return ERR_PTR(-EPROBE_DEFER);
+
+	if (!backlight->props.brightness) {
+		backlight->props.brightness = backlight->props.max_brightness;
+		DRM_DEBUG_KMS("Backlight brightness set to %d\n",
+			      backlight->props.brightness);
+	}
+
+	return backlight;
+}
+EXPORT_SYMBOL(tinydrm_of_find_backlight);
+
+/**
+ * tinydrm_enable_backlight - enable backlight helper
+ * @backlight: backlight device
+ *
+ * Helper to enable backlight for use in &tinydrm_funcs ->enable callback
+ * functions.
+ */
+int tinydrm_enable_backlight(struct backlight_device *backlight)
+{
+	unsigned int old_state;
+
+	if (!backlight)
+		return 0;
+
+	old_state = backlight->props.state;
+	backlight->props.state &= ~BL_CORE_SUSPENDED;
+	DRM_DEBUG_KMS("Backlight state: 0x%x -> 0x%x\n", old_state,
+		      backlight->props.state);
+
+	return backlight_update_status(backlight);
+}
+EXPORT_SYMBOL(tinydrm_enable_backlight);
+
+/**
+ * tinydrm_disable_backlight - disable backlight helper
+ * @backlight: backlight device
+ *
+ * Helper to disable backlight for use in &tinydrm_funcs ->disable callback
+ * functions.
+ */
+void tinydrm_disable_backlight(struct backlight_device *backlight)
+{
+	unsigned int old_state;
+	int ret;
+
+	if (!backlight)
+		return;
+
+	old_state = backlight->props.state;
+	backlight->props.state |= BL_CORE_SUSPENDED;
+	DRM_DEBUG_KMS("Backlight state: 0x%x -> 0x%x\n", old_state,
+		      backlight->props.state);
+	ret = backlight_update_status(backlight);
+	if (ret)
+		DRM_ERROR("Failed to disable backlight %d\n", ret);
+}
+EXPORT_SYMBOL(tinydrm_disable_backlight);
+#endif
+
+static int __maybe_unused tinydrm_pm_suspend(struct device *dev)
+{
+	struct tinydrm_device *tdev = dev_get_drvdata(dev);
+
+	return tdev ? tinydrm_suspend(tdev) : -EINVAL;
+}
+
+static int __maybe_unused tinydrm_pm_resume(struct device *dev)
+{
+	struct tinydrm_device *tdev = dev_get_drvdata(dev);
+
+	return tdev ? tinydrm_resume(tdev) : -EINVAL;
+}
+
+/*
+ * tinydrm_simple_pm_ops - tinydrm simple power management operations
+ *
+ * This provides simple suspend/resume power management and can be assigned
+ * to the drivers &device_driver->pm property. &tinydrm_device must be set
+ * on the device using dev_set_drvdata() or equivalent.
+ */
+const struct dev_pm_ops tinydrm_simple_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(tinydrm_pm_suspend, tinydrm_pm_resume)
+};
+EXPORT_SYMBOL(tinydrm_simple_pm_ops);
+
+/**
+ * tinydrm_spi_shutdown - SPI driver shutdown callback helper
+ * @spi: SPI device
+ *
+ * This is a helper function for the &spi_driver ->shutdown callback which
+ * makes sure that the tinydrm device is disabled and unprepared on shutdown.
+ * &tinydrm_device must be set on the device using spi_set_drvdata().
+ */
+void tinydrm_spi_shutdown(struct spi_device *spi)
+{
+	struct tinydrm_device *tdev = spi_get_drvdata(spi);
+
+	if (tdev)
+		tinydrm_shutdown(tdev);
+}
+EXPORT_SYMBOL(tinydrm_spi_shutdown);
diff --git a/drivers/gpu/drm/tinydrm/core/tinydrm-pipe.c b/drivers/gpu/drm/tinydrm/core/tinydrm-pipe.c
new file mode 100644
index 0000000..0751208
--- /dev/null
+++ b/drivers/gpu/drm/tinydrm/core/tinydrm-pipe.c
@@ -0,0 +1,247 @@
+/*
+ * Copyright (C) 2016 Noralf Tr√∏nnes
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <drm/drmP.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_fb_helper.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_simple_kms_helper.h>
+#include <drm/tinydrm/tinydrm.h>
+
+struct tinydrm_connector {
+	struct drm_connector base;
+	const struct drm_display_mode *mode;
+};
+
+static inline struct tinydrm_connector *
+to_tinydrm_connector(struct drm_connector *connector)
+{
+	return container_of(connector, struct tinydrm_connector, base);
+}
+
+static int tinydrm_connector_get_modes(struct drm_connector *connector)
+{
+	struct tinydrm_connector *tconn = to_tinydrm_connector(connector);
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, tconn->mode);
+	if (!mode) {
+		DRM_ERROR("Failed to duplicate mode\n");
+		return 0;
+	}
+
+	if (mode->name[0] == '\0')
+		drm_mode_set_name(mode);
+
+	mode->type |= DRM_MODE_TYPE_PREFERRED;
+	drm_mode_probed_add(connector, mode);
+
+	if (mode->width_mm) {
+		connector->display_info.width_mm = mode->width_mm;
+		connector->display_info.height_mm = mode->height_mm;
+	}
+
+	return 1;
+}
+
+static const struct drm_connector_helper_funcs tinydrm_connector_hfuncs = {
+	.get_modes = tinydrm_connector_get_modes,
+	.best_encoder = drm_atomic_helper_best_encoder,
+};
+
+static enum drm_connector_status
+tinydrm_connector_detect(struct drm_connector *connector, bool force)
+{
+	if (drm_device_is_unplugged(connector->dev))
+		return connector_status_disconnected;
+
+	return connector->status;
+}
+
+static void tinydrm_connector_destroy(struct drm_connector *connector)
+{
+	struct tinydrm_connector *tconn = to_tinydrm_connector(connector);
+
+	drm_connector_cleanup(connector);
+	kfree(tconn);
+}
+
+static const struct drm_connector_funcs tinydrm_connector_funcs = {
+	.dpms = drm_atomic_helper_connector_dpms,
+	.reset = drm_atomic_helper_connector_reset,
+	.detect = tinydrm_connector_detect,
+	.fill_modes = drm_helper_probe_single_connector_modes,
+	.destroy = tinydrm_connector_destroy,
+	.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
+};
+
+/**
+ * tinydrm_connector_create - Create simple connector
+ * @drm: DRM device
+ * @mode: Supported display mode
+ * @connector_type: Connector type
+ * @dirty_prop: Whether or not to create a dirty property on the connector
+ *
+ * This function creates a simple &drm_connector with one fixed
+ * &drm_display_mode.
+ *
+ * Returns:
+ * DRM connector on success, error pointer on failure.
+ */
+struct drm_connector *
+tinydrm_connector_create(struct drm_device *drm,
+			 const struct drm_display_mode *mode,
+			 int connector_type)
+{
+	struct tinydrm_connector *tconn;
+	struct drm_connector *connector;
+	int ret;
+
+	tconn = kzalloc(sizeof(*tconn), GFP_KERNEL);
+	if (!tconn)
+		return ERR_PTR(-ENOMEM);
+
+	tconn->mode = mode;
+	connector = &tconn->base;
+
+	drm_connector_helper_add(connector, &tinydrm_connector_hfuncs);
+	ret = drm_connector_init(drm, connector, &tinydrm_connector_funcs,
+				 connector_type);
+	if (ret) {
+		kfree(tconn);
+		return ERR_PTR(ret);
+	}
+
+	connector->status = connector_status_connected;
+
+	return connector;
+}
+EXPORT_SYMBOL(tinydrm_connector_create);
+
+/**
+ * tinydrm_display_pipe_update - Display pipe update helper
+ * @pipe: Simple display pipe
+ * @old_state: Old plane state
+ *
+ * This function schedules a full framebuffer flush if the plane framebuffer
+ * has changed. It also detects if fbdev is being used.
+ * Drivers can use this as their &drm_simple_display_pipe_funcs->update
+ * callback.
+ */
+void tinydrm_display_pipe_update(struct drm_simple_display_pipe *pipe,
+				 struct drm_plane_state *old_state)
+{
+	struct tinydrm_device *tdev = pipe_to_tinydrm(pipe);
+	struct drm_framebuffer *fb = pipe->plane.state->fb;
+	struct drm_crtc *crtc = &tdev->pipe.crtc;
+
+	if (!fb)
+		DRM_DEBUG_KMS("fb unset\n");
+	else if (fb != old_state->fb)
+		DRM_DEBUG_KMS("fb changed\n");
+	else
+		DRM_DEBUG_KMS("No fb change\n");
+
+	if (fb && (fb != old_state->fb)) {
+		struct tinydrm_device *tdev = pipe_to_tinydrm(pipe);
+
+		pipe->plane.fb = fb;
+		schedule_work(&tdev->dirty_work);
+	}
+
+	if (crtc->state->event) {
+		DRM_DEBUG_KMS("crtc event\n");
+		spin_lock_irq(&crtc->dev->event_lock);
+		drm_crtc_send_vblank_event(crtc, crtc->state->event);
+		spin_unlock_irq(&crtc->dev->event_lock);
+		crtc->state->event = NULL;
+	}
+
+	if (tdev->fbdev_helper && fb == tdev->fbdev_helper->fb)
+		tdev->fbdev_used = true;
+}
+EXPORT_SYMBOL(tinydrm_display_pipe_update);
+
+static int tinydrm_rotate_mode(struct drm_display_mode *mode,
+			       unsigned int rotation)
+{
+	if (rotation == 0 || rotation == 180) {
+		return 0;
+	} else if (rotation == 90 || rotation == 270) {
+		swap(mode->hdisplay, mode->vdisplay);
+		swap(mode->hsync_start, mode->vsync_start);
+		swap(mode->hsync_end, mode->vsync_end);
+		swap(mode->htotal, mode->vtotal);
+		swap(mode->width_mm, mode->height_mm);
+		return 0;
+	} else {
+		return -EINVAL;
+	}
+}
+
+/**
+ * tinydrm_display_pipe_init - Initialize display pipe
+ * @tdev: tinydrm device
+ * @funcs: Display pipe functions
+ * @connector_type: Connector type
+ * @formats: Array of supported formats (%DRM_FORMAT_*)
+ * @format_count: Number of elements in @formats
+ * @mode: Supported mode
+ * @rotation: Initial @mode rotation in degrees Counter Clock Wise
+ *
+ * This function sets up a &drm_simple_display_pipe with a &drm_connector that
+ * has one fixed &drm_display_mode which is rotated according to @rotation.
+ *
+ * Returns:
+ * Zero on success, negative error code on failure.
+ */
+int
+tinydrm_display_pipe_init(struct tinydrm_device *tdev,
+			  const struct drm_simple_display_pipe_funcs *funcs,
+			  int connector_type,
+			  const uint32_t *formats,
+			  unsigned int format_count,
+			  const struct drm_display_mode *mode,
+			  unsigned int rotation)
+{
+	struct drm_device *drm = &tdev->drm;
+	struct drm_display_mode *mode_copy;
+	struct drm_connector *connector;
+	int ret;
+
+	mode_copy = devm_kmalloc(drm->dev, sizeof(*mode_copy), GFP_KERNEL);
+	if (!mode_copy)
+		return -ENOMEM;
+
+	*mode_copy = *mode;
+	ret = tinydrm_rotate_mode(mode_copy, rotation);
+	if (ret) {
+		DRM_ERROR("Illegal rotation value %u\n", rotation);
+		return -EINVAL;
+	}
+
+	drm->mode_config.min_width = mode_copy->hdisplay;
+	drm->mode_config.max_width = mode_copy->hdisplay;
+	drm->mode_config.min_height = mode_copy->vdisplay;
+	drm->mode_config.max_height = mode_copy->vdisplay;
+
+	connector = tinydrm_connector_create(drm, mode_copy, connector_type);
+	if (IS_ERR(connector))
+		return PTR_ERR(connector);
+
+	ret = drm_simple_display_pipe_init(drm, &tdev->pipe, funcs, formats,
+					   format_count, connector);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+EXPORT_SYMBOL(tinydrm_display_pipe_init);
diff --git a/drivers/gpu/drm/tinydrm/core/tinydrm-regmap.c b/drivers/gpu/drm/tinydrm/core/tinydrm-regmap.c
new file mode 100644
index 0000000..15a879c
--- /dev/null
+++ b/drivers/gpu/drm/tinydrm/core/tinydrm-regmap.c
@@ -0,0 +1,326 @@
+#define DEBUG
+/*
+ * Copyright (C) 2016 Noralf Tr√∏nnes
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <drm/drmP.h>
+#include <drm/tinydrm/tinydrm.h>
+#include <drm/tinydrm/tinydrm-helpers.h>
+#include <drm/tinydrm/tinydrm-regmap.h>
+#include <linux/module.h>
+#include <linux/regmap.h>
+#include <linux/spi/spi.h>
+
+static unsigned int spi_max;
+module_param(spi_max, uint, 0400);
+MODULE_PARM_DESC(spi_max, "Set a lower SPI max transfer size");
+
+/**
+ * tinydrm_regmap_flush_rgb565 - flush framebuffer to LCD register
+ * @reg: LCD register map
+ * @regnr: register number
+ * @fb: framebuffer
+ * @vmem: buffer backing the framebuffer
+ * @clip: part of buffer to write
+ *
+ * Flush framebuffer changes to LCD register supporting RGB565. XRGB8888 is
+ * converted to RGB565.
+ */
+int tinydrm_regmap_flush_rgb565(struct regmap *reg, u32 regnr,
+				struct drm_framebuffer *fb, void *vmem,
+				struct drm_clip_rect *clip)
+{
+	unsigned int width = clip->x2 - clip->x1;
+	unsigned int height = clip->y2 - clip->y1;
+	unsigned int num_pixels = width * height;
+	u16 *tr, *buf = NULL;
+	int ret;
+
+	/*
+	 * TODO: Add support for all widths (requires a buffer copy)
+	 *
+	 * Crude X windows usage numbers for a 320x240 (76.8k pixel) display,
+	 * possible improvements:
+	 * - 80-90% cut for <2k pixel transfers
+	 * - 40-50% cut for <50k pixel tranfers
+	 */
+	if (width != fb->width) {
+		dev_err(fb->dev->dev,
+			"Only full width clip are supported: x1=%u, x2=%u\n",
+			clip->x1, clip->x2);
+		return -EINVAL;
+	}
+
+	switch (fb->pixel_format) {
+	case DRM_FORMAT_RGB565:
+		vmem += clip->y1 * width * 2;
+		tr = vmem;
+		break;
+	case DRM_FORMAT_XRGB8888:
+		vmem += clip->y1 * width * 4;
+		buf = kmalloc_array(num_pixels, sizeof(u16), GFP_KERNEL);
+		if (!buf)
+			return -ENOMEM;
+
+		tinydrm_xrgb8888_to_rgb565(vmem, buf, num_pixels);
+		tr = buf;
+		break;
+	default:
+		dev_err_once(fb->dev->dev, "Format is not supported: %s\n",
+			     drm_get_format_name(fb->pixel_format));
+		return -EINVAL;
+	}
+
+	ret = regmap_raw_write(reg, regnr, tr, num_pixels * 2);
+	kfree(buf);
+
+	return ret;
+}
+EXPORT_SYMBOL(tinydrm_regmap_flush_rgb565);
+
+#if IS_ENABLED(CONFIG_SPI)
+
+/**
+ * tinydrm_spi_max_transfer_size - Determine max SPI transfer size
+ * @spi: SPI device
+ * @max_len: Maximum buffer size needed (optional)
+ *
+ * This function returns the maximum size to use for SPI transfers. It checks
+ * the SPI master, the optional @max_len and the module parameter spi_max and
+ * returns the smallest.
+ *
+ * Returns:
+ * Maximum size for SPI transfers
+ */
+size_t tinydrm_spi_max_transfer_size(struct spi_device *spi, size_t max_len)
+{
+	size_t ret;
+
+	ret = min(spi_max_transfer_size(spi), spi->master->max_dma_len);
+	DRM_INFO("Max SPI transfer size: %zu\n", ret);
+	if (max_len)
+		ret = min(ret, max_len);
+	if (spi_max)
+		ret = min_t(size_t, ret, spi_max);
+	ret &= ~0x3;
+	if (ret < 4)
+		ret = 4;
+
+	DRM_DEBUG_DRIVER("Max SPI transfer size: %zu\n", ret);
+
+	return ret;
+}
+EXPORT_SYMBOL(tinydrm_spi_max_transfer_size);
+
+/**
+ * tinydrm_spi_bpw_supported - Check if bits per word is supported
+ * @spi: SPI device
+ * @bpw: Bits per word
+ *
+ * This function checks to see if the SPI master driver supports @bpw.
+ *
+ * Returns:
+ * True if @bpw is supported, false otherwise.
+ */
+bool tinydrm_spi_bpw_supported(struct spi_device *spi, u8 bpw)
+{
+	u32 bpw_mask = spi->master->bits_per_word_mask;
+
+	if (bpw == 8)
+		return true;
+
+	if (!bpw_mask) {
+		dev_warn_once(&spi->dev,
+			      "bits_per_word_mask not set, assume only 8\n");
+		return false;
+	}
+
+	if (bpw_mask & SPI_BPW_MASK(bpw))
+		return true;
+
+	return false;
+}
+EXPORT_SYMBOL(tinydrm_spi_bpw_supported);
+
+/* hexdump that can do u16, useful on little endian where bytes are swapped */
+static void tinydrm_hexdump(char *linebuf, size_t linebuflen, const void *buf,
+			    size_t len, size_t bpw, size_t max)
+{
+	if (bpw > 16) {
+		snprintf(linebuf, linebuflen, "bpw not supported");
+	} else if (bpw > 8) {
+		size_t count = len > max ? max / 2 : (len / 2);
+		const u16 *buf16 = buf;
+		unsigned int j, lx = 0;
+		int ret;
+
+		for (j = 0; j < count; j++) {
+			ret = snprintf(linebuf + lx, linebuflen - lx,
+				       "%s%4.4x", j ? " " : "", *buf16++);
+			if (ret >= linebuflen - lx) {
+				snprintf(linebuf, linebuflen, "ERROR");
+				break;
+			}
+			lx += ret;
+		}
+	} else {
+		hex_dump_to_buffer(buf, len, max, 1, linebuf, linebuflen,
+				   false);
+	}
+}
+
+/* called through TINYDRM_DEBUG_REG_WRITE() */
+void tinydrm_debug_reg_write(const void *reg, size_t reg_len, const void *val,
+			     size_t val_len, size_t val_width)
+{
+	unsigned int regnr;
+
+	if (reg_len != 1 && reg_len != 2)
+		return;
+
+	regnr = (reg_len == 1) ? *(u8 *)reg : *(u16 *)reg;
+
+	if (val && val_len) {
+		char linebuf[3 * 32];
+
+		tinydrm_hexdump(linebuf, ARRAY_SIZE(linebuf), val, val_len,
+				val_width, 16);
+		drm_printk(KERN_DEBUG, DRM_UT_CORE,
+			   "regnr=0x%0*x, data(%zu)= %s%s\n",
+			   reg_len == 1 ? 2 : 4, regnr,
+			   val_len, linebuf, val_len > 32 ? " ..." : "");
+	} else {
+		drm_printk(KERN_DEBUG, DRM_UT_CORE,
+			   "regnr=0x%0*x\n",
+			   reg_len == 1 ? 2 : 4, regnr);
+	}
+}
+EXPORT_SYMBOL(tinydrm_debug_reg_write);
+
+/* called through tinydrm_dbg_spi_message() */
+void _tinydrm_dbg_spi_message(struct spi_device *spi, struct spi_message *m)
+{
+	struct spi_master *master = spi->master;
+	struct spi_transfer *tmp;
+	struct list_head *pos;
+	char linebuf[3 * 32];
+	int i = 0;
+
+	list_for_each(pos, &m->transfers) {
+		tmp = list_entry(pos, struct spi_transfer, transfer_list);
+
+		if (tmp->tx_buf) {
+			bool dma = false;
+
+			if (master->can_dma)
+				dma = master->can_dma(master, spi, tmp);
+
+			tinydrm_hexdump(linebuf, ARRAY_SIZE(linebuf),
+					tmp->tx_buf, tmp->len,
+					tmp->bits_per_word, 16);
+			printk(KERN_DEBUG "    tr[%i]: bpw=%i, dma=%u, len=%u, tx_buf(%p)=[%s%s]\n",
+			       i, tmp->bits_per_word, dma, tmp->len,
+			       tmp->tx_buf, linebuf,
+			       tmp->len > 16 ? " ..." : "");
+		}
+		if (tmp->rx_buf) {
+			tinydrm_hexdump(linebuf, ARRAY_SIZE(linebuf),
+					tmp->rx_buf, tmp->len,
+					tmp->bits_per_word, 16);
+			printk(KERN_DEBUG "    tr[%i]: bpw=%i,        len=%u, rx_buf(%p)=[%s%s]\n",
+			       i, tmp->bits_per_word, tmp->len, tmp->rx_buf,
+			       linebuf, tmp->len > 16 ? " ..." : "");
+		}
+		i++;
+	}
+}
+EXPORT_SYMBOL(_tinydrm_dbg_spi_message);
+
+/**
+ * tinydrm_spi_transfer - SPI transfer helper
+ * @spi: SPI device
+ * @speed_hz: Override speed (optional)
+ * @header: Optional header transfer
+ * @bpw: Bits per word
+ * @buf: Buffer to transfer
+ * @len: Buffer length
+ * @swap_buf: Swap buffer used on Little Endian when 16 bpw is not supported
+ * @max_chunk: Break up buffer into chunks of this size
+ *
+ * This SPI transfer helper breaks up the transfer of @buf into @max_chunk
+ * chunks. If the machine is Little Endian and the SPI master driver doesn't
+ * support @bpw=16, it swaps the bytes using @swap_buf and does a 8-bit
+ * transfer. If @header is set, it is prepended to each SPI message.
+ *
+ * Returns:
+ * Zero on success, negative error code on failure.
+ */
+int tinydrm_spi_transfer(struct spi_device *spi, u32 speed_hz,
+			 struct spi_transfer *header, u8 bpw, const void *buf,
+			 size_t len, u16 *swap_buf, size_t max_chunk)
+{
+	struct spi_transfer tr = {
+		.bits_per_word = bpw,
+		.speed_hz = speed_hz,
+	};
+	struct spi_message m;
+	bool swap = false;
+	size_t chunk;
+	int ret = 0;
+
+	if (WARN_ON_ONCE(bpw != 8 && bpw != 16))
+		return -EINVAL;
+
+	if (drm_debug & DRM_UT_CORE)
+		pr_debug("[drm:%s] bpw=%u, max_chunk=%zu, transfers:\n",
+			 __func__, bpw, max_chunk);
+
+	if (tinydrm_get_machine_endian() == REGMAP_ENDIAN_LITTLE &&
+	    bpw == 16 && !tinydrm_spi_bpw_supported(spi, 16)) {
+		if (!swap_buf)
+			return -EINVAL;
+
+		swap = true;
+		tr.bits_per_word = 8;
+	}
+
+	spi_message_init(&m);
+	if (header)
+		spi_message_add_tail(header, &m);
+	spi_message_add_tail(&tr, &m);
+
+	while (len) {
+		chunk = min(len, max_chunk);
+
+		tr.tx_buf = buf;
+		tr.len = chunk;
+
+		if (swap) {
+			const u16 *buf16 = buf;
+			unsigned int i;
+
+			for (i = 0; i < chunk / 2; i++)
+				swap_buf[i] = swab16(buf16[i]);
+
+			tr.tx_buf = swap_buf;
+		}
+
+		buf += chunk;
+		len -= chunk;
+
+		tinydrm_dbg_spi_message(spi, &m);
+		ret = spi_sync(spi, &m);
+		if (ret)
+			return ret;
+	};
+
+	return 0;
+}
+EXPORT_SYMBOL(tinydrm_spi_transfer);
+
+#endif /* CONFIG_SPI */
diff --git a/drivers/gpu/drm/tinydrm/mi0283qt.c b/drivers/gpu/drm/tinydrm/mi0283qt.c
new file mode 100644
index 0000000..aca2a04
--- /dev/null
+++ b/drivers/gpu/drm/tinydrm/mi0283qt.c
@@ -0,0 +1,310 @@
+#define DEBUG
+
+/*
+ * DRM driver for Multi-Inno MI0283QT panels
+ *
+ * Copyright 2016 Noralf Tr√∏nnes
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+/* TODO: DT binding
+
+of: Add vendor prefix for Multi-Inno
+Multi-Inno Technology Co.,Ltd is a Hong Kong based company offering
+LCD, LCD module products and complete panel solutions.
+
+Documentation/devicetree/bindings/vendor-prefixes.txt
+-------------------------------------------------------------------------------
+multi-inno	Multi-Inno Technology Co.,Ltd
+-------------------------------------------------------------------------------
+
+dt-bindings: Add Multi-Inno MI0283QT binding
+Add device-tree binding documentation for the MI0283QT display panel.
+
+Documentation/devicetree/bindings/display/multi-inno,mi0283qt.txt
+-------------------------------------------------------------------------------
+Multi-Inno MI0283QT display panel
+
+Required properties:
+- compatible:	"multi-inno,mi0283qt".
+
+The node for this driver must be a child node of a SPI controller, hence
+all mandatory properties described in ../spi/spi-bus.txt must be specified.
+
+Optional properties:
+- dc-gpios:	D/C pin. The presence/absence of this GPIO determines
+		the panel interface mode (IM[3:0] pins):
+		- present: IM=x110 4-wire 8-bit data serial interface
+		- absent:  IM=x101 3-wire 9-bit data serial interface
+- reset-gpios:	Reset pin
+- power-supply:	A regulator node for the supply voltage.
+- backlight:	phandle of the backlight device attached to the panel
+- rotation:	panel rotation in degrees counter clockwise (0,90,180,270)
+- write-only:	LCD controller is write only. This depends on the interface
+		mode, SPI master driver and wiring:
+		- IM=11xx and MISO not connected
+		- IM=01xx and SPI master driver doesn't support spi-3wire (SDA)
+
+Example:
+	mi0283qt@0{
+		compatible = "multi-inno,mi0283qt";
+		reg = <0>;
+		spi-max-frequency = <32000000>;
+		rotation = <90>;
+		dc-gpios = <&gpio 25 0>;
+		backlight = <&backlight>;
+	};
+-------------------------------------------------------------------------------
+*/
+
+#include <drm/tinydrm/ili9341.h>
+#include <drm/tinydrm/mipi-dbi.h>
+#include <drm/tinydrm/tinydrm.h>
+#include <drm/tinydrm/tinydrm-helpers.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/property.h>
+#include <linux/regulator/consumer.h>
+#include <linux/spi/spi.h>
+#include <video/mipi_display.h>
+
+static void mi0283qt_enable(struct drm_simple_display_pipe *pipe,
+			    struct drm_crtc_state *crtc_state)
+{
+	struct tinydrm_device *tdev = pipe_to_tinydrm(pipe);
+	struct mipi_dbi *mipi = mipi_dbi_from_tinydrm(tdev);
+	struct device *dev = tdev->drm.dev;
+	struct regmap *reg = mipi->reg;
+	u8 addr_mode;
+	int ret;
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	mutex_lock(&tdev->dev_lock);
+
+	if (tdev->prepared)
+		goto out_unlock;
+
+	if (mipi->regulator) {
+		ret = regulator_enable(mipi->regulator);
+		if (ret) {
+			dev_err(dev, "Failed to enable regulator %d\n", ret);
+			goto out_unlock;
+		}
+	}
+
+	/* Avoid flicker by skipping setup if the bootloader has done it */
+	if (mipi_dbi_display_is_on(reg)) {
+		tdev->prepared = true;
+		goto out_unlock;
+	}
+
+	mipi_dbi_hw_reset(mipi);
+	ret = mipi_dbi_write(reg, MIPI_DCS_SOFT_RESET);
+	if (ret) {
+		dev_err(dev, "Error writing command %d\n", ret);
+		goto out_unlock;
+	}
+
+	msleep(20);
+
+	mipi_dbi_write(reg, MIPI_DCS_SET_DISPLAY_OFF);
+
+	mipi_dbi_write(reg, ILI9341_PWCTRLB, 0x00, 0x83, 0x30);
+	mipi_dbi_write(reg, ILI9341_PWRSEQ, 0x64, 0x03, 0x12, 0x81);
+	mipi_dbi_write(reg, ILI9341_DTCTRLA, 0x85, 0x01, 0x79);
+	mipi_dbi_write(reg, ILI9341_PWCTRLA, 0x39, 0x2c, 0x00, 0x34, 0x02);
+	mipi_dbi_write(reg, ILI9341_PUMPCTRL, 0x20);
+	mipi_dbi_write(reg, ILI9341_DTCTRLB, 0x00, 0x00);
+
+	/* Power Control */
+	mipi_dbi_write(reg, ILI9341_PWCTRL1, 0x26);
+	mipi_dbi_write(reg, ILI9341_PWCTRL2, 0x11);
+	/* VCOM */
+	mipi_dbi_write(reg, ILI9341_VMCTRL1, 0x35, 0x3e);
+	mipi_dbi_write(reg, ILI9341_VMCTRL2, 0xbe);
+
+	/* Memory Access Control */
+	mipi_dbi_write(reg, MIPI_DCS_SET_PIXEL_FORMAT, 0x55);
+
+	switch (mipi->rotation) {
+	default:
+		addr_mode = ILI9341_MADCTL_MV | ILI9341_MADCTL_MY |
+			    ILI9341_MADCTL_MX;
+		break;
+	case 90:
+		addr_mode = ILI9341_MADCTL_MY;
+		break;
+	case 180:
+		addr_mode = ILI9341_MADCTL_MV;
+		break;
+	case 270:
+		addr_mode = ILI9341_MADCTL_MX;
+		break;
+	}
+	addr_mode |= ILI9341_MADCTL_BGR;
+	mipi_dbi_write(reg, MIPI_DCS_SET_ADDRESS_MODE, addr_mode);
+
+	/* Frame Rate */
+	mipi_dbi_write(reg, ILI9341_FRMCTR1, 0x00, 0x1b);
+
+	/* Gamma */
+	mipi_dbi_write(reg, ILI9341_EN3GAM, 0x08);
+	mipi_dbi_write(reg, MIPI_DCS_SET_GAMMA_CURVE, 0x01);
+	mipi_dbi_write(reg, ILI9341_PGAMCTRL,
+		       0x1f, 0x1a, 0x18, 0x0a, 0x0f, 0x06, 0x45, 0x87,
+		       0x32, 0x0a, 0x07, 0x02, 0x07, 0x05, 0x00);
+	mipi_dbi_write(reg, ILI9341_NGAMCTRL,
+		       0x00, 0x25, 0x27, 0x05, 0x10, 0x09, 0x3a, 0x78,
+		       0x4d, 0x05, 0x18, 0x0d, 0x38, 0x3a, 0x1f);
+
+	/* DDRAM */
+	mipi_dbi_write(reg, ILI9341_ETMOD, 0x07);
+
+	/* Display */
+	mipi_dbi_write(reg, ILI9341_DISCTRL, 0x0a, 0x82, 0x27, 0x00);
+	mipi_dbi_write(reg, MIPI_DCS_EXIT_SLEEP_MODE);
+	msleep(100);
+
+	mipi_dbi_write(reg, MIPI_DCS_SET_DISPLAY_ON);
+	msleep(100);
+
+	tdev->prepared = true;
+	if (pipe->plane.state->fb)
+		schedule_work(&tdev->dirty_work);
+
+out_unlock:
+	mutex_unlock(&tdev->dev_lock);
+}
+
+static const struct drm_simple_display_pipe_funcs mi0283qt_pipe_funcs = {
+	.enable = mi0283qt_enable,
+	.disable = mipi_dbi_pipe_disable,
+	.update = tinydrm_display_pipe_update,
+};
+
+static const struct drm_display_mode mi0283qt_mode = {
+	TINYDRM_MODE(320, 240, 58, 43),
+};
+
+static const struct of_device_id mi0283qt_of_match[] = {
+	{ .compatible = "multi-inno,mi0283qt" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, mi0283qt_of_match);
+
+static const struct spi_device_id mi0283qt_id[] = {
+	{ "mi0283qt", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(spi, mi0283qt_id);
+
+static struct drm_driver mi0283qt_driver = {
+	.driver_features	= DRIVER_GEM | DRIVER_MODESET | DRIVER_PRIME |
+				  DRIVER_ATOMIC,
+	TINYDRM_GEM_DRIVER_OPS,
+	.lastclose		= tinydrm_lastclose,
+	.debugfs_init		= mipi_dbi_debugfs_init,
+	.debugfs_cleanup	= mipi_dbi_debugfs_cleanup,
+	.name			= "mi0283qt",
+	.desc			= "Multi-Inno MI0283QT",
+	.date			= "20160614",
+	.major			= 1,
+	.minor			= 0,
+};
+
+static int mi0283qt_probe(struct spi_device *spi)
+{
+	struct device *dev = &spi->dev;
+	struct tinydrm_device *tdev;
+	struct mipi_dbi *mipi;
+	struct gpio_desc *dc;
+	u32 rotation = 0;
+	bool writeonly;
+	int ret;
+
+	if (!dev->coherent_dma_mask) {
+		ret = dma_coerce_mask_and_coherent(dev, DMA_BIT_MASK(32));
+		if (ret)
+			dev_warn(dev, "Failed to set dma mask %d\n", ret);
+	}
+
+	mipi = devm_kzalloc(dev, sizeof(*mipi), GFP_KERNEL);
+	if (!mipi)
+		return -ENOMEM;
+
+	mipi->reset = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(mipi->reset)) {
+		dev_err(dev, "Failed to get gpio 'reset'\n");
+		return PTR_ERR(mipi->reset);
+	}
+
+	dc = devm_gpiod_get_optional(dev, "dc", GPIOD_OUT_LOW);
+	if (IS_ERR(dc)) {
+		dev_err(dev, "Failed to get gpio 'dc'\n");
+		return PTR_ERR(dc);
+	}
+
+	mipi->regulator = devm_regulator_get_optional(dev, "power");
+	if (IS_ERR(mipi->regulator)) {
+		ret = PTR_ERR(mipi->regulator);
+		if (ret != -ENODEV)
+			return ret;
+
+		mipi->regulator = NULL;
+	}
+
+	mipi->enable_delay_ms = 50;
+	mipi->backlight = tinydrm_of_find_backlight(dev);
+	if (IS_ERR(mipi->backlight))
+		return PTR_ERR(mipi->backlight);
+
+	writeonly = device_property_read_bool(dev, "write-only");
+	device_property_read_u32(dev, "rotation", &rotation);
+
+	mipi->reg = mipi_dbi_spi_init(spi, dc, writeonly);
+	if (IS_ERR(mipi->reg))
+		return PTR_ERR(mipi->reg);
+
+	ret = mipi_dbi_init(dev, mipi, &mi0283qt_pipe_funcs, &mi0283qt_driver,
+			    &mi0283qt_mode, rotation);
+	if (ret)
+		return ret;
+
+	tdev = &mipi->tinydrm;
+
+	ret = devm_tinydrm_register(tdev);
+	if (ret)
+		return ret;
+
+	spi_set_drvdata(spi, tdev);
+
+	DRM_DEBUG_DRIVER("Initialized %s:%s @%uMHz on minor %d\n",
+			 tdev->drm.driver->name, dev_name(dev),
+			 spi->max_speed_hz / 1000000,
+			 tdev->drm.primary->index);
+
+	return 0;
+}
+
+static struct spi_driver mi0283qt_spi_driver = {
+	.driver = {
+		.name = "mi0283qt",
+		.owner = THIS_MODULE,
+		.of_match_table = mi0283qt_of_match,
+		.pm = &tinydrm_simple_pm_ops,
+	},
+	.id_table = mi0283qt_id,
+	.probe = mi0283qt_probe,
+	.shutdown = tinydrm_spi_shutdown,
+};
+module_spi_driver(mi0283qt_spi_driver);
+
+MODULE_DESCRIPTION("Multi-Inno MI0283QT DRM driver");
+MODULE_AUTHOR("Noralf Tr√∏nnes");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/tinydrm/mipi-dbi.c b/drivers/gpu/drm/tinydrm/mipi-dbi.c
new file mode 100644
index 0000000..0a074a2
--- /dev/null
+++ b/drivers/gpu/drm/tinydrm/mipi-dbi.c
@@ -0,0 +1,1087 @@
+#define DEBUG
+#define VERBOSE_DEBUG
+/*
+ * MIPI Display Bus Interface (DBI) LCD controller support
+ *
+ * Copyright 2016 Noralf Tr√∏nnes
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_fb_cma_helper.h>
+#include <drm/tinydrm/mipi-dbi.h>
+#include <drm/tinydrm/tinydrm.h>
+#include <drm/tinydrm/tinydrm-helpers.h>
+#include <drm/tinydrm/tinydrm-regmap.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/spi/spi.h>
+#include <linux/swab.h>
+#include <video/mipi_display.h>
+
+#define MIPI_DBI_DEFAULT_SPI_READ_SPEED 2000000 /* 2MHz */
+
+#define DCS_POWER_MODE_DISPLAY			BIT(2)
+#define DCS_POWER_MODE_DISPLAY_NORMAL_MODE	BIT(3)
+#define DCS_POWER_MODE_SLEEP_MODE		BIT(4)
+#define DCS_POWER_MODE_PARTIAL_MODE		BIT(5)
+#define DCS_POWER_MODE_IDLE_MODE		BIT(6)
+#define DCS_POWER_MODE_RESERVED_MASK		(BIT(0) | BIT(1) | BIT(7))
+
+struct mipi_dbi_spi {
+	struct spi_device *spi;
+	struct regmap *map;
+	unsigned int ram_reg;
+	struct gpio_desc *dc;
+	bool write_only;
+	u16 *tx_buf;
+	size_t chunk_size;
+};
+
+/**
+ * DOC: overview
+ *
+ * This library provides helpers for MIPI Display Bus Interface (DBI)
+ * compatible display controllers.
+ *
+ * Many controllers are MIPI compliant and can use this library.
+ * If a controller uses registers 0x2A and 0x2B to set the area to update
+ * and uses register 0x2C to write to frame memory, it is most likely MIPI
+ * compliant.
+ *
+ * Only MIPI Type 1 displays are supported since a full frame memory is needed.
+ *
+ * There are 3 MIPI DBI implementation types:
+ *
+ * A. Motorola 6800 type parallel bus
+ *
+ * B. Intel 8080 type parallel bus
+ *
+ * C. SPI type with 3 options:
+ *
+ *    1. 9-bit with the Data/Command signal as the ninth bit
+ *    2. Same as above except it's sent as 16 bits
+ *    3. 8-bit with the Data/Command signal as a separate D/CX pin
+ *
+ * Currently mipi_dbi only supports Type C options 1 and 3 with
+ * mipi_dbi_spi_init().
+ */
+
+/**
+ * mipi_dbi_write_buf - Write command and parameter array
+ * @reg: Controller register
+ * @cmd: Command
+ * @parameters: Array of parameters (optional)
+ * @num: Number of parameters
+ */
+int mipi_dbi_write_buf(struct regmap *reg, unsigned int cmd,
+		       const u8 *parameters, size_t num)
+{
+	u8 *buf;
+	int ret;
+
+	buf = kmalloc(num, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	memcpy(buf, parameters, num);
+
+	ret = regmap_raw_write(reg, cmd, buf, num);
+	kfree(buf);
+
+	return ret;
+}
+EXPORT_SYMBOL(mipi_dbi_write_buf);
+
+static size_t mipi_dbi_spi_clamp_size(struct spi_device *spi, size_t size)
+{
+	size_t max_spi, clamped;
+
+	max_spi = min(spi_max_transfer_size(spi), spi->master->max_dma_len);
+	if (!size)
+		size = max_spi;
+	clamped = clamp_val(size, 4, max_spi);
+	clamped &= ~0x3;
+
+	return clamped;
+}
+
+/*
+ * MIPI DBI Type C Option 1
+ *
+ * If the SPI controller doesn't have 9 bits per word support,
+ * use blocks of 9 bytes to send 8x 9-bit words with a 8-bit SPI transfer.
+ * Pad partial blocks with MIPI_DCS_NOP (zero).
+ */
+
+#define SHIFT_U9_INTO_U64(_dst, _src, _pos) \
+{ \
+	(_dst) |= 1ULL << (63 - ((_pos) * 9)); \
+	(_dst) |= (u64)(_src) << (63 - 8 - ((_pos) * 9)); \
+}
+
+static int mipi_dbi_spi1e_transfer(struct mipi_dbi_spi *mspi, u8 bits_per_word,
+				   int dc, const void *buf, size_t len,
+				   size_t max_chunk)
+{
+	struct spi_device *spi = mspi->spi;
+	struct spi_transfer tr = {
+		.bits_per_word = 8,
+	};
+	struct spi_message m;
+	size_t max_src_chunk, chunk;
+	int i, ret = 0;
+	u8 *dst;
+	void *buf_dc;
+	const u8 *src = buf;
+
+	max_chunk = mipi_dbi_spi_clamp_size(spi, max_chunk);
+	if (max_chunk < 9)
+		return -EINVAL;
+
+	if (drm_debug & DRM_UT_CORE)
+		pr_debug("[drm:%s] bpw=%u, dc=%d, max_chunk=%zu, transfers:\n",
+			 __func__, bits_per_word, dc, max_chunk);
+
+	spi_message_init_with_transfers(&m, &tr, 1);
+
+	if (!dc) {
+		/* pad at beginning of block */
+		if (WARN_ON_ONCE(len != 1 || bits_per_word != 8))
+			return -EINVAL;
+
+		dst = kzalloc(9, GFP_KERNEL);
+		if (!dst)
+			return -ENOMEM;
+
+		dst[8] = *src;
+		tr.tx_buf = dst;
+		tr.len = 9;
+
+		tinydrm_dbg_spi_message(spi, &m);
+		ret = spi_sync(spi, &m);
+		kfree(dst);
+
+		return ret;
+	}
+
+	/* 8-byte aligned max_src_chunk that fits max_chunk */
+	max_src_chunk = max_chunk / 9 * 8;
+	max_src_chunk = min(max_src_chunk, len);
+	max_src_chunk = max_t(size_t, 8, max_src_chunk & ~0x7);
+
+	max_chunk = max_src_chunk + (max_src_chunk / 8);
+	buf_dc = kmalloc(max_chunk, GFP_KERNEL);
+	if (!buf_dc)
+		return -ENOMEM;
+
+	tr.tx_buf = buf_dc;
+
+	while (len) {
+		size_t added = 0;
+
+		chunk = min(len, max_src_chunk);
+		len -= chunk;
+		dst = buf_dc;
+
+		if (chunk < 8) {
+			/* pad at end of block */
+			u64 tmp = 0;
+			int j;
+
+			if (bits_per_word == 8) {
+				for (j = 0; j < chunk; j++)
+					SHIFT_U9_INTO_U64(tmp, *src++, j);
+			} else {
+				for (j = 0; j < (chunk / 2); j += 2) {
+					SHIFT_U9_INTO_U64(tmp, *src++, j + 1);
+					SHIFT_U9_INTO_U64(tmp, *src++, j);
+				}
+			}
+
+			*(u64 *)dst = cpu_to_be64(tmp);
+			dst[8] = 0x00;
+			chunk = 8;
+			added = 1;
+		} else {
+			for (i = 0; i < chunk; i += 8) {
+				u64 tmp = 0;
+
+				if (bits_per_word == 8) {
+					SHIFT_U9_INTO_U64(tmp, *src++, 0);
+					SHIFT_U9_INTO_U64(tmp, *src++, 1);
+					SHIFT_U9_INTO_U64(tmp, *src++, 2);
+					SHIFT_U9_INTO_U64(tmp, *src++, 3);
+					SHIFT_U9_INTO_U64(tmp, *src++, 4);
+					SHIFT_U9_INTO_U64(tmp, *src++, 5);
+					SHIFT_U9_INTO_U64(tmp, *src++, 6);
+
+					tmp |= 0x1;
+					/* TODO: unaligned access here? */
+					*(u64 *)dst = cpu_to_be64(tmp);
+					dst += 8;
+					*dst++ = *src++;
+				} else {
+					u8 src7;
+
+					SHIFT_U9_INTO_U64(tmp, *src++, 1);
+					SHIFT_U9_INTO_U64(tmp, *src++, 0);
+					SHIFT_U9_INTO_U64(tmp, *src++, 3);
+					SHIFT_U9_INTO_U64(tmp, *src++, 2);
+					SHIFT_U9_INTO_U64(tmp, *src++, 5);
+					SHIFT_U9_INTO_U64(tmp, *src++, 4);
+					src7 = *src++;
+					SHIFT_U9_INTO_U64(tmp, *src++, 6);
+
+					tmp |= 0x1;
+					/* TODO: unaligned access here? */
+					*(u64 *)dst = cpu_to_be64(tmp);
+					dst += 8;
+					*dst++ = src7;
+				}
+				added++;
+			}
+		}
+
+		tr.len = chunk + added;
+
+		tinydrm_dbg_spi_message(spi, &m);
+		ret = spi_sync(spi, &m);
+		if (ret)
+			goto err_free;
+	};
+
+err_free:
+	kfree(buf_dc);
+
+	return ret;
+}
+
+static int mipi_dbi_spi1_transfer(struct mipi_dbi_spi *mspi, u8 bits_per_word,
+				  int dc, const void *buf, size_t len,
+				  size_t max_chunk)
+{
+	struct spi_device *spi = mspi->spi;
+	struct spi_transfer tr = {
+		.bits_per_word = 9,
+	};
+	const u16 *src16 = buf;
+	const u8 *src8 = buf;
+	struct spi_message m;
+	size_t max_src_chunk;
+	int ret = 0;
+	u16 *dst16;
+
+	if (!tinydrm_spi_bpw_supported(spi, 9))
+		return mipi_dbi_spi1e_transfer(mspi, bits_per_word, dc, buf,
+					       len, max_chunk);
+
+	if (WARN_ON_ONCE(bits_per_word == 16 && len % 2))
+		return -EINVAL;
+
+	max_chunk = mipi_dbi_spi_clamp_size(spi, max_chunk);
+
+	if (drm_debug & DRM_UT_CORE)
+		pr_debug("[drm:%s] bpw=%u, dc=%d, max_chunk=%zu, transfers:\n",
+			 __func__, bits_per_word, dc, max_chunk);
+
+	max_src_chunk = min(max_chunk / 2, len);
+
+	dst16 = kmalloc(max_src_chunk * 2, GFP_KERNEL);
+	if (!dst16)
+		return -ENOMEM;
+
+	spi_message_init_with_transfers(&m, &tr, 1);
+	tr.tx_buf = dst16;
+
+	while (len) {
+		size_t chunk = min(len, max_src_chunk);
+		unsigned int i;
+
+		if (bits_per_word == 8) {
+			for (i = 0; i < chunk; i++) {
+				dst16[i] = *src8++;
+				if (dc)
+					dst16[i] |= 0x0100;
+			}
+		} else {
+			for (i = 0; i < (chunk * 2); i += 2) {
+				dst16[i]     = *src16 >> 8;
+				dst16[i + 1] = *src16++ & 0xFF;
+				if (dc) {
+					dst16[i]     |= 0x0100;
+					dst16[i + 1] |= 0x0100;
+				}
+			}
+		}
+		tr.len = chunk;
+		len -= chunk;
+
+		tinydrm_dbg_spi_message(spi, &m);
+		ret = spi_sync(spi, &m);
+		if (ret)
+			goto err_free;
+	};
+
+err_free:
+	kfree(dst16);
+
+	return ret;
+}
+
+static int mipi_dbi_spi1_gather_write(void *context, const void *reg,
+				      size_t reg_len, const void *val,
+				      size_t val_len)
+{
+	struct mipi_dbi_spi *mspi = context;
+	size_t val_width;
+	int ret;
+
+	if (reg_len != 1)
+		return -EINVAL;
+
+	val_width = (*(u8 *)reg == mspi->ram_reg) ? 16 : 8;
+	TINYDRM_DEBUG_REG_WRITE(reg, reg_len, val, val_len, val_width);
+
+	ret = mipi_dbi_spi1_transfer(mspi, 8, 0, reg, reg_len, 4096);
+	if (ret)
+		return ret;
+
+	if (val && val_len)
+		ret = mipi_dbi_spi1_transfer(mspi, val_width, 1, val,
+					     val_len, 4096);
+
+	return ret;
+}
+
+static int mipi_dbi_spi1_write(void *context, const void *data, size_t count)
+{
+	return mipi_dbi_spi1_gather_write(context, data, 1,
+					 data + 1, count - 1);
+}
+
+static int mipi_dbi_spi1_read(void *context, const void *reg, size_t reg_size,
+			      void *val, size_t val_size)
+{
+	return -ENOTSUPP;
+}
+
+static const struct regmap_bus mipi_dbi_regmap_bus1 = {
+	.write = mipi_dbi_spi1_write,
+	.gather_write = mipi_dbi_spi1_gather_write,
+	.read = mipi_dbi_spi1_read,
+	.reg_format_endian_default = REGMAP_ENDIAN_DEFAULT,
+	.val_format_endian_default = REGMAP_ENDIAN_DEFAULT,
+};
+
+/* MIPI DBI Type C Option 3 */
+
+static int mipi_dbi_spi3_gather_write(void *context, const void *reg,
+				      size_t reg_len, const void *val,
+				      size_t val_len)
+{
+	struct mipi_dbi_spi *mspi = context;
+	struct spi_device *spi = mspi->spi;
+	size_t val_width;
+	int ret;
+
+	if (reg_len != 1)
+		return -EINVAL;
+
+	val_width = (*(u8 *)reg == mspi->ram_reg) ? 16 : 8;
+	TINYDRM_DEBUG_REG_WRITE(reg, reg_len, val, val_len, val_width);
+
+	gpiod_set_value_cansleep(mspi->dc, 0);
+	ret = tinydrm_spi_transfer(spi, 0, NULL, 8, reg, 1, mspi->tx_buf,
+				   mspi->chunk_size);
+	if (ret)
+		return ret;
+
+	if (val && val_len) {
+		gpiod_set_value_cansleep(mspi->dc, 1);
+		ret = tinydrm_spi_transfer(spi, 0, NULL, val_width, val,
+					   val_len, mspi->tx_buf,
+					   mspi->chunk_size);
+	}
+
+	return ret;
+}
+
+static int mipi_dbi_spi3_write(void *context, const void *data, size_t count)
+{
+	return mipi_dbi_spi3_gather_write(context, data, 1,
+					  data + 1, count - 1);
+}
+
+static int mipi_dbi_spi3_read(void *context, const void *reg, size_t reg_len,
+			      void *val, size_t val_len)
+{
+	struct mipi_dbi_spi *mspi = context;
+	struct spi_device *spi = mspi->spi;
+	u32 speed_hz = min_t(u32, MIPI_DBI_DEFAULT_SPI_READ_SPEED,
+			     spi->max_speed_hz / 2);
+	struct spi_transfer tr[2] = {
+		{
+			.speed_hz = speed_hz,
+			.tx_buf = reg,
+			.len = 1,
+		}, {
+			.speed_hz = speed_hz,
+			.len = val_len,
+		},
+	};
+	struct spi_message m;
+	u8 cmd = *(u8 *)reg;
+	u8 *buf;
+	int ret;
+
+	if (mspi->write_only)
+		return -EACCES;
+
+	if (drm_debug & DRM_UT_CORE)
+		pr_debug("[drm:%s] regnr=0x%02x, len=%zu, transfers:\n",
+			 __func__, cmd, val_len);
+
+	/*
+	 * Support non-standard 24-bit and 32-bit Nokia read commands which
+	 * start with a dummy clock, so we need to read an extra byte.
+	 */
+	if (cmd == MIPI_DCS_GET_DISPLAY_ID ||
+	    cmd == MIPI_DCS_GET_DISPLAY_STATUS) {
+		if (!(val_len == 3 || val_len == 4))
+			return -EINVAL;
+
+		tr[1].len = val_len + 1;
+	}
+
+	buf = kmalloc(tr[1].len, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	tr[1].rx_buf = buf;
+	gpiod_set_value_cansleep(mspi->dc, 0);
+
+	/*
+	 * Can't use spi_write_then_read() because reading speed is slower
+	 * than writing speed and that is set on the transfer.
+	 */
+	spi_message_init_with_transfers(&m, tr, ARRAY_SIZE(tr));
+	ret = spi_sync(spi, &m);
+	tinydrm_dbg_spi_message(spi, &m);
+
+	if (tr[1].len == val_len) {
+		memcpy(val, buf, val_len);
+	} else {
+		u8 *data = val;
+		unsigned int i;
+
+		for (i = 0; i < val_len; i++)
+			data[i] = (buf[i] << 1) | !!(buf[i + 1] & BIT(7));
+	}
+	kfree(buf);
+
+	return ret;
+}
+
+/* MIPI DBI Type C Option 3 */
+static const struct regmap_bus mipi_dbi_regmap_bus3 = {
+	.write = mipi_dbi_spi3_write,
+	.gather_write = mipi_dbi_spi3_gather_write,
+	.read = mipi_dbi_spi3_read,
+	.reg_format_endian_default = REGMAP_ENDIAN_DEFAULT,
+	.val_format_endian_default = REGMAP_ENDIAN_DEFAULT,
+};
+
+/**
+ * mipi_dbi_spi_init - Initialize MIPI DBI SPI interface
+ * @spi: SPI device
+ * @dc: D/C gpio (optional)
+ * @write_only: Controller is write-only
+ *
+ * This function initializes a &regmap that can be used to send commands to
+ * the controller. mipi_dbi_write() can be used to send commands.
+ * If @dc is set, a Type C Option 3 interface is assumed, if not
+ * Type C Option 1.
+ * If the SPI master driver doesn't support the necessary bits per word,
+ * the following transformation is used:
+ *
+ * - 9-bit: reorder buffer as 9x 8-bit words, padded with no-op command.
+ * - 16-bit: if big endian send as 8-bit, if little endian swap bytes
+ *
+ * Returns:
+ * regmap on success, error pointer on failure.
+ */
+struct regmap *mipi_dbi_spi_init(struct spi_device *spi, struct gpio_desc *dc,
+				 bool write_only)
+{
+	struct regmap_config config = {
+		.reg_bits = 8,
+		.val_bits = 8,
+		.cache_type = REGCACHE_NONE,
+	};
+	struct device *dev = &spi->dev;
+	struct mipi_dbi_spi *mspi;
+
+	mspi = devm_kzalloc(dev, sizeof(*mspi), GFP_KERNEL);
+	if (!mspi)
+		return ERR_PTR(-ENOMEM);
+
+	mspi->chunk_size = tinydrm_spi_max_transfer_size(spi, 0);
+	mspi->ram_reg = MIPI_DCS_WRITE_MEMORY_START;
+	mspi->write_only = write_only;
+	mspi->spi = spi;
+	mspi->dc = dc;
+
+	if (tinydrm_get_machine_endian() == REGMAP_ENDIAN_LITTLE &&
+	    dc && !tinydrm_spi_bpw_supported(spi, 16)) {
+		mspi->tx_buf = devm_kmalloc(dev, mspi->chunk_size, GFP_KERNEL);
+		if (!mspi->tx_buf)
+			return ERR_PTR(-ENOMEM);
+	}
+
+	if (dc)
+		mspi->map = devm_regmap_init(dev, &mipi_dbi_regmap_bus3, mspi,
+					     &config);
+	else
+		mspi->map = devm_regmap_init(dev, &mipi_dbi_regmap_bus1, mspi,
+					     &config);
+
+	return mspi->map;
+}
+EXPORT_SYMBOL(mipi_dbi_spi_init);
+
+static int mipi_dbi_fb_dirty(struct drm_framebuffer *fb,
+			     struct drm_file *file_priv,
+			     unsigned int flags, unsigned int color,
+			     struct drm_clip_rect *clips,
+			     unsigned int num_clips)
+{
+	struct drm_gem_cma_object *cma_obj = drm_fb_cma_get_gem_obj(fb, 0);
+	struct tinydrm_device *tdev = drm_to_tinydrm(fb->dev);
+	struct mipi_dbi *mipi = mipi_dbi_from_tinydrm(tdev);
+	struct regmap *reg = mipi->reg;
+	struct drm_clip_rect clip;
+	int ret = 0;
+
+	mutex_lock(&tdev->dev_lock);
+
+	if (!tinydrm_check_dirty(fb, &clips, &num_clips))
+		goto out_unlock;
+
+	tinydrm_merge_clips(&clip, clips, num_clips, flags,
+			    fb->width, fb->height);
+	clip.x1 = 0;
+	clip.x2 = fb->width;
+
+	DRM_DEBUG("Flushing [FB:%d] x1=%u, x2=%u, y1=%u, y2=%u\n", fb->base.id,
+		  clip.x1, clip.x2, clip.y1, clip.y2);
+
+	tinydrm_debugfs_dirty_begin(tdev, fb, &clip);
+
+	mipi_dbi_write(reg, MIPI_DCS_SET_COLUMN_ADDRESS,
+		       (clip.x1 >> 8) & 0xFF, clip.x1 & 0xFF,
+		       (clip.x2 >> 8) & 0xFF, (clip.x2 - 1) & 0xFF);
+	mipi_dbi_write(reg, MIPI_DCS_SET_PAGE_ADDRESS,
+		       (clip.y1 >> 8) & 0xFF, clip.y1 & 0xFF,
+		       (clip.y2 >> 8) & 0xFF, (clip.y2 - 1) & 0xFF);
+
+	ret = tinydrm_regmap_flush_rgb565(reg, MIPI_DCS_WRITE_MEMORY_START,
+					  fb, cma_obj->vaddr, &clip);
+
+	tinydrm_debugfs_dirty_end(tdev, 0, 16);
+
+	if (ret) {
+		dev_err_once(fb->dev->dev, "Failed to update display %d\n",
+			     ret);
+		goto out_unlock;
+	}
+
+	if (!tdev->enabled) {
+		if (mipi->enable_delay_ms)
+			msleep(mipi->enable_delay_ms);
+		ret = tinydrm_enable_backlight(mipi->backlight);
+		if (ret) {
+			DRM_ERROR("Failed to enable backlight %d\n", ret);
+			goto out_unlock;
+		}
+		tdev->enabled = true;
+	}
+
+out_unlock:
+	mutex_unlock(&tdev->dev_lock);
+
+	return ret;
+}
+
+static const struct drm_framebuffer_funcs mipi_dbi_fb_funcs = {
+	.destroy	= drm_fb_cma_destroy,
+	.create_handle	= drm_fb_cma_create_handle,
+	.dirty		= mipi_dbi_fb_dirty,
+};
+
+static void mipi_dbi_blank(struct mipi_dbi *mipi)
+{
+	struct drm_device *drm = &mipi->tinydrm.drm;
+	int height = drm->mode_config.min_height;
+	int width = drm->mode_config.min_width;
+	unsigned int num_pixels = width * height;
+	struct regmap *reg = mipi->reg;
+	u16 *buf;
+
+	buf = kzalloc(num_pixels * 2, GFP_KERNEL);
+	if (!buf)
+		return;
+
+	mipi_dbi_write(reg, MIPI_DCS_SET_COLUMN_ADDRESS, 0, 0,
+		       (width >> 8) & 0xFF, (width - 1) & 0xFF);
+	mipi_dbi_write(reg, MIPI_DCS_SET_PAGE_ADDRESS, 0, 0,
+		       (height >> 8) & 0xFF, (height - 1) & 0xFF);
+	regmap_raw_write(reg, MIPI_DCS_WRITE_MEMORY_START, buf,
+			 num_pixels * 2);
+	kfree(buf);
+}
+
+/**
+ * mipi_dbi_pipe_disable - MIPI DBI pipe disable helper
+ * @pipe: Display pipe
+ *
+ * This function disables the display pipeline by disabling backlight and
+ * regulator if present.
+ * Drivers can use this as their &drm_simple_display_pipe_funcs->disable
+ * callback.
+ */
+void mipi_dbi_pipe_disable(struct drm_simple_display_pipe *pipe)
+{
+	struct tinydrm_device *tdev = pipe_to_tinydrm(pipe);
+	struct mipi_dbi *mipi = mipi_dbi_from_tinydrm(tdev);
+	struct regmap *reg = mipi->reg;
+
+	DRM_DEBUG_KMS("\n");
+
+	mutex_lock(&tdev->dev_lock);
+
+	if (tdev->enabled) {
+		if (mipi->backlight)
+			tinydrm_disable_backlight(mipi->backlight);
+		else if (!mipi->regulator)
+			mipi_dbi_blank(mipi);
+	}
+	tdev->enabled = false;
+
+	if (tdev->prepared) {
+		if (mipi->backlight) {
+			/*
+			 * This usually turns the pixels off letting backlight
+			 * shine through, so only do it if we control backlight
+			 *
+			 * TODO
+			 * Maybe just leave the display prepared. Very little
+			 * power savings in doing this. And it would speed up
+			 * re-enabling the pipeline (100-500ms).
+			 */
+			mipi_dbi_write(reg, MIPI_DCS_SET_DISPLAY_OFF);
+			mipi_dbi_write(reg, MIPI_DCS_ENTER_SLEEP_MODE);
+			tdev->prepared = false;
+		}
+
+		if (mipi->regulator) {
+			regulator_disable(mipi->regulator);
+			tdev->prepared = false;
+		}
+	}
+
+	mutex_unlock(&tdev->dev_lock);
+}
+EXPORT_SYMBOL(mipi_dbi_pipe_disable);
+
+static const uint32_t mipi_dbi_formats[] = {
+	DRM_FORMAT_RGB565,
+	DRM_FORMAT_XRGB8888,
+};
+
+/**
+ * mipi_dbi_init - MIPI DBI initialization
+ * @dev: Parent device
+ * @mipi: &mipi_dbi structure to initialize
+ * @pipe_funcs: Display pipe functions
+ * @driver: DRM driver
+ * @mode: Display mode
+ * @rotation: Initial rotation in degress Counter Clock Wise
+ *
+ * This function initializes a &mipi_dbi structure and it's underlying
+ * @tinydrm_device and &drm_device. It also sets up the display pipeline.
+ * Supported formats: Native RGB565 and emulated XRGB8888.
+ * Objects created by this function will be automatically freed on driver
+ * detach (devres).
+ *
+ * Returns:
+ * Zero on success, negative error code on failure.
+ */
+int mipi_dbi_init(struct device *dev, struct mipi_dbi *mipi,
+		  const struct drm_simple_display_pipe_funcs *pipe_funcs,
+		  struct drm_driver *driver,
+		  const struct drm_display_mode *mode, unsigned int rotation)
+{
+	struct tinydrm_device *tdev = &mipi->tinydrm;
+	struct drm_device *drm = &tdev->drm;
+	int ret;
+
+	ret = devm_tinydrm_init(dev, tdev, &mipi_dbi_fb_funcs, driver);
+	if (ret)
+		return ret;
+
+	/* TODO: Maybe add DRM_MODE_CONNECTOR_SPI */
+	ret = tinydrm_display_pipe_init(tdev, pipe_funcs,
+					DRM_MODE_CONNECTOR_VIRTUAL,
+					mipi_dbi_formats,
+					ARRAY_SIZE(mipi_dbi_formats), mode,
+					rotation);
+	if (ret)
+		return ret;
+
+	drm->mode_config.preferred_depth = 16;
+	mipi->rotation = rotation;
+
+	drm_mode_config_reset(drm);
+
+	tinydrm_debugfs_dirty_init(tdev);
+
+	DRM_DEBUG_KMS("preferred_depth=%u, rotation = %u\n",
+		      drm->mode_config.preferred_depth, rotation);
+
+	return 0;
+}
+EXPORT_SYMBOL(mipi_dbi_init);
+
+/**
+ * mipi_dbi_hw_reset - Hardware reset of controller
+ * @mipi: MIPI DBI structure
+ *
+ * Reset controller if the &mipi_dbi->reset gpio is set.
+ */
+void mipi_dbi_hw_reset(struct mipi_dbi *mipi)
+{
+	if (!mipi->reset)
+		return;
+
+	gpiod_set_value_cansleep(mipi->reset, 0);
+	msleep(20);
+	gpiod_set_value_cansleep(mipi->reset, 1);
+	msleep(120);
+}
+EXPORT_SYMBOL(mipi_dbi_hw_reset);
+
+/**
+ * mipi_dbi_display_is_on - check if display is on
+ * @reg: LCD register
+ *
+ * This function checks the Power Mode register (if readable) to see if
+ * display output is turned on. This can be used to see if the bootloader
+ * has already turned on the display avoiding flicker when the pipeline is
+ * enabled.
+ *
+ * Returns:
+ * true if the display can be verified to be on, false otherwise.
+ */
+bool mipi_dbi_display_is_on(struct regmap *reg)
+{
+	u8 val;
+
+	if (regmap_raw_read(reg, MIPI_DCS_GET_POWER_MODE, &val, 1))
+		return false;
+
+	val &= ~DCS_POWER_MODE_RESERVED_MASK;
+
+	if (val != (DCS_POWER_MODE_DISPLAY |
+	    DCS_POWER_MODE_DISPLAY_NORMAL_MODE | DCS_POWER_MODE_SLEEP_MODE))
+		return false;
+
+	DRM_DEBUG_DRIVER("Display is ON\n");
+
+	return true;
+}
+EXPORT_SYMBOL(mipi_dbi_display_is_on);
+
+#ifdef CONFIG_DEBUG_FS
+
+static bool mipi_dbi_debugfs_readreg(struct seq_file *m, struct regmap *reg,
+				     unsigned int regnr, const char *desc,
+				     u8 *buf, size_t len)
+{
+	int ret;
+
+	ret = regmap_raw_read(reg, regnr, buf, len);
+	if (ret) {
+		seq_printf(m, "\n%s: command %02Xh failed: %d\n", desc, regnr,
+			   ret);
+		return false;
+	}
+
+	seq_printf(m, "\n%s (%02Xh=%*phN):\n", desc, regnr, len, buf);
+
+	return true;
+}
+
+static void
+seq_bit_val(struct seq_file *m, const char *desc, u32 val, u8 bit)
+{
+	bool bit_val = !!(val & BIT(bit));
+
+	seq_printf(m, "    D%u=%u: %s\n", bit, bit_val, desc);
+}
+
+static void
+seq_bit_reserved(struct seq_file *m, u32 val, u8 end, u8 start)
+{
+	int i;
+
+	for (i = end; i >= start; i--)
+		seq_bit_val(m, "Reserved", val, i);
+}
+
+static void
+seq_bit_array(struct seq_file *m, const char *desc, u32 val, u8 end, u8 start)
+{
+	u32 bits_val = (val & GENMASK(end, start)) >> start;
+	int i;
+
+	seq_printf(m, "    D[%u:%u]=%u: %s ", end, start, bits_val, desc);
+	for (i = end; i >= start; i--)
+		seq_printf(m, "%u ", !!(val & BIT(i)));
+
+	seq_putc(m, '\n');
+}
+
+static void
+seq_bit_text(struct seq_file *m, const char *desc, u32 val, u8 bit,
+	     const char *on, const char *off)
+{
+	bool bit_val = val & BIT(bit);
+
+	seq_printf(m, "    D%u=%u: %s %s\n", bit, bit_val, desc,
+		   bit_val ? on : off);
+}
+
+static inline void
+seq_bit_on_off(struct seq_file *m, const char *desc, u32 val, u8 bit)
+{
+	seq_bit_text(m, desc, val, bit, "On", "Off");
+}
+
+static char *mipi_pixel_format_str(u8 val)
+{
+	switch (val) {
+	case 0:
+		return "Reserved";
+	case 1:
+		return "3 bits/pixel";
+	case 2:
+		return "8 bits/pixel";
+	case 3:
+		return "12 bits/pixel";
+	case 4:
+		return "Reserved";
+	case 5:
+		return "16 bits/pixel";
+	case 6:
+		return "18 bits/pixel";
+	case 7:
+		return "24 bits/pixel";
+	default:
+		return "Illegal format";
+	}
+}
+
+static int mipi_dbi_debugfs_show(struct seq_file *m, void *arg)
+{
+	struct drm_info_node *node = (struct drm_info_node *)m->private;
+	struct drm_device *drm = node->minor->dev;
+	struct tinydrm_device *tdev = drm_to_tinydrm(drm);
+	struct mipi_dbi *mipi = mipi_dbi_from_tinydrm(tdev);
+	struct regmap *reg = mipi->reg;
+	u8 buf[4];
+	u8 val8;
+	int ret;
+
+	ret = regmap_raw_read(reg, MIPI_DCS_GET_POWER_MODE, buf, 1);
+	if (ret == -EACCES || ret == -ENOTSUPP) {
+		seq_puts(m, "Controller is write-only\n");
+		return 0;
+	}
+
+	/*
+	 * Read Display ID (04h) and Read Display Status (09h) are
+	 * non-standard commands that Nokia wanted back in the day,
+	 * so most vendors implemented them.
+	 */
+	if (mipi_dbi_debugfs_readreg(m, reg, MIPI_DCS_GET_DISPLAY_ID,
+				     "Display ID", buf, 3)) {
+		seq_printf(m, "    ID1 = 0x%02x\n", buf[0]);
+		seq_printf(m, "    ID2 = 0x%02x\n", buf[1]);
+		seq_printf(m, "    ID3 = 0x%02x\n", buf[2]);
+	}
+
+	if (mipi_dbi_debugfs_readreg(m, reg, MIPI_DCS_GET_DISPLAY_STATUS,
+				     "Display status", buf, 4)) {
+		u32 stat;
+
+		stat = (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];
+
+		seq_bit_on_off(m, "Booster voltage status:", stat, 31);
+		seq_bit_val(m, "Row address order", stat, 30);
+		seq_bit_val(m, "Column address order", stat, 29);
+		seq_bit_val(m, "Row/column exchange", stat, 28);
+		seq_bit_text(m, "Vertical refresh:", stat, 27,
+			     "Bottom to Top", "Top to Bottom");
+		seq_bit_text(m, "RGB/BGR order:", stat, 26, "BGR", "RGB");
+		seq_bit_text(m, "Horizontal refresh order:", stat, 25,
+			     "Right to Left", "Left to Right");
+		seq_bit_reserved(m, stat, 24, 23);
+		seq_bit_array(m, "Interface color pixel format:", stat, 22, 20);
+		seq_bit_on_off(m, "Idle mode:", stat, 19);
+		seq_bit_on_off(m, "Partial mode:", stat, 18);
+		seq_bit_text(m, "Sleep:", stat, 17, "Out", "In");
+		seq_bit_on_off(m, "Display normal mode:", stat, 16);
+		seq_bit_on_off(m, "Vertical scrolling status:", stat, 15);
+		seq_bit_reserved(m, stat, 14, 14);
+		seq_bit_val(m, "Inversion status", stat, 13);
+		seq_bit_val(m, "All pixel ON", stat, 12);
+		seq_bit_val(m, "All pixel OFF", stat, 11);
+		seq_bit_on_off(m, "Display:", stat, 10);
+		seq_bit_on_off(m, "Tearing effect line:", stat, 9);
+		seq_bit_array(m, "Gamma curve selection:", stat, 8, 6);
+		seq_bit_text(m, "Tearing effect line mode:", stat, 5,
+			     "Mode 2, both H-Blanking and V-Blanking",
+			     "Mode 1, V-Blanking only");
+		seq_bit_reserved(m, stat, 4, 0);
+	}
+
+	if (mipi_dbi_debugfs_readreg(m, reg, MIPI_DCS_GET_POWER_MODE,
+				     "Power mode", &val8, 1)) {
+		seq_bit_text(m, "Booster", val8, 7, "On", "Off or faulty");
+		seq_bit_on_off(m, "Idle Mode", val8, 6);
+		seq_bit_on_off(m, "Partial Mode", val8, 5);
+		seq_bit_text(m, "Sleep", val8, 4, "Out Mode", "In Mode");
+		seq_bit_on_off(m, "Display Normal Mode", val8, 3);
+		seq_bit_on_off(m, "Display is", val8, 2);
+		seq_bit_reserved(m, val8, 1, 0);
+	}
+
+	if (mipi_dbi_debugfs_readreg(m, reg, MIPI_DCS_GET_ADDRESS_MODE,
+				     "Address mode", &val8, 1)) {
+		seq_bit_text(m, "Page Address Order:", val8, 7,
+			     "Bottom to Top", "Top to Bottom");
+		seq_bit_text(m, "Column Address Order:", val8, 6,
+			     "Right to Left", "Left to Right");
+		seq_bit_text(m, "Page/Column Order:", val8, 5,
+			     "Reverse Mode", "Normal Mode");
+		seq_bit_text(m, "Line Address Order: LCD Refresh", val8, 4,
+			     "Bottom to Top", "Top to Bottom");
+		seq_bit_text(m, "RGB/BGR Order:", val8, 3, "BGR", "RGB");
+		seq_bit_text(m, "Display Data Latch Data Order: LCD Refresh",
+			     val8, 2, "Right to Left", "Left to Right");
+		seq_bit_reserved(m, val8, 1, 0);
+	}
+
+	if (mipi_dbi_debugfs_readreg(m, reg, MIPI_DCS_GET_PIXEL_FORMAT,
+				     "Pixel format", &val8, 1)) {
+		u8 dpi = (val8 >> 4) & 0x7;
+		u8 dbi = val8 & 0x7;
+
+		seq_bit_reserved(m, val8, 7, 7);
+		seq_printf(m, "    D[6:4]=%u: DPI: %s\n", dpi,
+			   mipi_pixel_format_str(dpi));
+		seq_bit_reserved(m, val8, 3, 3);
+		seq_printf(m, "    D[2:0]=%u: DBI: %s\n", dbi,
+			   mipi_pixel_format_str(dbi));
+	}
+
+	if (mipi_dbi_debugfs_readreg(m, reg, MIPI_DCS_GET_DISPLAY_MODE,
+				     "Image Mode", &val8, 1)) {
+		u8 gc = val8 & 0x7;
+
+		seq_bit_on_off(m, "Vertical Scrolling Status:", val8, 7);
+		seq_bit_reserved(m, val8, 6, 6);
+		seq_bit_on_off(m, "Inversion:", val8, 5);
+		seq_bit_reserved(m, val8, 4, 3);
+		seq_printf(m, "    D[2:0]=%u: Gamma Curve Selection: ", gc);
+		if (gc < 4)
+			seq_printf(m, "GC%u\n", gc);
+		else
+			seq_puts(m, "Reserved\n");
+	}
+
+	if (mipi_dbi_debugfs_readreg(m, reg, MIPI_DCS_GET_SIGNAL_MODE,
+				     "Signal Mode", &val8, 1)) {
+		seq_bit_on_off(m, "Tearing Effect Line:", val8, 7);
+		seq_bit_text(m, "Tearing Effect Line Output Mode: Mode",
+			     val8, 6, "2", "1");
+		seq_bit_reserved(m, val8, 5, 0);
+	}
+
+	if (mipi_dbi_debugfs_readreg(m, reg, MIPI_DCS_GET_DIAGNOSTIC_RESULT,
+				     "Diagnostic result", &val8, 1)) {
+		seq_bit_text(m, "Register Loading Detection:", val8, 7,
+			     "OK", "Fault or reset");
+		seq_bit_text(m, "Functionality Detection:", val8, 6,
+			     "OK", "Fault or reset");
+		seq_bit_text(m, "Chip Attachment Detection:", val8, 5,
+			     "Fault", "OK or unimplemented");
+		seq_bit_text(m, "Display Glass Break Detection:", val8, 4,
+			     "Fault", "OK or unimplemented");
+		seq_bit_reserved(m, val8, 3, 0);
+	}
+
+	return 0;
+}
+
+static const struct drm_info_list mipi_dbi_debugfs_list[] = {
+	{ "mipi",   mipi_dbi_debugfs_show, 0 },
+};
+
+/**
+ * mipi_dbi_debugfs_init - Create debugfs entries
+ * @minor: DRM minor
+ *
+ * Drivers can use this as their &drm_driver->debugfs_init callback.
+ *
+ * Returns:
+ * Zero on success, negative error code on failure.
+ */
+int mipi_dbi_debugfs_init(struct drm_minor *minor)
+{
+	int ret;
+
+	ret = tinydrm_debugfs_init(minor);
+	if (ret)
+		return ret;
+
+	return drm_debugfs_create_files(mipi_dbi_debugfs_list,
+					ARRAY_SIZE(mipi_dbi_debugfs_list),
+					minor->debugfs_root, minor);
+}
+EXPORT_SYMBOL(mipi_dbi_debugfs_init);
+
+/**
+ * mipi_dbi_debugfs_cleanup - Cleanup debugfs entries
+ * @minor: DRM minor
+ *
+ * Drivers can use this as their &drm_driver->debugfs_cleanup callback.
+ */
+void mipi_dbi_debugfs_cleanup(struct drm_minor *minor)
+{
+	tinydrm_debugfs_cleanup(minor);
+	drm_debugfs_remove_files(mipi_dbi_debugfs_list,
+				 ARRAY_SIZE(mipi_dbi_debugfs_list), minor);
+}
+EXPORT_SYMBOL(mipi_dbi_debugfs_cleanup);
+
+#endif
+
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/tinydrm/utinydrm.c b/drivers/gpu/drm/tinydrm/utinydrm.c
new file mode 100644
index 0000000..14ac47c
--- /dev/null
+++ b/drivers/gpu/drm/tinydrm/utinydrm.c
@@ -0,0 +1,652 @@
+#define DEBUG
+/*
+ * Copyright (C) 2016 Noralf Tr√∏nnes
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_fb_cma_helper.h>
+#include <drm/drm_fb_helper.h>
+#include <drm/tinydrm/tinydrm.h>
+#include <drm/tinydrm/tinydrm-helpers.h>
+#include <linux/completion.h>
+#include <linux/fs.h>
+#include <linux/idr.h>
+#include <linux/init.h>
+#include <linux/leds.h>
+#include <linux/miscdevice.h>
+#include <linux/module.h>
+#include <linux/poll.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+
+#include <uapi/drm/utinydrm.h>
+
+
+struct utinydrm_device {
+	struct tinydrm_device	tdev;
+	struct device dev;
+	struct idr 		idr;
+
+	struct mutex		mutex;
+	wait_queue_head_t	waitq;
+	struct completion	completion;
+
+	struct utinydrm_event	*ev;
+	int			event_ret;
+
+	bool			initialized;
+	bool			fbdev_fb_sent;
+	struct work_struct	release_work;
+};
+
+static inline struct utinydrm_device *
+udev_from_tdev(struct tinydrm_device *tdev)
+{
+	return container_of(tdev, struct utinydrm_device, tdev);
+}
+
+static struct miscdevice utinydrm_misc;
+
+static int utinydrm_send_event(struct tinydrm_device *tdev, void *ev_in)
+{
+	struct utinydrm_device *udev = udev_from_tdev(tdev);
+	struct utinydrm_event *ev = ev_in;
+	unsigned long time_left;
+	int ret = 0;
+
+	ev = kmemdup(ev, ev->length, GFP_KERNEL);
+	if (!ev)
+		return -ENOMEM;
+
+	dev_dbg(tdev->drm.dev, "%s(ev=%p) IN\n", __func__, ev);
+	mutex_lock(&udev->tdev.dev_lock);
+	reinit_completion(&udev->completion);
+
+	ret = mutex_lock_interruptible(&udev->mutex);
+	if (ret) {
+		kfree(ev);
+		goto out_unlock;
+	}
+	udev->ev = ev;
+	mutex_unlock(&udev->mutex);
+
+	dev_dbg(tdev->drm.dev, "%s: ev->type=%u, ev->length=%u\n", __func__, udev->ev->type, udev->ev->length);
+
+	wake_up_interruptible(&udev->waitq);
+
+	time_left = wait_for_completion_timeout(&udev->completion, 5 * HZ);
+	//ret = udev->event_ret;
+	//time_left = 1;
+	if (!time_left) {
+		dev_err(&udev->dev, "%s: timeout waiting for reply\n", __func__);
+		ret =-ETIMEDOUT;
+	}
+
+out_unlock:
+	mutex_unlock(&udev->tdev.dev_lock);
+
+	dev_dbg(tdev->drm.dev, "%s OUT ret=%d, event_ret=%d\n", __func__, ret, udev->event_ret);
+	return ret;
+}
+
+static int utinydrm_fb_create_event(struct drm_framebuffer *fb)
+{
+	struct tinydrm_device *tdev = drm_to_tinydrm(fb->dev);
+	struct utinydrm_device *udev = udev_from_tdev(tdev);
+	struct utinydrm_event_fb_create ev = {
+		.base = {
+			.type = UTINYDRM_EVENT_FB_CREATE,
+			.length = sizeof(ev),
+		},
+	};
+	struct drm_mode_fb_cmd2 *ufb = &ev.fb;
+	struct drm_gem_cma_object *cma_obj;
+	int ret, i;
+
+	dev_dbg(fb->dev->dev, "%s: [FB:%d]\n", __func__, fb->base.id);
+
+	ufb->fb_id = fb->base.id;
+	ufb->width = fb->width;
+	ufb->height = fb->height;
+	ufb->pixel_format = fb->pixel_format;
+	ufb->flags = fb->flags;
+
+	for (i = 0; i < 4; i++) {
+		cma_obj = drm_fb_cma_get_gem_obj(fb, i);
+		if (!cma_obj)
+			break;
+
+		ufb->pitches[i] = fb->pitches[i];
+		ufb->offsets[i] = fb->offsets[i];
+		ufb->modifier[i] = fb->modifier[i];
+	}
+
+	ret = idr_alloc(&udev->idr, fb, fb->base.id, fb->base.id + 1, GFP_KERNEL);
+	if (ret < 1) {
+		dev_err(fb->dev->dev, "%s: [FB:%d]: failed to allocate idr %d\n", __func__, fb->base.id, ret);
+		return ret;
+	}
+
+	ret = utinydrm_send_event(tdev, &ev);
+
+	return ret;
+}
+
+static int utinydrm_fb_dirty(struct drm_framebuffer *fb,
+			     struct drm_file *file_priv,
+			     unsigned int flags, unsigned int color,
+			     struct drm_clip_rect *clips,
+			     unsigned int num_clips)
+{
+	struct tinydrm_device *tdev = drm_to_tinydrm(fb->dev);
+	struct utinydrm_device *udev = udev_from_tdev(tdev);
+	struct drm_mode_fb_dirty_cmd *dirty;
+	struct utinydrm_event_fb_dirty *ev;
+	struct drm_clip_rect clip;
+	size_t size_clips, size;
+	int ret;
+
+	pr_debug("\n\n\n");
+	if (!tinydrm_check_dirty(fb, &clips, &num_clips))
+		return -EINVAL;
+
+	/* FIXME: if (fb == tdev->fbdev_helper->fb) */
+	if (tdev->fbdev_helper && !udev->fbdev_fb_sent) {
+		utinydrm_fb_create_event(tdev->fbdev_helper->fb);
+		udev->fbdev_fb_sent = true;
+	}
+
+	tdev->enabled = true;
+
+	tinydrm_merge_clips(&clip, clips, num_clips, flags,
+			    fb->width, fb->height);
+	clip.x1 = 0;
+	clip.x2 = fb->width;
+	clips = &clip;
+	num_clips = 1;
+
+	size_clips = num_clips * sizeof(struct drm_clip_rect);
+	size = sizeof(struct utinydrm_event_fb_dirty) + size_clips;
+	ev = kzalloc(size, GFP_KERNEL);
+	if (!ev)
+		return -ENOMEM;
+
+	dev_dbg(fb->dev->dev, "%s: [FB:%d]: num_clips=%u, size_clips=%zu, size=%zu\n", __func__, fb->base.id, num_clips, size_clips, size);
+
+	ev->base.type = UTINYDRM_EVENT_FB_DIRTY;
+	ev->base.length = size;
+	dirty = &ev->fb_dirty_cmd;
+
+	dirty->fb_id = fb->base.id;
+	dirty->flags = flags;
+	dirty->color = color;
+	dirty->num_clips = num_clips;
+	//dirty->clips_ptr
+
+	if (num_clips)
+		memcpy(ev->clips, clips, size_clips);
+
+//	tinydrm_merge_clips(&clip, clips, num_clips, flags,
+//			    fb->width, fb->height);
+//	clip.x1 = 0;
+//	clip.x2 = fb->width;
+
+	DRM_DEBUG("Flushing [FB:%d] x1=%u, x2=%u, y1=%u, y2=%u\n", fb->base.id,
+		  clip.x1, clip.x2, clip.y1, clip.y2);
+
+	tinydrm_debugfs_dirty_begin(tdev, fb, &clip);
+
+	ret = utinydrm_send_event(tdev, ev);
+
+	tinydrm_debugfs_dirty_end(tdev, 0, 16);
+
+	if (ret) {
+		dev_err_once(fb->dev->dev, "Failed to update display %d\n",
+			     ret);
+	}
+
+	return ret;
+}
+
+static void utinydrm_fb_destroy(struct drm_framebuffer *fb)
+{
+	struct tinydrm_device *tdev = drm_to_tinydrm(fb->dev);
+	struct utinydrm_device *udev = udev_from_tdev(tdev);
+	struct utinydrm_event_fb_destroy ev = {
+		.base = {
+			.type = UTINYDRM_EVENT_FB_DESTROY,
+			.length = sizeof(ev),
+		},
+	};
+	struct drm_framebuffer *iter;
+	int id;
+
+	dev_dbg(fb->dev->dev, "%s: [FB:%d]\n", __func__, fb->base.id);
+
+	idr_for_each_entry(&udev->idr, iter, id) {
+		if (fb == iter)
+			break;
+	}
+
+	if (!iter) {
+		dev_err(fb->dev->dev, "%s: failed to find idr\n", __func__);
+		return;
+	}
+
+	ev.fb_id = id;
+	idr_remove(&udev->idr, id);
+
+	utinydrm_send_event(tdev, &ev);
+
+	drm_fb_cma_destroy(fb);
+}
+
+static const struct drm_framebuffer_funcs utinydrm_fb_funcs = {
+	.destroy	= utinydrm_fb_destroy,
+	.create_handle	= drm_fb_cma_create_handle,
+	.dirty		= utinydrm_fb_dirty,
+};
+
+static struct drm_framebuffer *
+utinydrm_fb_create(struct drm_device *drm, struct drm_file *file_priv,
+		   const struct drm_mode_fb_cmd2 *mode_cmd)
+{
+	struct drm_framebuffer *fb;
+	int ret;
+
+	fb = tinydrm_fb_create(drm, file_priv, mode_cmd);
+	if (IS_ERR(fb))
+		return fb;
+
+	dev_dbg(drm->dev, "%s\n", __func__);
+	ret = utinydrm_fb_create_event(fb);
+
+	return fb;
+}
+
+static const struct drm_mode_config_funcs utinydrm_mode_config_funcs = {
+	.fb_create = utinydrm_fb_create,
+	.atomic_check = drm_atomic_helper_check,
+	.atomic_commit = drm_atomic_helper_commit,
+};
+
+static void utinydrm_pipe_enable(struct drm_simple_display_pipe *pipe,
+				 struct drm_crtc_state *crtc_state)
+{
+	struct tinydrm_device *tdev = pipe_to_tinydrm(pipe);
+	struct utinydrm_event ev = {
+		.type = UTINYDRM_EVENT_PIPE_ENABLE,
+		.length = sizeof(ev),
+	};
+
+	dev_dbg(tdev->drm.dev, "%s\n", __func__);
+	tdev->prepared = true;
+	utinydrm_send_event(tdev, &ev);
+}
+
+static void utinydrm_pipe_disable(struct drm_simple_display_pipe *pipe)
+{
+	struct tinydrm_device *tdev = pipe_to_tinydrm(pipe);
+	struct utinydrm_event ev = {
+		.type = UTINYDRM_EVENT_PIPE_DISABLE,
+		.length = sizeof(ev),
+	};
+
+	dev_dbg(tdev->drm.dev, "%s\n", __func__);
+	tdev->prepared = false;
+	tdev->enabled = false;
+	utinydrm_send_event(tdev, &ev);
+}
+
+static const struct drm_simple_display_pipe_funcs utinydrm_pipe_funcs = {
+	.enable = utinydrm_pipe_enable,
+	.disable = utinydrm_pipe_disable,
+	.update = tinydrm_display_pipe_update,
+};
+
+static int utinydrm_prime_handle_to_fd_ioctl(struct drm_device *dev, void *data,
+					     struct drm_file *file_priv)
+{
+	struct drm_prime_handle *args = data;
+
+	/* FIXME: only the userspace driver should use this */
+
+	/* check flags are valid */
+	if (args->flags & ~(DRM_CLOEXEC | DRM_RDWR))
+		return -EINVAL;
+
+	return dev->driver->prime_handle_to_fd(dev, file_priv, args->handle,
+					       args->flags, &args->fd);
+}
+
+static const struct drm_ioctl_desc utinydrm_ioctls[] = {
+	DRM_IOCTL_DEF_DRV(UTINYDRM_PRIME_HANDLE_TO_FD, utinydrm_prime_handle_to_fd_ioctl, DRM_CONTROL_ALLOW|DRM_UNLOCKED),
+};
+
+static struct drm_driver utinydrm_driver = {
+	.driver_features	= DRIVER_GEM | DRIVER_MODESET | DRIVER_PRIME |
+				  DRIVER_ATOMIC,
+	TINYDRM_GEM_DRIVER_OPS,
+	.lastclose		= tinydrm_lastclose,
+
+	.ioctls			= utinydrm_ioctls,
+	.num_ioctls		= ARRAY_SIZE(utinydrm_ioctls),
+
+	.name			= "utinydrm",
+	.desc			= "Userspace driver tinydrm",
+	.date			= "20161119",
+	.major			= 1,
+	.minor			= 0,
+};
+
+static const uint32_t utinydrm_formats[] = {
+	DRM_FORMAT_RGB565,
+	DRM_FORMAT_XRGB8888,
+};
+
+static int utinydrm_register(struct utinydrm_device *udev, struct utinydrm_dev_create *dev_create)
+{
+	struct tinydrm_device *tdev = &udev->tdev;
+	struct drm_display_mode display_mode;
+	struct device *dev = &udev->dev;
+	struct drm_device *drm;
+	struct drm_driver *drv;
+	int ret;
+
+	if (!dev->coherent_dma_mask) {
+		ret = dma_coerce_mask_and_coherent(dev, DMA_BIT_MASK(32));
+		if (ret)
+			dev_warn(dev, "Failed to set dma mask %d\n", ret);
+	}
+
+	drv = devm_kmalloc(&udev->dev, sizeof(*drv), GFP_KERNEL);
+	if (!drv)
+		return -ENOMEM;
+
+	*drv = utinydrm_driver;
+	drv->name = kstrdup(dev_create->name, GFP_KERNEL);
+	if (!drv->name)
+		return -ENOMEM;
+
+	ret = devm_tinydrm_init(&udev->dev, tdev, &utinydrm_fb_funcs, drv);
+	if (ret)
+		return ret;
+
+	drm = &tdev->drm;
+	drm->mode_config.funcs = &utinydrm_mode_config_funcs;
+
+	ret = drm_mode_convert_umode(&display_mode, &dev_create->mode);
+	if (ret)
+		return ret;
+
+	drm_mode_debug_printmodeline(&display_mode);
+
+	ret = tinydrm_display_pipe_init(tdev, &utinydrm_pipe_funcs,
+					DRM_MODE_CONNECTOR_VIRTUAL,
+					utinydrm_formats,
+					ARRAY_SIZE(utinydrm_formats), &display_mode,
+					0);
+	if (ret)
+		return ret;
+
+	drm->mode_config.preferred_depth = 16;
+
+	drm_mode_config_reset(drm);
+
+	tinydrm_debugfs_dirty_init(tdev);
+
+	DRM_DEBUG_KMS("preferred_depth=%u\n", drm->mode_config.preferred_depth);
+
+	ret = devm_tinydrm_register(tdev);
+
+	dev_create->index = drm->primary->index;
+
+	return ret;
+}
+
+static void utinydrm_unregister(struct utinydrm_device *udev)
+{
+	struct tinydrm_device *tdev = &udev->tdev;
+
+	devm_tinydrm_unregister(tdev);
+}
+
+/*********************************************************************************************************************************/
+
+static void utinydrm_release_work(struct work_struct *work)
+{
+	struct utinydrm_device *udev = container_of(work, struct utinydrm_device,
+						    release_work);
+	struct drm_device *drm = &udev->tdev.drm;
+
+	//drm_device_set_unplugged(drm);
+
+	while (drm->open_count) {
+		dev_dbg(drm->dev, "%s: open_count=%d\n", __func__, drm->open_count);
+		msleep(1000);
+	}
+
+	utinydrm_unregister(udev);
+
+
+	dev_dbg(&udev->dev, "%s: dev.refcount=%d\n", __func__, atomic_read(&udev->dev.kobj.kref.refcount));
+
+	device_unregister(&udev->dev);
+}
+
+static void utinydrm_device_release(struct device *dev)
+{
+	//struct utinydrm_device *udev = container_of(dev, struct utinydrm_device, dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+	/* FIXME: there's use after free */
+	//kfree(udev);
+}
+
+static int utinydrm_open(struct inode *inode, struct file *file)
+{
+	struct utinydrm_device *udev;
+	int ret;
+
+	udev = kzalloc(sizeof(*udev), GFP_KERNEL);
+	if (!udev)
+		return -ENOMEM;
+
+	/* FIXME: tinydrm currently needs a parent device */
+	dev_set_name(&udev->dev, "utinydrm%u", 0);
+	udev->dev.release = utinydrm_device_release;
+	ret = device_register(&udev->dev);
+	if (ret) {
+		put_device(&udev->dev);
+		kfree(udev);
+		return ret;
+	}
+
+	mutex_init(&udev->mutex);
+	init_waitqueue_head(&udev->waitq);
+	init_completion(&udev->completion);
+	idr_init(&udev->idr);
+	INIT_WORK(&udev->release_work, utinydrm_release_work);
+
+	file->private_data = udev;
+	nonseekable_open(inode, file);
+
+	return 0;
+}
+
+static ssize_t utinydrm_write(struct file *file, const char __user *buffer,
+			   size_t count, loff_t *ppos)
+{
+	struct utinydrm_device *udev = file->private_data;
+	int ret, event_ret;
+
+	dev_dbg(udev->tdev.drm.dev, "%s\n", __func__);
+
+	if (!udev->initialized)
+		return -EINVAL;
+
+	if (!count)
+		return 0;
+
+	if (count != sizeof(int))
+		return -EINVAL;
+
+	if (copy_from_user(&event_ret, buffer, sizeof(int)))
+		return -EFAULT;
+
+	ret = mutex_lock_interruptible(&udev->mutex);
+	if (ret)
+		return ret;
+
+	udev->event_ret = event_ret;
+	complete(&udev->completion);
+
+	mutex_unlock(&udev->mutex);
+
+	return count;
+}
+
+static ssize_t utinydrm_read(struct file *file, char __user *buffer, size_t count,
+			  loff_t *ppos)
+{
+	struct utinydrm_device *udev = file->private_data;
+	ssize_t ret;
+
+	dev_dbg(&udev->dev, "%s(count=%zu)\n", __func__, count);
+	if (!count)
+		return 0;
+
+	do {
+		ret = mutex_lock_interruptible(&udev->mutex);
+		if (ret)
+			return ret;
+
+		if (!udev->ev && (file->f_flags & O_NONBLOCK)) {
+			ret = -EAGAIN;
+		} else if (udev->ev) {
+			dev_dbg(&udev->dev, "%s udev->ev->length=%u\n", __func__, udev->ev->length);
+			if (count < udev->ev->length)
+				ret = -EINVAL;
+			else if (copy_to_user(buffer, udev->ev, udev->ev->length))
+				ret = -EFAULT;
+			else
+				ret = udev->ev->length;
+			kfree(udev->ev);
+			udev->ev = NULL;
+		}
+
+		mutex_unlock(&udev->mutex);
+
+		dev_dbg(&udev->dev, "%s: ret=%d\n", __func__, ret);
+		if (ret)
+			break;
+
+		if (!(file->f_flags & O_NONBLOCK))
+			ret = wait_event_interruptible(udev->waitq, udev->ev);
+		dev_dbg(&udev->dev, "%s: while: ret=%d\n", __func__, ret);
+	} while (ret == 0);
+
+	return ret;
+}
+
+static unsigned int utinydrm_poll(struct file *file, poll_table *wait)
+{
+	struct utinydrm_device *udev = file->private_data;
+
+	dev_dbg(udev->tdev.drm.dev, "%s\n", __func__);
+	poll_wait(file, &udev->waitq, wait);
+
+	if (udev->ev)
+		return POLLIN | POLLRDNORM;
+
+	return 0;
+}
+
+static int utinydrm_release(struct inode *inode, struct file *file)
+{
+	struct utinydrm_device *udev = file->private_data;
+	int i;
+
+	dev_dbg(&udev->dev, "%s: refcount=%d\n", __func__, atomic_read(&udev->dev.kobj.kref.refcount));
+
+	if (udev->initialized) {
+		schedule_work(&udev->release_work);
+	} else {
+		dev_dbg(&udev->dev, "%s: refcount=%d\n", __func__, atomic_read(&udev->dev.kobj.kref.refcount));
+
+		device_unregister(&udev->dev);
+		for (i = atomic_read(&udev->dev.kobj.kref.refcount); i > 0; i--)
+			put_device(&udev->dev);
+	}
+
+	return 0;
+}
+
+static long utinydrm_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	struct utinydrm_device *udev = file->private_data;
+	struct utinydrm_dev_create dev_create;
+	int ret = -EINVAL;
+
+	switch (cmd) {
+	case UTINYDRM_DEV_CREATE:
+
+		if (copy_from_user(&dev_create, (void __user *)arg, sizeof(dev_create)))
+			return -EFAULT;
+
+		ret = utinydrm_register(udev, &dev_create);
+		if (!ret) {
+			udev->initialized = true;
+			if (copy_to_user((void __user *)arg, &dev_create, sizeof(dev_create)))
+				ret = -EFAULT;
+		}
+
+		break;
+	}
+
+	return ret;
+}
+
+static const struct file_operations utinydrm_fops = {
+	.owner		= THIS_MODULE,
+	.open		= utinydrm_open,
+	.release	= utinydrm_release,
+	.read		= utinydrm_read,
+	.write		= utinydrm_write,
+	.poll		= utinydrm_poll,
+
+	.unlocked_ioctl	= utinydrm_ioctl,
+//#ifdef CONFIG_COMPAT
+//	.compat_ioctl	= utinydrm_compat_ioctl,
+//#endif
+
+	.llseek		= no_llseek,
+};
+
+static struct miscdevice utinydrm_misc = {
+	.fops		= &utinydrm_fops,
+	.minor		= MISC_DYNAMIC_MINOR,
+	.name		= "utinydrm",
+};
+
+static int __init utinydrm_init(void)
+{
+	return misc_register(&utinydrm_misc);
+}
+module_init(utinydrm_init);
+
+static void __exit utinydrm_exit(void)
+{
+	misc_deregister(&utinydrm_misc);
+}
+module_exit(utinydrm_exit);
+
+MODULE_AUTHOR("Noralf Tr√∏nnes");
+MODULE_DESCRIPTION("Userspace driver for tinydrm");
+MODULE_LICENSE("GPL");
diff --git a/include/drm/tinydrm/hx8340.h b/include/drm/tinydrm/hx8340.h
new file mode 100644
index 0000000..4fc975f
--- /dev/null
+++ b/include/drm/tinydrm/hx8340.h
@@ -0,0 +1,46 @@
+/*
+ * HX8340 LCD controller
+ *
+ * Copyright 2016 Noralf Tr√∏nnes
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __LINUX_HX8340_H
+#define __LINUX_HX8340_H
+
+#define HX8340_SETOSC      0xB0
+#define HX8340_SETPWCTR1   0xB1
+#define HX8340_SETPWCTR2   0xB2
+#define HX8340_SETPWCTR3   0xB3
+#define HX8340_SETPWCTR4   0xB4
+#define HX8340_SETPWCTR5   0xB5
+#define HX8340_SETDISCTRL  0xB6
+#define HX8340_SETFRMCTRL  0xB7
+#define HX8340_SETDISCYCC  0xB8
+#define HX8340_SETINVCTRL  0xB9
+#define HX8340_RGBBPCTR    0xBA
+#define HX8340_SETRGBIF    0xBB
+#define HX8340_SETDODC     0xBC
+#define HX8340_SETINTMODE  0xBD
+#define HX8340_SETPANEL    0xBE
+
+#define HX8340_SETONOFF    0xC0
+#define HX8340_SETEXTCMD   0xC1
+#define HX8340_SETGAMMAP   0xC2
+#define HX8340_SETGAMMAN   0xC3
+#define HX8340_SETOTP      0xC7
+
+#define HX8340_RDID1       0xDA
+#define HX8340_RDID2       0xDB
+#define HX8340_RDID3       0xDC
+
+#define HX8340_MADCTL_BGR  BIT(3)
+#define HX8340_MADCTL_MV   BIT(5)
+#define HX8340_MADCTL_MX   BIT(6)
+#define HX8340_MADCTL_MY   BIT(7)
+
+#endif /* __LINUX_HX8340_H */
diff --git a/include/drm/tinydrm/ili9341.h b/include/drm/tinydrm/ili9341.h
new file mode 100644
index 0000000..807a09f
--- /dev/null
+++ b/include/drm/tinydrm/ili9341.h
@@ -0,0 +1,54 @@
+/*
+ * ILI9341 LCD controller
+ *
+ * Copyright 2016 Noralf Tr√∏nnes
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __LINUX_ILI9341_H
+#define __LINUX_ILI9341_H
+
+#define ILI9341_FRMCTR1    0xb1
+#define ILI9341_FRMCTR2    0xb2
+#define ILI9341_FRMCTR3    0xb3
+#define ILI9341_INVTR      0xb4
+#define ILI9341_PRCTR      0xb5
+#define ILI9341_DISCTRL    0xb6
+#define ILI9341_ETMOD      0xb7
+
+#define ILI9341_PWCTRL1    0xc0
+#define ILI9341_PWCTRL2    0xc1
+#define ILI9341_VMCTRL1    0xc5
+#define ILI9341_VMCTRL2    0xc7
+#define ILI9341_PWCTRLA    0xcb
+#define ILI9341_PWCTRLB    0xcf
+
+#define ILI9341_RDID1      0xda
+#define ILI9341_RDID2      0xdb
+#define ILI9341_RDID3      0xdc
+#define ILI9341_RDID4      0xd3
+
+#define ILI9341_PGAMCTRL   0xe0
+#define ILI9341_NGAMCTRL   0xe1
+#define ILI9341_DGAMCTRL1  0xe2
+#define ILI9341_DGAMCTRL2  0xe3
+#define ILI9341_DTCTRLA    0xe8
+#define ILI9341_DTCTRLB    0xea
+#define ILI9341_PWRSEQ     0xed
+
+#define ILI9341_EN3GAM     0xf2
+#define ILI9341_IFCTRL     0xf6
+#define ILI9341_PUMPCTRL   0xf7
+
+#define ILI9341_MADCTL_MH  BIT(2)
+#define ILI9341_MADCTL_BGR BIT(3)
+#define ILI9341_MADCTL_ML  BIT(4)
+#define ILI9341_MADCTL_MV  BIT(5)
+#define ILI9341_MADCTL_MX  BIT(6)
+#define ILI9341_MADCTL_MY  BIT(7)
+
+#endif /* __LINUX_ILI9341_H */
diff --git a/include/drm/tinydrm/mipi-dbi.h b/include/drm/tinydrm/mipi-dbi.h
new file mode 100644
index 0000000..e3de909
--- /dev/null
+++ b/include/drm/tinydrm/mipi-dbi.h
@@ -0,0 +1,82 @@
+/*
+ * MIPI Display Bus Interface (DBI) LCD controller support
+ *
+ * Copyright 2016 Noralf Tr√∏nnes
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __LINUX_MIPI_DBI_H
+#define __LINUX_MIPI_DBI_H
+
+#include <drm/tinydrm/tinydrm.h>
+
+struct drm_gem_cma_object;
+struct drm_framebuffer;
+struct drm_clip_rect;
+struct spi_device;
+struct gpio_desc;
+struct regulator;
+
+/**
+ * mipi_dbi - MIPI DBI controller
+ * @tinydrm: tinydrm base
+ * @reg: register map
+ * @reset: Optional reset gpio
+ * @rotation: initial rotation in degress Counter Clock Wise
+ * @backlight: backlight device (optional)
+ * @enable_delay_ms: Optional delay in milliseconds before turning on backlight
+ * @regulator: power regulator (optional)
+ */
+struct mipi_dbi {
+	struct tinydrm_device tinydrm;
+	struct regmap *reg;
+	struct gpio_desc *reset;
+	unsigned int rotation;
+	struct backlight_device *backlight;
+	unsigned int enable_delay_ms;
+	struct regulator *regulator;
+};
+
+static inline struct mipi_dbi *
+mipi_dbi_from_tinydrm(struct tinydrm_device *tdev)
+{
+	return container_of(tdev, struct mipi_dbi, tinydrm);
+}
+
+struct regmap *mipi_dbi_spi_init(struct spi_device *spi, struct gpio_desc *dc,
+				 bool write_only);
+int mipi_dbi_init(struct device *dev, struct mipi_dbi *mipi,
+		  const struct drm_simple_display_pipe_funcs *pipe_funcs,
+		  struct drm_driver *driver,
+		  const struct drm_display_mode *mode, unsigned int rotation);
+void mipi_dbi_pipe_disable(struct drm_simple_display_pipe *pipe);
+void mipi_dbi_hw_reset(struct mipi_dbi *mipi);
+bool mipi_dbi_display_is_on(struct regmap *reg);
+
+/**
+ * mipi_dbi_write - Write command and optional parameter(s)
+ * @cmd: Command
+ * @...: Parameters
+ */
+#define mipi_dbi_write(reg, cmd, seq...) \
+({ \
+	u8 d[] = { seq }; \
+	mipi_dbi_write_buf(reg, cmd, d, ARRAY_SIZE(d)); \
+})
+
+int mipi_dbi_write_buf(struct regmap *reg, unsigned int cmd,
+		       const u8 *parameters, size_t num);
+
+#ifdef CONFIG_DEBUG_FS
+int mipi_dbi_debugfs_init(struct drm_minor *minor);
+void mipi_dbi_debugfs_cleanup(struct drm_minor *minor);
+#else
+#define mipi_dbi_debugfs_init		NULL
+#define mipi_dbi_debugfs_cleanup	NULL
+#endif
+
+#endif /* __LINUX_MIPI_DBI_H */
diff --git a/include/drm/tinydrm/st7735r.h b/include/drm/tinydrm/st7735r.h
new file mode 100644
index 0000000..f2ba535
--- /dev/null
+++ b/include/drm/tinydrm/st7735r.h
@@ -0,0 +1,44 @@
+/*
+ * ST7735R LCD controller
+ *
+ * Copyright 2016 Noralf Tr√∏nnes
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __LINUX_ST7735R_H
+#define __LINUX_ST7735R_H
+
+#define ST7735R_FRMCTR1		0xB1
+#define ST7735R_FRMCTR2		0xB2
+#define ST7735R_FRMCTR3		0xB3
+#define ST7735R_INVCTR		0xB4
+
+#define ST7735R_PWCTR1		0xC0
+#define ST7735R_PWCTR2		0xC1
+#define ST7735R_PWCTR3		0xC2
+#define ST7735R_PWCTR4		0xC3
+#define ST7735R_PWCTR5		0xC4
+#define ST7735R_VMCTR1		0xC5
+#define ST7735R_VMOFCTR		0xC7
+
+#define ST7735R_WRID2		0xD1
+#define ST7735R_WRID3		0xD2
+#define ST7735R_NVCTR1		0xD9
+#define ST7735R_RDID1		0xDA
+#define ST7735R_RDID2		0xDB
+#define ST7735R_RDID3		0xDC
+#define ST7735R_NVCTR2		0xDE
+#define ST7735R_NVCTR3		0xDF
+
+#define ST7735R_GAMCTRP1	0xE0
+#define ST7735R_GAMCTRN1	0xE1
+
+#define ST7735R_MADCTL_MV	BIT(5)
+#define ST7735R_MADCTL_MX	BIT(6)
+#define ST7735R_MADCTL_MY	BIT(7)
+
+#endif /* __LINUX_ST7735R_H */
diff --git a/include/drm/tinydrm/tinydrm-helpers.h b/include/drm/tinydrm/tinydrm-helpers.h
new file mode 100644
index 0000000..2cf416a
--- /dev/null
+++ b/include/drm/tinydrm/tinydrm-helpers.h
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2016 Noralf Tr√∏nnes
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __LINUX_TINYDRM_HELPERS_H
+#define __LINUX_TINYDRM_HELPERS_H
+
+struct backlight_device;
+struct tinydrm_device;
+struct drm_clip_rect;
+struct dev_pm_ops;
+struct spi_device;
+struct device;
+
+void tinydrm_merge_clips(struct drm_clip_rect *dst,
+			 struct drm_clip_rect *src, unsigned int num_clips,
+			 unsigned int flags, u32 max_width, u32 max_height);
+void tinydrm_xrgb8888_to_rgb565(u32 *src, u16 *dst, unsigned int num_pixels);
+
+#ifdef CONFIG_BACKLIGHT_CLASS_DEVICE
+struct backlight_device *tinydrm_of_find_backlight(struct device *dev);
+int tinydrm_enable_backlight(struct backlight_device *backlight);
+void tinydrm_disable_backlight(struct backlight_device *backlight);
+#else
+static inline struct backlight_device *
+tinydrm_of_find_backlight(struct device *dev)
+{
+	return NULL;
+}
+
+static inline int tinydrm_enable_backlight(struct backlight_device *backlight)
+{
+	return 0;
+}
+
+static inline void
+tinydrm_disable_backlight(struct backlight_device *backlight)
+{
+}
+#endif
+
+extern const struct dev_pm_ops tinydrm_simple_pm_ops;
+void tinydrm_spi_shutdown(struct spi_device *spi);
+
+#endif /* __LINUX_TINYDRM_HELPERS_H */
diff --git a/include/drm/tinydrm/tinydrm-regmap.h b/include/drm/tinydrm/tinydrm-regmap.h
new file mode 100644
index 0000000..70a67ed
--- /dev/null
+++ b/include/drm/tinydrm/tinydrm-regmap.h
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2016 Noralf Tr√∏nnes
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __LINUX_TINYDRM_REGMAP_H
+#define __LINUX_TINYDRM_REGMAP_H
+
+#include <linux/regmap.h>
+
+struct drm_framebuffer;
+struct drm_clip_rect;
+struct spi_transfer;
+struct spi_message;
+struct spi_device;
+
+int tinydrm_regmap_flush_rgb565(struct regmap *reg, u32 regnr,
+				struct drm_framebuffer *fb, void *vmem,
+				struct drm_clip_rect *clip);
+size_t tinydrm_spi_max_transfer_size(struct spi_device *spi, size_t max_len);
+bool tinydrm_spi_bpw_supported(struct spi_device *spi, u8 bpw);
+int tinydrm_spi_transfer(struct spi_device *spi, u32 speed_hz,
+			 struct spi_transfer *header, u8 bpw, const void *buf,
+			 size_t len, u16 *swap_buf, size_t max_chunk);
+void tinydrm_debug_reg_write(const void *reg, size_t reg_len, const void *val,
+			     size_t val_len, size_t val_width);
+void _tinydrm_dbg_spi_message(struct spi_device *spi, struct spi_message *m);
+
+/**
+ * tinydrm_get_machine_endian - Get machine endianness
+ *
+ * Returns:
+ * REGMAP_ENDIAN_LITTLE or REGMAP_ENDIAN_BIG
+ */
+static inline enum regmap_endian tinydrm_get_machine_endian(void)
+{
+#if defined(__LITTLE_ENDIAN)
+	return REGMAP_ENDIAN_LITTLE;
+#else
+	return REGMAP_ENDIAN_BIG;
+#endif
+}
+
+#if defined(DEBUG)
+/**
+ * TINYDRM_DEBUG_REG_WRITE - Print info about register write
+ * @reg: Register number buffer
+ * @reg_len: Length of @reg buffer
+ * @val: Value buffer
+ * @val_len: Length of @val buffer
+ * @val_width: Word width of @val buffer
+ *
+ * This macro prints info to the log about a register write. Can be used in
+ * &regmap_bus ->gather_write functions. It's a wrapper around
+ * tinydrm_debug_reg_write().
+ * DEBUG has to be defined for this macro to be enabled alongside setting
+ * the DRM_UT_CORE bit of drm_debug.
+ */
+#define TINYDRM_DEBUG_REG_WRITE(reg, reg_len, val, val_len, val_width) \
+	do { \
+		if (unlikely(drm_debug & DRM_UT_CORE)) \
+			tinydrm_debug_reg_write(reg, reg_len, \
+						val, val_len, val_width); \
+	} while (0)
+
+/**
+ * tinydrm_dbg_spi_message - Dump SPI message
+ * @spi: SPI device
+ * @m: SPI message
+ *
+ * Dumps info about the transfers in a SPI message including start of buffers.
+ * DEBUG has to be defined for this function to be enabled alongside setting
+ * the DRM_UT_CORE bit of drm_debug.
+ */
+static inline void tinydrm_dbg_spi_message(struct spi_device *spi,
+					   struct spi_message *m)
+{
+	if (drm_debug & DRM_UT_CORE)
+		_tinydrm_dbg_spi_message(spi, m);
+}
+#else
+#define TINYDRM_DEBUG_REG_WRITE(reg, reg_len, val, val_len, val_width) \
+	do { \
+		if (0) \
+			tinydrm_debug_reg_write(reg, reg_len, \
+						val, val_len, val_width); \
+	} while (0)
+
+static inline void tinydrm_dbg_spi_message(struct spi_device *spi,
+					   struct spi_message *m)
+{
+}
+#endif
+
+#endif /* __LINUX_TINYDRM_REGMAP_H */
diff --git a/include/drm/tinydrm/tinydrm.h b/include/drm/tinydrm/tinydrm.h
new file mode 100644
index 0000000..1555742
--- /dev/null
+++ b/include/drm/tinydrm/tinydrm.h
@@ -0,0 +1,177 @@
+/*
+ * Copyright (C) 2016 Noralf Tr√∏nnes
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __LINUX_TINYDRM_H
+#define __LINUX_TINYDRM_H
+
+#include <drm/drm_crtc.h>
+#include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_simple_kms_helper.h>
+
+struct tinydrm_debugfs_dirty;
+
+/**
+ * struct tinydrm_device - tinydrm device
+ * @drm: DRM device
+ * @pipe: Display pipe structure
+ * @dirty_work: framebuffer flusher
+ * @dev_lock: serializes device access and protects
+ *            prepared/enabled state changes
+ * @prepared: device prepared state (prepared for framebuffer flushing)
+ * @enabled: device enabled state (display is on)
+ * @fbdev_cma: fbdev CMA structure
+ * @fbdev_helper: fbdev helper (from the private fbdev CMA structure).
+ * @fbdev_used: fbdev has actually been used
+ * @suspend_state: atomic state when suspended
+ * @debugfs_dirty: debugfs dirty file control structure
+ */
+struct tinydrm_device {
+	struct drm_device drm;
+	struct drm_simple_display_pipe pipe;
+	struct work_struct dirty_work;
+	struct mutex dev_lock;
+	bool prepared;
+	bool enabled;
+	struct drm_fbdev_cma *fbdev_cma;
+	struct drm_fb_helper *fbdev_helper;
+	bool fbdev_used;
+	struct drm_atomic_state *suspend_state;
+	struct tinydrm_debugfs_dirty *debugfs_dirty;
+/* private: */
+	const struct drm_framebuffer_funcs *fb_funcs;
+};
+
+static inline struct tinydrm_device *
+drm_to_tinydrm(struct drm_device *drm)
+{
+	return container_of(drm, struct tinydrm_device, drm);
+}
+
+static inline struct tinydrm_device *
+pipe_to_tinydrm(struct drm_simple_display_pipe *pipe)
+{
+	return container_of(pipe, struct tinydrm_device, pipe);
+}
+
+/*
+ * TINYDRM_GEM_DRIVER_OPS - default tinydrm gem operations
+ *
+ * This macro provides a shortcut for setting the tinydrm GEM operations in
+ * the &drm_driver structure.
+ */
+#define TINYDRM_GEM_DRIVER_OPS \
+	.gem_free_object	= tinydrm_gem_cma_free_object, \
+	.gem_vm_ops		= &drm_gem_cma_vm_ops, \
+	.prime_handle_to_fd	= drm_gem_prime_handle_to_fd, \
+	.prime_fd_to_handle	= drm_gem_prime_fd_to_handle, \
+	.gem_prime_import	= drm_gem_prime_import, \
+	.gem_prime_export	= drm_gem_prime_export, \
+	.gem_prime_get_sg_table	= drm_gem_cma_prime_get_sg_table, \
+	.gem_prime_import_sg_table = tinydrm_gem_cma_prime_import_sg_table, \
+	.gem_prime_vmap		= drm_gem_cma_prime_vmap, \
+	.gem_prime_vunmap	= drm_gem_cma_prime_vunmap, \
+	.gem_prime_mmap		= drm_gem_cma_prime_mmap, \
+	.dumb_create		= drm_gem_cma_dumb_create, \
+	.dumb_map_offset	= drm_gem_cma_dumb_map_offset, \
+	.dumb_destroy		= drm_gem_dumb_destroy, \
+	.fops			= &tinydrm_fops
+
+/**
+ * TINYDRM_MODE - tinydrm display mode
+ * @hd: horizontal resolution, width
+ * @vd: vertical resolution, height
+ * @hd_mm: display width in millimeters
+ * @vd_mm: display height in millimeters
+ *
+ * This macro creates a &drm_display_mode for use with tinydrm.
+ */
+#define TINYDRM_MODE(hd, vd, hd_mm, vd_mm) \
+	.hdisplay = (hd), \
+	.hsync_start = (hd), \
+	.hsync_end = (hd), \
+	.htotal = (hd), \
+	.vdisplay = (vd), \
+	.vsync_start = (vd), \
+	.vsync_end = (vd), \
+	.vtotal = (vd), \
+	.width_mm = (hd_mm), \
+	.height_mm = (vd_mm), \
+	.type = DRM_MODE_TYPE_DRIVER, \
+	.clock = 1 /* pass validation */
+
+extern const struct file_operations tinydrm_fops;
+void tinydrm_lastclose(struct drm_device *drm);
+void tinydrm_gem_cma_free_object(struct drm_gem_object *gem_obj);
+struct drm_gem_object *
+tinydrm_gem_cma_prime_import_sg_table(struct drm_device *drm,
+				      struct dma_buf_attachment *attach,
+				      struct sg_table *sgt);
+struct drm_framebuffer *
+tinydrm_fb_create(struct drm_device *drm, struct drm_file *file_priv,
+		  const struct drm_mode_fb_cmd2 *mode_cmd);
+bool tinydrm_check_dirty(struct drm_framebuffer *fb,
+			 struct drm_clip_rect **clips,
+			 unsigned int *num_clips);
+struct drm_connector *
+tinydrm_connector_create(struct drm_device *drm,
+			 const struct drm_display_mode *mode,
+			 int connector_type);
+void tinydrm_display_pipe_update(struct drm_simple_display_pipe *pipe,
+				 struct drm_plane_state *old_state);
+int
+tinydrm_display_pipe_init(struct tinydrm_device *tdev,
+			  const struct drm_simple_display_pipe_funcs *funcs,
+			  int connector_type,
+			  const uint32_t *formats,
+			  unsigned int format_count,
+			  const struct drm_display_mode *mode,
+			  unsigned int rotation);
+int devm_tinydrm_init(struct device *parent, struct tinydrm_device *tdev,
+		      const struct drm_framebuffer_funcs *fb_funcs,
+		      struct drm_driver *driver);
+int devm_tinydrm_register(struct tinydrm_device *tdev);
+void devm_tinydrm_unregister(struct tinydrm_device *tdev);
+void tinydrm_shutdown(struct tinydrm_device *tdev);
+int tinydrm_suspend(struct tinydrm_device *tdev);
+int tinydrm_resume(struct tinydrm_device *tdev);
+
+int tinydrm_fbdev_init(struct tinydrm_device *tdev);
+void tinydrm_fbdev_fini(struct tinydrm_device *tdev);
+
+#ifdef CONFIG_DEBUG_FS
+int tinydrm_debugfs_init(struct drm_minor *minor);
+void tinydrm_debugfs_dirty_begin(struct tinydrm_device *tdev,
+				 struct drm_framebuffer *fb,
+				 const struct drm_clip_rect *clip);
+void tinydrm_debugfs_dirty_end(struct tinydrm_device *tdev, size_t len,
+			       unsigned int bits_per_pixel);
+void tinydrm_debugfs_cleanup(struct drm_minor *minor);
+int tinydrm_debugfs_dirty_init(struct tinydrm_device *tdev);
+#else
+int tinydrm_debugfs_dirty_init(struct tinydrm_device *tdev)
+{
+	return 0;
+}
+
+void tinydrm_debugfs_dirty_begin(struct tinydrm_device *tdev,
+				 struct drm_framebuffer *fb,
+				 const struct drm_clip_rect *clip)
+{
+}
+
+void tinydrm_debugfs_dirty_end(struct tinydrm_device *tdev, size_t len,
+			       unsigned int bits_per_pixel)
+{
+}
+
+#define tinydrm_debugfs_init	NULL
+#define tinydrm_debugfs_cleanup	NULL
+#endif /* CONFIG_DEBUG_FS */
+
+#endif /* __LINUX_TINYDRM_H */
diff --git a/include/uapi/drm/utinydrm.h b/include/uapi/drm/utinydrm.h
new file mode 100644
index 0000000..7d57886
--- /dev/null
+++ b/include/uapi/drm/utinydrm.h
@@ -0,0 +1,73 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef _UAPI__UTINYDRM_H_
+#define _UAPI__UTINYDRM_H_
+
+#if defined(__KERNEL__)
+#include <uapi/drm/drm_mode.h>
+#include <linux/types.h>
+#else
+#include <linux/types.h>
+#include <drm/drm_mode.h>
+#endif
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+#define UTINYDRM_MAX_NAME_SIZE    80
+
+/* ioctl */
+/* FIXME: what should this be? */
+#define UTINYDRM_IOCTL_BASE       'U'
+
+struct utinydrm_dev_create {
+	char name[UTINYDRM_MAX_NAME_SIZE];
+	struct drm_mode_modeinfo mode;
+	int index;
+};
+
+#define UTINYDRM_DEV_CREATE       _IOWR(UTINYDRM_IOCTL_BASE, 1, struct utinydrm_dev_create)
+
+struct utinydrm_event {
+	__u32 type;
+	__u32 length;
+};
+
+#define UTINYDRM_EVENT_PIPE_ENABLE	1
+#define UTINYDRM_EVENT_PIPE_DISABLE	2
+#define UTINYDRM_EVENT_FB_CREATE	3
+
+struct utinydrm_event_fb_create {
+	struct utinydrm_event base;
+	struct drm_mode_fb_cmd2 fb;
+};
+
+#define UTINYDRM_EVENT_FB_DESTROY	4
+
+struct utinydrm_event_fb_destroy {
+	struct utinydrm_event base;
+	__u32 fb_id;
+};
+
+#define UTINYDRM_EVENT_FB_DIRTY 	5
+
+struct utinydrm_event_fb_dirty {
+	struct utinydrm_event base;
+	struct drm_mode_fb_dirty_cmd fb_dirty_cmd;
+	struct drm_clip_rect clips[];
+};
+
+#define UTINYDRM_PRIME_HANDLE_TO_FD 0x01
+#define DRM_IOCTL_UTINYDRM_PRIME_HANDLE_TO_FD    DRM_IOWR(DRM_COMMAND_BASE + UTINYDRM_PRIME_HANDLE_TO_FD, struct drm_prime_handle)
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif /* _UAPI__UTINYDRM_H_ */
-- 
2.10.2

